"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[9503],{2765:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=s(5893),l=s(1151);const a={sidebar_position:3.1},r="An Informal Introduction to Common Lisp",c={id:"tutorial/informal-introduction-to-lisp",title:"An Informal Introduction to Common Lisp",description:'This article is a stub. Please help contribute in our repository or by clicking on the "Edit this page" link below.',source:"@site/docs/tutorial/informal-introduction-to-lisp.md",sourceDirName:"tutorial",slug:"/tutorial/informal-introduction-to-lisp",permalink:"/docs/tutorial/informal-introduction-to-lisp",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/informal-introduction-to-lisp.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:3.1,frontMatter:{sidebar_position:3.1},sidebar:"tutorialSidebar",previous:{title:"Using a Common Lisp Implementation",permalink:"/docs/tutorial/using-cl-implementation"},next:{title:"Control Flow",permalink:"/docs/tutorial/control-flows"}},t={},d=[{value:"1 Using Common Lisp as a Calculator",id:"1-using-common-lisp-as-a-calculator",level:2},{value:"1.1 Numbers",id:"11-numbers",level:2},{value:"1.2. Text",id:"12-text",level:2},{value:"1.3. Lists",id:"13-lists",level:2},{value:"1.4. First Steps Towards Programming",id:"14-first-steps-towards-programming",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"an-informal-introduction-to-common-lisp",children:"An Informal Introduction to Common Lisp"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["This article is a stub. Please help contribute in ",(0,i.jsx)(n.a,{href:"https://github.com/lisp-docs/lisp-docs.github.io",children:"our repository"}),' or by clicking on the "Edit this page" link below.\nThe article itself is similar to the python tutorial, ',(0,i.jsx)(n.strong,{children:"but it needs to be checked!"})]})}),"\n",(0,i.jsxs)(n.p,{children:["In the following examples, input and output are distinguished by the presence or absence of prompts.  To repeat the example, you must type everything after the prompt, when the prompt appears; lines that do not begin with a prompt are output from the Lisp system.  In Common Lisp, the standard interactive prompt is often ",(0,i.jsx)(n.code,{children:">"})," (though this can vary between implementations). We will use ",(0,i.jsx)(n.code,{children:">"})," here."]}),"\n",(0,i.jsx)(n.p,{children:"You can copy and paste the input lines into your Lisp environment (often called a REPL, for Read-Eval-Print Loop)."}),"\n",(0,i.jsxs)(n.p,{children:["Many of the examples in this manual, even those entered at the interactive prompt, include comments. Comments in Common Lisp start with a semicolon ",(0,i.jsx)(n.code,{children:";"})," and extend to the end of the line. A single semicolon is typically used for short comments on the same line as code. Two semicolons ",(0,i.jsx)(n.code,{children:";;"})," are used for comments that form a paragraph on their own and describe a section of code. Three semicolons ",(0,i.jsx)(n.code,{children:";;;"})," are used for file-level comments introducing a file or a major section of code within a file. A comment may appear at the start of a line or following whitespace or code, but not within a string literal. A semicolon within a string literal is just a semicolon."]}),"\n",(0,i.jsx)(n.p,{children:"Since comments are to clarify code and are not interpreted by Lisp, they may be omitted when typing in examples."}),"\n",(0,i.jsx)(n.p,{children:"Some examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'; this is the first comment\n(defvar spam 1) ; and this is the second comment\n          ;; ... and now a third!\n(defvar text "# This is not a comment because it\'s inside quotes.")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you may have guessed the form ",(0,i.jsx)(n.code,{children:"defvar"})," above defines a variable. We'll delve into this a bit later."]}),"\n",(0,i.jsx)(n.h2,{id:"1-using-common-lisp-as-a-calculator",children:"1 Using Common Lisp as a Calculator"}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s try some simple Common Lisp commands. Start your Lisp environment (often a REPL) and wait for the prompt, often ",(0,i.jsx)(n.code,{children:">"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"11-numbers",children:"1.1 Numbers"}),"\n",(0,i.jsxs)(n.p,{children:["The Lisp environment acts as a simple calculator: you can type an expression at it and it will print the value. Expression syntax uses prefix notation (also known as Polish notation): the operator comes before the operands. Parentheses ",(0,i.jsx)(n.code,{children:"()"})," are used for grouping and function calls. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(+ 2 2)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"4\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(- 50 (* 5 6))\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"20\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(/ (- 50 (* 5 6)) 4)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"5\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(/ 8 5) ; division by default yields a ratio or a float if appropriate\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output (depending on the implementation and settings):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"8/5  ; Ratio\n"})}),"\n",(0,i.jsx)(n.p,{children:"or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"1.6 ; Float\n"})}),"\n",(0,i.jsx)(n.p,{children:"Common Lisp has several numeric types: integers (e.g., 2, 4, 20), ratios (e.g. 8/5), and floating-point numbers (e.g., 1.6, 5.0)."}),"\n",(0,i.jsxs)(n.p,{children:["To get an integer quotient (floor division) you can use ",(0,i.jsx)(n.code,{children:"floor"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(floor 17 3)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"5\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"floor"})," actually returns two values: the quotient and the remainder. To get just the remainder, use ",(0,i.jsx)(n.code,{children:"mod"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(mod 17 3)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To get both the quotient and remainder use ",(0,i.jsx)(n.code,{children:"multiple-value-bind"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(multiple-value-bind (quotient remainder) (floor 17 3)\n  (format t "Quotient: ~a, Remainder: ~a~%" quotient remainder))\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"Quotient: 5, Remainder: 2\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(+ (* 5 3) 2) ;floored quotient * divisor + remainder\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"17\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In Common Lisp, you can use ",(0,i.jsx)(n.code,{children:"expt"})," to calculate powers:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(expt 5 2) ; 5 squared\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"25\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(expt 2 7) ; 2 to the power of 7\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"128\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The special operator ",(0,i.jsx)(n.code,{children:"setf"})," is used to assign a value to a variable:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf width 20)\n(setf height (* 5 9))\n(* width height)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"900\n"})}),"\n",(0,i.jsx)(n.p,{children:"If a variable is not defined (assigned a value), trying to use it will signal an unbound-variable error:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"n ; try to access an undefined variable\n"})}),"\n",(0,i.jsx)(n.p,{children:"This will signal an error similar to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"The variable N is unbound.\n"})}),"\n",(0,i.jsx)(n.p,{children:"Common Lisp has full support for floating-point numbers. Operations with mixed numeric types generally result in a floating-point number if one of the operands is a float:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(- (* 4 3.75) 1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"14.0\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the REPL, the value of the last evaluated expression is available through the special variable ",(0,i.jsx)(n.code,{children:"*"}),". This is similar to ",(0,i.jsx)(n.code,{children:"_"})," in Python's interactive mode."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf tax (/ 12.5 100))\n(setf price 100.50)\n(* price tax)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"12.5625\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(+ price *)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"113.0625\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(round * 2) ; Rounding to two decimal places\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"113.06\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Like Python, you should treat ",(0,i.jsx)(n.code,{children:"*"})," as read-only. Avoid assigning to it explicitly."]}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp supports other numeric types, including complex numbers. The imaginary unit is represented as ",(0,i.jsx)(n.code,{children:"#C(0 1)"})," or ",(0,i.jsx)(n.code,{children:"0+1i"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(* #C(0 1) #C(0 1)) ; i * i = -1\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"-1\n"})}),"\n",(0,i.jsx)(n.p,{children:"or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"#C(-1 0)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"12-text",children:"1.2. Text"}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp can manipulate text (represented by the type ",(0,i.jsx)(n.code,{children:"string"}),") as well as numbers. This includes characters \u201c!\u201d, words \u201crabbit\u201d, names \u201cParis\u201d, sentences \u201cGot your back.\u201d, etc. \u201cYay! :)\u201d. They are enclosed in double quotes ",(0,i.jsx)(n.code,{children:'"..."'}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"spam eggs"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"spam eggs"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Paris rabbit got your back :)! Yay!"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Paris rabbit got your back :)! Yay!"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"1975" ; digits and numerals enclosed in quotes are also strings\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"1975"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To include a double quote within a string, you need to escape it using a backslash ",(0,i.jsx)(n.code,{children:"\\"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"doesn\'t"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"doesn\'t"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"\\"Yes,\\" they said."\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"\\"Yes,\\" they said."\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"\\"Isn\'t,\\" they said."\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"\\"Isn\'t,\\" they said."\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the Lisp REPL, the string definition and output string are the same. The ",(0,i.jsx)(n.code,{children:"print"})," function produces a more readable output, but for strings, it doesn't remove the quotes unless you use ",(0,i.jsx)(n.code,{children:"princ"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf s "First line.\\nSecond line.") ; \\n means newline\n\ns ; without print, special characters are included in the string\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"First line.\\nSecond line."\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(print s) ; with print, special characters are interpreted, so \\n produces new line, and quotes are printed\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"First line.\nSecond line."\n\n```lisp\n\n```lisp\n(princ s) ; with princ, special characters are interpreted, so \\n produces new line, and quotes are not printed\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"First line.\nSecond line.\n"})}),"\n",(0,i.jsxs)(n.p,{children:['Common Lisp doesn\'t have "raw strings" in the same way as Python. Backslashes are always interpreted as escape characters unless they are themselves escaped (e.g., ',(0,i.jsx)(n.code,{children:"\\\\"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"String literals can span multiple lines using backslashes at the end of each line to continue the string:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf long-string "Usage: thingy [OPTIONS]\\\n\\\n     -h                        Display this usage message\\\n\\\n     -H hostname               Hostname to connect to")\n(print long-string)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Usage: thingy [OPTIONS]\n\n     -h                        Display this usage message\n\n     -H hostname               Hostname to connect to"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Strings can be concatenated (joined together) using ",(0,i.jsx)(n.code,{children:"concatenate"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(concatenate \'string "un" "un" "un" "ium")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"unununium"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["There is no automatic concatenation of adjacent string literals in Common Lisp. You must always use ",(0,i.jsx)(n.code,{children:"concatenate"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(concatenate \'string "Py" "thon")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Python"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf prefix "Py")\n(concatenate \'string prefix "thon")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Python"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Strings can be accessed by index using ",(0,i.jsx)(n.code,{children:"aref"}),". The first character has index 0:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf word "Python")\n(aref word 0) ; character in position 0\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"#\\P\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(aref word 5) ; character in position 5\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"#\\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Indices can't be negative in Common Lisp's ",(0,i.jsx)(n.code,{children:"aref"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To get a substring (slicing), use ",(0,i.jsx)(n.code,{children:"subseq"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subseq word 0 2) ; characters from position 0 (included) to 2 (excluded)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Py"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subseq word 2 5) ; characters from position 2 (included) to 5 (excluded)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"tho"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Slice indices have useful defaults; an omitted first index defaults to zero, and an omitted second index defaults to the length of the string:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subseq word 0)   ; characters from the beginning to the end\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Python"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subseq word 4)   ; characters from position 4 (included) to the end\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"on"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp strings ",(0,i.jsx)(n.em,{children:"are"})," mutable. You can change individual characters using ",(0,i.jsx)(n.code,{children:"(setf (aref string index) new-character)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf word "Python")\n(setf (aref word 0) #\\J)\nword\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'"Jython"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The function ",(0,i.jsx)(n.code,{children:"length"})," returns the length of a string:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf s "supercalifragilisticexpialidocious")\n(length s)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"34\n"})}),"\n",(0,i.jsx)(n.h2,{id:"13-lists",children:"1.3. Lists"}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp uses ",(0,i.jsx)(n.em,{children:"lists"})," as its primary compound data type to group together other values. Lists are written as a sequence of space-separated values (items) enclosed in parentheses. Lists can contain items of different types."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf squares (list 1 4 9 16 25))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Evaluating ",(0,i.jsx)(n.code,{children:"squares"})," in the REPL:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"squares\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(1 4 9 16 25)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Like strings (and other sequence types), lists can be accessed by index using ",(0,i.jsx)(n.code,{children:"elt"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(elt squares 0) ; indexing returns the item\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp does ",(0,i.jsx)(n.em,{children:"not"})," support negative indexing with ",(0,i.jsx)(n.code,{children:"elt"}),". To access elements from the end, use ",(0,i.jsx)(n.code,{children:"nth"})," with a calculated index or ",(0,i.jsx)(n.code,{children:"nthcdr"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(nth (- (length squares) 1) squares) ; last element (equivalent to squares[-1] in Python)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"25\n"})}),"\n",(0,i.jsx)(n.p,{children:"or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(car (last squares))\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"25\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To get a sublist (slicing), use ",(0,i.jsx)(n.code,{children:"subseq"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subseq squares 2 5) ; slicing returns a new list (equivalent to squares[2:5] in Python)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(9 16 25)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Lists can be concatenated using ",(0,i.jsx)(n.code,{children:"append"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(append squares (list 36 49 64 81 100))\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(1 4 9 16 25 36 49 64 81 100)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Lists in Common Lisp are mutable. You can change their content using ",(0,i.jsx)(n.code,{children:"setf"})," with ",(0,i.jsx)(n.code,{children:"elt"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf cubes (list 1 8 27 65 125)) ; something's wrong here\n\n(expt 4 3) ; the cube of 4 is 64, not 65!\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"64\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf (elt cubes 3) 64) ; replace the wrong value\n\ncubes\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(1 8 27 64 125)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can add new items to a list using ",(0,i.jsx)(n.code,{children:"push"})," or ",(0,i.jsx)(n.code,{children:"append"}),". ",(0,i.jsx)(n.code,{children:"push"})," adds to the beginning, while ",(0,i.jsx)(n.code,{children:"append"})," creates a new list. For adding to the end, ",(0,i.jsx)(n.code,{children:"nconc"})," is often more efficient than ",(0,i.jsx)(n.code,{children:"append"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf cubes (nconc cubes (list 216))) ; add the cube of 6\n(setf cubes (nconc cubes (list (expt 7 3)))) ; and the cube of 7\n\ncubes\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(1 8 27 64 125 216 343)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Simple assignment in Common Lisp, like in Python, does ",(0,i.jsx)(n.em,{children:"not"})," copy data. When you assign a list to a variable, the variable refers to the existing list:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf rgb (list "Red" "Green" "Blue"))\n(setf rgba rgb)\n\n(eq rgb rgba) ; they reference the same object (similar to id() in Python)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"T\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(nconc rgba (list "Alph"))\n\nrgb\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'("Red" "Green" "Blue" "Alph")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To create a copy of a list, use ",(0,i.jsx)(n.code,{children:"copy-list"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(setf correct-rgba (copy-list rgba))\n(setf (elt correct-rgba (- (length correct-rgba) 1)) "Alpha")\n\ncorrect-rgba\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'("Red" "Green" "Blue" "Alpha")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"rgba\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'("Red" "Green" "Blue" "Alph")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Assignment to slices (using ",(0,i.jsx)(n.code,{children:"setf"})," with ",(0,i.jsx)(n.code,{children:"subseq"}),") is also possible:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf letters (list 'a 'b 'c 'd 'e 'f 'g))\n\nletters\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(A B C D E F G)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf (subseq letters 2 5) (list 'C 'D 'E))\n\nletters\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(A B C D E F G)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To remove elements, you can use ",(0,i.jsx)(n.code,{children:"setf"})," with ",(0,i.jsx)(n.code,{children:"subseq"})," and an empty list, or use ",(0,i.jsx)(n.code,{children:"delete"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf (subseq letters 2 5) nil)\nletters\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(A B F G)\n"})}),"\n",(0,i.jsx)(n.p,{children:"To clear the list:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf letters nil)\nletters\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"NIL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The function ",(0,i.jsx)(n.code,{children:"length"})," also applies to lists:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf letters (list 'a 'b 'c 'd))\n(length letters)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"4\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is possible to nest lists:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(setf a (list 'a 'b 'c))\n(setf n (list 1 2 3))\n(setf x (list a n))\n\nx\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"((A B C) (1 2 3))\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(elt x 0)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(A B C)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(elt (elt x 0) 1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"B\n"})}),"\n",(0,i.jsx)(n.h2,{id:"14-first-steps-towards-programming",children:"1.4. First Steps Towards Programming"}),"\n",(0,i.jsx)(n.p,{children:"Of course, we can use Common Lisp for more complicated tasks than adding two and two together. For instance, we can write an initial sub-sequence of the Fibonacci series as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:";; Fibonacci series:\n;; the sum of two elements defines the next\n\n(let ((a 0) (b 1)) ; Multiple assignment using LET\n  (loop\n    (when (> a 10) (return)) ; Exit the loop when a >= 10\n    (print a)\n    (rotatef a b (+ a b)))) ; Simultaneous assignment using ROTATEF\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"0 \n1 \n1 \n2 \n3 \n5 \n8 \n"})}),"\n",(0,i.jsx)(n.p,{children:"This example introduces several new features."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The first line uses ",(0,i.jsx)(n.code,{children:"let"})," with a binding list ",(0,i.jsx)(n.code,{children:"((a 0) (b 1))"})," to introduce local variables ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," and simultaneously initialize them to 0 and 1. This is Common Lisp's equivalent of multiple assignment. The last line uses ",(0,i.jsx)(n.code,{children:"rotatef"})," which is the idiomatic way to swap variable values and perform simultaneous assignment in Common Lisp. ",(0,i.jsx)(n.code,{children:"rotatef"})," rotates the values of the given variables. ",(0,i.jsx)(n.code,{children:"(rotatef a b (+ a b))"})," is equivalent to the Python ",(0,i.jsx)(n.code,{children:"a, b = b, a+b"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"loop"})," macro introduces an infinite loop. The ",(0,i.jsx)(n.code,{children:"when"})," form provides a conditional exit from the loop. ",(0,i.jsx)(n.code,{children:"(when (> a 10) (return))"})," is equivalent to ",(0,i.jsx)(n.code,{children:"if a > 10: break"})," in Python. The loop continues as long as the condition ",(0,i.jsx)(n.code,{children:"(> a 10)"})," is false (i.e., ",(0,i.jsx)(n.code,{children:"a"})," is less than or equal to 10). The standard comparison operators are similar to C and Python: ",(0,i.jsx)(n.code,{children:"<"})," (less than), ",(0,i.jsx)(n.code,{children:">"})," (greater than), ",(0,i.jsx)(n.code,{children:"="})," (equal to), ",(0,i.jsx)(n.code,{children:"<="})," (less than or equal to), ",(0,i.jsx)(n.code,{children:">="})," (greater than or equal to), and ",(0,i.jsx)(n.code,{children:"/="})," (not equal to). Note that ",(0,i.jsx)(n.code,{children:"="})," is for numeric equality, ",(0,i.jsx)(n.code,{children:"eql"})," is for general object equality (and is what is usually wanted) and ",(0,i.jsx)(n.code,{children:"eq"})," is for object identity."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Indentation is not syntactically significant in Common Lisp, unlike Python. However, it is ",(0,i.jsx)(n.em,{children:"extremely"})," important for readability. The code within the ",(0,i.jsx)(n.code,{children:"let"})," and ",(0,i.jsx)(n.code,{children:"loop"})," forms is indented to show the structure. Common Lisp code is typically formatted using consistent indentation."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"print"})," function writes the value of its argument(s). It prints a newline after each argument by default. To print without a newline, you can use ",(0,i.jsx)(n.code,{children:"princ"})," or ",(0,i.jsx)(n.code,{children:"write-string"})," to a stream. To format output, ",(0,i.jsx)(n.code,{children:"format"})," is the standard way. It is much more powerful than Python's ",(0,i.jsx)(n.code,{children:"print"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Example using ",(0,i.jsx)(n.code,{children:"format"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(let ((i (* 256 256)))\n  (format t "The value of i is ~d~%" i)) ; ~d is for decimal integer, ~% is for newline\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"The value of i is 65536\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To avoid the newline after the output, or end the output with a different string, you can use ",(0,i.jsx)(n.code,{children:"format"})," with different directives. For example, to separate numbers with commas:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(let ((a 0) (b 1))\n  (loop\n    (when (> a 1000) (return))\n    (format t "~d," a) ; Print a followed by a comma, no newline\n    (rotatef a b (+ a b))))\n(terpri) ; Print a final newline\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output (the last comma will remain, a more sophisticated format string could avoid that):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A more elegant way to avoid the trailing comma is to use ",(0,i.jsx)(n.code,{children:"loop for"})," and ",(0,i.jsx)(n.code,{children:"format"})," with conditional printing:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(loop for a = 0 then b\n      and b = 1 then (+ a b)\n      while (< a 1000)\n      do (format t "~d~@[,-~]" a)) ; Print a, and a comma unless it\'s the first one.\n(terpri)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>r});var i=s(7294);const l={},a=i.createContext(l);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);