"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[8974],{3888:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>t});var i=s(5893),a=s(1151);const o={sidebar_position:8},l="Packages",c={id:"tutorial/packages",title:"Packages",description:"This article needs to be checked!.",source:"@site/docs/tutorial/packages.md",sourceDirName:"tutorial",slug:"/tutorial/packages",permalink:"/docs/tutorial/packages",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/packages.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Condition System",permalink:"/docs/tutorial/conditions"},next:{title:"Macros",permalink:"/docs/tutorial/macros"}},r={},t=[{value:"Quickstart",id:"quickstart",level:2},{value:"Introduction to Packages, Protocols, and Code in Different Files in Common Lisp",id:"introduction-to-packages-protocols-and-code-in-different-files-in-common-lisp",level:2},{value:"1. Packages",id:"1-packages",level:2},{value:"1.1 What are Packages and Why are They Needed?",id:"11-what-are-packages-and-why-are-they-needed",level:3},{value:"1.2 The <code>COMMON-LISP</code> and <code>KEYWORD</code> Packages",id:"12-the-common-lisp-and-keyword-packages",level:3},{value:"1.3 <code>defpackage</code>: Defining a Package",id:"13-defpackage-defining-a-package",level:3},{value:"1.4 <code>in-package</code>: Switching to a Package",id:"14-in-package-switching-to-a-package",level:3},{value:"1.5 <code>use-package</code>: Importing Symbols",id:"15-use-package-importing-symbols",level:3},{value:"1.6 <code>export</code>: Making Symbols Visible to Other Packages",id:"16-export-making-symbols-visible-to-other-packages",level:3},{value:"1.7 <code>import</code>: Accessing External Symbols",id:"17-import-accessing-external-symbols",level:3},{value:"1.8 Package Nicknames",id:"18-package-nicknames",level:3},{value:"2. Symbols and Interning",id:"2-symbols-and-interning",level:2},{value:"2.1 What is a Symbol?",id:"21-what-is-a-symbol",level:3},{value:"2.2 The Concept of Interning",id:"22-the-concept-of-interning",level:3},{value:"2.3 Package Prefixes (e.g., <code>package:symbol</code>)",id:"23-package-prefixes-eg-packagesymbol",level:3},{value:"3. Protocols (with Generic Functions and CLOS)",id:"3-protocols-with-generic-functions-and-clos",level:2},{value:"3.1 Defining Protocols Using Generic Functions",id:"31-defining-protocols-using-generic-functions",level:3},{value:"3.2 Implementing Protocols with Methods",id:"32-implementing-protocols-with-methods",level:3},{value:"3.3 Benefits of Using Protocols",id:"33-benefits-of-using-protocols",level:3},{value:"3.4 Example of a Simple Protocol",id:"34-example-of-a-simple-protocol",level:3},{value:"4. Loading Code from Files",id:"4-loading-code-from-files",level:2},{value:"4.1 <code>load</code>: Evaluating Lisp Code from a File",id:"41-load-evaluating-lisp-code-from-a-file",level:3},{value:"4.2 <code>require</code>: Loading a File Only Once",id:"42-require-loading-a-file-only-once",level:3},{value:"5. Organizing Code into Systems with ASDF",id:"5-organizing-code-into-systems-with-asdf",level:2},{value:"5.1 ASDF Basics (Recap Focusing on Multi-File Aspects)",id:"51-asdf-basics-recap-focusing-on-multi-file-aspects",level:3},{value:"5.2 Defining Systems with Multiple Components (Files)",id:"52-defining-systems-with-multiple-components-files",level:3},{value:"5.3 Dependencies Between Systems",id:"53-dependencies-between-systems",level:3},{value:"6. Best Practices and Examples",id:"6-best-practices-and-examples",level:2},{value:"6.1 Structuring a Multi-File Project",id:"61-structuring-a-multi-file-project",level:3},{value:"6.2 Example of a Project Using Packages, Protocols, and ASDF",id:"62-example-of-a-project-using-packages-protocols-and-asdf",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"packages",children:"Packages"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["This article ",(0,i.jsx)(n.strong,{children:"needs to be checked!"}),".\nPlease help contribute by checking it and making changes in ",(0,i.jsx)(n.a,{href:"https://github.com/lisp-docs/lisp-docs.github.io",children:"our repository"}),' or by clicking on the "Edit this page" link below.']})}),"\n",(0,i.jsx)(n.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,i.jsxs)(n.p,{children:["If you are looking to just hit the ground running and learn Common Lisp I recommend just ",(0,i.jsx)(n.a,{href:"https://www.sbcl.org/getting.html",children:"installing SBCL"})," and ",(0,i.jsx)(n.a,{href:"/docs/tutorial/informal-introduction-to-lisp",children:"going ahead"})," with the tutorial."]}),"\n",(0,i.jsx)(n.p,{children:"If you are on a linux/debian type system, you can run"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ sudo apt-get install sbcl\n"})}),"\n",(0,i.jsx)(n.p,{children:"For macOS"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ brew install sbcl\n"})}),"\n",(0,i.jsx)(n.p,{children:"For Arch Linux"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ sudo pacman -S sbcl\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For other systems, Windows, or to just get the latest version instead of the one in your package manager, you can ",(0,i.jsx)(n.a,{href:"https://www.sbcl.org/platform-table.html",children:"download a binary here"})," (click on the green cell in the table corresponding to your system, they are actually links). Then follow these instructions: ",(0,i.jsx)(n.a,{href:"https://www.sbcl.org/getting.html",children:"SBCL's Getting Started"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For a more detailed explanation, read ahead."}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-packages-protocols-and-code-in-different-files-in-common-lisp",children:"Introduction to Packages, Protocols, and Code in Different Files in Common Lisp"}),"\n",(0,i.jsxs)(n.p,{children:["As Lisp programs grow in size and complexity, it becomes essential to organize code into manageable units. Common Lisp provides ",(0,i.jsx)(n.em,{children:"packages"})," as a mechanism for namespace management, preventing name clashes and promoting modularity. Furthermore, the concept of ",(0,i.jsx)(n.em,{children:"protocols"})," (often implemented using generic functions and CLOS) allows for defining interfaces and structuring interactions between different parts of a system. Finally, organizing code into separate files is crucial for maintainability and collaboration."]}),"\n",(0,i.jsx)(n.p,{children:"This tutorial will introduce you to these essential concepts, explaining how to define and use packages, how to implement protocols, and how to structure your Lisp code across multiple files."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Packages:"})," Namespaces that prevent symbol collisions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Symbols and Interning:"})," How symbols are associated with packages."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"defpackage"}),":"]})," Defining new packages."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"in-package"}),":"]})," Switching to a different package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"use-package"}),":"]})," Importing symbols from other packages."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"export"})," and ",(0,i.jsx)(n.code,{children:"import"}),":"]})," Controlling symbol visibility."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Protocols (using Generic Functions and CLOS):"})," Defining interfaces for interacting with objects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Loading Code from Files:"})," Using ",(0,i.jsx)(n.code,{children:"load"})," and ",(0,i.jsx)(n.code,{children:"require"})," to load code from separate files."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ASDF System Definitions:"})," Using ASDF to manage multi-file projects and dependencies."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Table of Contents:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Packages:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What are packages and why are they needed?"}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"COMMON-LISP"})," and ",(0,i.jsx)(n.code,{children:"KEYWORD"})," packages."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"defpackage"}),": Defining a package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"in-package"}),": Switching to a package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"use-package"}),": Importing symbols."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"export"}),": Making symbols visible to other packages."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"import"}),": Accessing external symbols."]}),"\n",(0,i.jsx)(n.li,{children:"Package nicknames."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Symbols and Interning:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What is a symbol?"}),"\n",(0,i.jsx)(n.li,{children:"The concept of interning."}),"\n",(0,i.jsxs)(n.li,{children:["Package prefixes (e.g., ",(0,i.jsx)(n.code,{children:"package:symbol"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Protocols (with Generic Functions and CLOS):"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Defining protocols using generic functions."}),"\n",(0,i.jsx)(n.li,{children:"Implementing protocols with methods."}),"\n",(0,i.jsx)(n.li,{children:"Benefits of using protocols."}),"\n",(0,i.jsx)(n.li,{children:"Example of a simple protocol."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Loading Code from Files:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"load"}),": Evaluating Lisp code from a file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"require"}),": Loading a file only once."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Organizing Code into Systems with ASDF:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ASDF basics (recap from previous tutorial, focusing on multi-file aspects)."}),"\n",(0,i.jsx)(n.li,{children:"Defining systems with multiple components (files)."}),"\n",(0,i.jsx)(n.li,{children:"Dependencies between systems."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"6. Best Practices and Examples:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Structuring a multi-file project."}),"\n",(0,i.jsx)(n.li,{children:"Example of a project using packages, protocols, and ASDF."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This tutorial aims to provide a practical guide to organizing and managing Common Lisp code in larger projects. By the end, you should be able to create and use packages, define protocols, and structure your code across multiple files effectively."}),"\n",(0,i.jsx)(n.h2,{id:"1-packages",children:"1. Packages"}),"\n",(0,i.jsx)(n.p,{children:"Packages in Common Lisp provide a way to organize code into namespaces, preventing naming conflicts and promoting modularity. This section explains the basics of packages and how to use them."}),"\n",(0,i.jsx)(n.h3,{id:"11-what-are-packages-and-why-are-they-needed",children:"1.1 What are Packages and Why are They Needed?"}),"\n",(0,i.jsxs)(n.p,{children:["In any large software project, it's common to have multiple developers or libraries contributing code. Without a mechanism for managing namespaces, it's easy to encounter naming collisions, where two different parts of the code use the same name for different things (e.g., two different functions named ",(0,i.jsx)(n.code,{children:"calculate-area"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"Packages solve this problem by providing separate namespaces. Each symbol (variable, function, class, etc.) belongs to a specific package. This allows you to have symbols with the same name in different packages without them interfering with each other."}),"\n",(0,i.jsxs)(n.h3,{id:"12-the-common-lisp-and-keyword-packages",children:["1.2 The ",(0,i.jsx)(n.code,{children:"COMMON-LISP"})," and ",(0,i.jsx)(n.code,{children:"KEYWORD"})," Packages"]}),"\n",(0,i.jsx)(n.p,{children:"Two special packages are always present in a Common Lisp environment:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"COMMON-LISP"})," (or ",(0,i.jsx)(n.code,{children:"CL"}),"):"]})," This package contains all the standard Common Lisp functions, macros, and other symbols. When you start a Lisp REPL, you are usually in this package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"KEYWORD"}),":"]})," This package contains keywords, which are symbols that evaluate to themselves (e.g., ",(0,i.jsx)(n.code,{children:":foo"}),", ",(0,i.jsx)(n.code,{children:":bar"}),"). Keywords are commonly used as named arguments to functions and macros."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"13-defpackage-defining-a-package",children:["1.3 ",(0,i.jsx)(n.code,{children:"defpackage"}),": Defining a Package"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"defpackage"})," macro is used to define a new package. Its basic syntax is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defpackage package-name\n  (:use package1 package2 ...)\n  (:export symbol1 symbol2 ...)\n  (:nicknames nickname1 nickname2 ...))\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"package-name"}),":"]})," The name of the package (a symbol or a string)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"(:use package1 package2 ...)"}),":"]})," Specifies which other packages this package ",(0,i.jsx)(n.em,{children:"uses"}),". Using a package imports the external symbols of that package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"(:export symbol1 symbol2 ...)"}),":"]})," Specifies which symbols from this package are ",(0,i.jsx)(n.em,{children:"exported"})," (made visible to other packages)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"(:nicknames nickname1 nickname2 ...)"}),":"]})," Specifies alternative names (nicknames) for the package."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defpackage my-utils\n  (:use common-lisp)\n  (:export my-function my-variable)\n    (:nicknames mu))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This defines a package named ",(0,i.jsx)(n.code,{children:"my-utils"})," that:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses the ",(0,i.jsx)(n.code,{children:"COMMON-LISP"})," package (so it can use standard Lisp functions)."]}),"\n",(0,i.jsxs)(n.li,{children:["Exports the symbols ",(0,i.jsx)(n.code,{children:"my-function"})," and ",(0,i.jsx)(n.code,{children:"my-variable"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Has the nickname ",(0,i.jsx)(n.code,{children:"mu"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"14-in-package-switching-to-a-package",children:["1.4 ",(0,i.jsx)(n.code,{children:"in-package"}),": Switching to a Package"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"in-package"})," macro is used to switch the current package. When you evaluate code, the symbols you type are interned (associated) with the current package."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :my-utils) ; Switch to the my-utils package\n\n(defun my-function (x) (* x 2)) ; Defines my-function in my-utils\n\n(defvar my-variable 10) ; Defines my-variable in my-utils\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, ",(0,i.jsx)(n.code,{children:"my-function"})," and ",(0,i.jsx)(n.code,{children:"my-variable"})," belong to the ",(0,i.jsx)(n.code,{children:"my-utils"})," package."]}),"\n",(0,i.jsxs)(n.h3,{id:"15-use-package-importing-symbols",children:["1.5 ",(0,i.jsx)(n.code,{children:"use-package"}),": Importing Symbols"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"use-package"})," function imports all external symbols from another package into the current package. This makes it easier to use those symbols without having to qualify them with the package name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :another-package)\n\n(use-package :my-utils) ; Imports my-function and my-variable\n\n(my-function 5)     ; Now you can use my-function directly\n(print my-variable) ; And my-variable\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"16-export-making-symbols-visible-to-other-packages",children:["1.6 ",(0,i.jsx)(n.code,{children:"export"}),": Making Symbols Visible to Other Packages"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"export"})," function (or the ",(0,i.jsx)(n.code,{children:":export"})," option in ",(0,i.jsx)(n.code,{children:"defpackage"}),") makes symbols in a package visible to other packages. Only exported symbols can be imported using ",(0,i.jsx)(n.code,{children:"use-package"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :my-utils)\n\n(export 'my-function) ; Makes my-function visible\n(export '(my-variable my-other-function)) ; Export multiple symbols\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"17-import-accessing-external-symbols",children:["1.7 ",(0,i.jsx)(n.code,{children:"import"}),": Accessing External Symbols"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"import"})," function allows you to access individual symbols from other packages without using ",(0,i.jsx)(n.code,{children:"use-package"}),". This is useful when you only need a few symbols from a package or when using ",(0,i.jsx)(n.code,{children:"use-package"})," would cause name conflicts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :yet-another-package)\n\n(import 'my-utils:my-function) ; Imports only my-function\n\n(my-utils:my-variable) ; You still need to qualify my-variable\n(my-function 10) ; You can use my-function directly\n"})}),"\n",(0,i.jsx)(n.h3,{id:"18-package-nicknames",children:"1.8 Package Nicknames"}),"\n",(0,i.jsx)(n.p,{children:"Package nicknames provide shorter, more convenient ways to refer to packages."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defpackage my-long-package-name\n  (:nicknames m-l-p))\n\n(in-package :m-l-p) ; You can now use the nickname\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example summarizing package usage:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defpackage :my-application\n  (:use :common-lisp :my-utils))\n\n(in-package :my-application)\n\n(my-function 20) ; Uses my-function from my-utils\n(print my-variable) ; Uses my-variable from my-utils\n\n(defun application-function ()\n  (print "Application function"))\n\n(export \'application-function) ; Exports the application function\n'})}),"\n",(0,i.jsx)(n.p,{children:"This section provided a basic introduction to packages in Common Lisp. Understanding packages is essential for organizing larger projects and preventing naming conflicts. The next section will cover symbols and interning in more detail."}),"\n",(0,i.jsx)(n.h2,{id:"2-symbols-and-interning",children:"2. Symbols and Interning"}),"\n",(0,i.jsx)(n.p,{children:"This section delves into the concept of symbols and interning, which are fundamental to how packages work in Common Lisp."}),"\n",(0,i.jsx)(n.h3,{id:"21-what-is-a-symbol",children:"2.1 What is a Symbol?"}),"\n",(0,i.jsxs)(n.p,{children:["In Common Lisp, a ",(0,i.jsx)(n.em,{children:"symbol"})," is a data object that represents a name. Symbols are used as identifiers for variables, functions, classes, and other program entities. Unlike strings, which represent sequences of characters, symbols are atomic objects with unique identities."]}),"\n",(0,i.jsx)(n.p,{children:"Key characteristics of symbols:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Name:"})," A symbol has a name, which is a string."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Package:"})," A symbol belongs to a specific package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Value:"})," A symbol can have a value (if it's a variable)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Function definition:"})," A symbol can have a function definition (if it's a function name)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Property list:"})," A symbol can have a property list, which is a list of key-value pairs that can be used to store arbitrary information about the symbol."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"foo"}),", ",(0,i.jsx)(n.code,{children:"BAR"}),", ",(0,i.jsx)(n.code,{children:"my-variable"}),", ",(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"-"})," are all symbols."]}),"\n",(0,i.jsx)(n.h3,{id:"22-the-concept-of-interning",children:"2.2 The Concept of Interning"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Interning"})," is the process of associating a symbol's name with a unique object in a specific package. When you type a symbol in the Lisp REPL or in your code, the Lisp system ",(0,i.jsx)(n.em,{children:"interns"})," that symbol in the current package. This means that if you type the same symbol name again, you will get the ",(0,i.jsx)(n.em,{children:"same"})," symbol object."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(eq 'foo 'foo) ; Returns T (because 'foo refers to the same symbol object)\n\n(string= (symbol-name 'foo) \"FOO\") ; Returns T (symbol names are case insensitive by default)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here's how interning works:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["When the Lisp reader encounters a symbol name (e.g., ",(0,i.jsx)(n.code,{children:"foo"}),"), it checks if a symbol with that name already exists in the current package."]}),"\n",(0,i.jsx)(n.li,{children:"If a symbol with that name exists, the reader returns that existing symbol object."}),"\n",(0,i.jsxs)(n.li,{children:["If a symbol with that name does not exist, the reader creates a new symbol object, associates it with the name, and ",(0,i.jsx)(n.em,{children:"interns"})," it in the current package."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Uninterned Symbols:"})}),"\n",(0,i.jsxs)(n.p,{children:["It's also possible to create ",(0,i.jsx)(n.em,{children:"uninterned"})," symbols using ",(0,i.jsx)(n.code,{children:"gensym"})," (which we saw in the macros tutorial). Uninterned symbols are not associated with any package and are guaranteed to be unique."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(eq (gensym) (gensym)) ; Returns NIL (because each call to gensym creates a new, distinct symbol)\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"23-package-prefixes-eg-packagesymbol",children:["2.3 Package Prefixes (e.g., ",(0,i.jsx)(n.code,{children:"package:symbol"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["To refer to a symbol in a different package, you can use a ",(0,i.jsx)(n.em,{children:"package prefix"}),". The syntax is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"package-name:symbol-name\n"})}),"\n",(0,i.jsx)(n.p,{children:"or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"package-nickname:symbol-name\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's say you have a package ",(0,i.jsx)(n.code,{children:"my-utils"})," that exports a function ",(0,i.jsx)(n.code,{children:"my-function"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defpackage my-utils\n    (:use common-lisp)\n    (:export my-function)\n    (:nicknames mu))\n\n(in-package :my-utils)\n\n(defun my-function (x) (* x 2))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To call ",(0,i.jsx)(n.code,{children:"my-function"})," from another package, you can use the package prefix:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :cl-user) ; Switch to the CL-USER package\n\n(my-utils:my-function 5) ; Calls my-function from the my-utils package, returns 10\n(mu:my-function 10) ; Using the nickname, returns 20\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you have used a package (with ",(0,i.jsx)(n.code,{children:"use-package"}),") you don't need the package prefix:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :cl-user)\n\n(use-package :my-utils)\n\n(my-function 15) ; Calls my-function from my-utils without the prefix, returns 30\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Double Colon ",(0,i.jsx)(n.code,{children:"::"}),":"]})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use a double colon ",(0,i.jsx)(n.code,{children:"::"})," to refer to a symbol in another package, even if it is ",(0,i.jsx)(n.em,{children:"not"})," exported. However, this is generally discouraged as it breaks encapsulation and makes your code more fragile."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(in-package :cl-user)\n\n(my-utils::internal-function) ; Accesses an internal (unexported) function (if it exists)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Using package prefixes and understanding interning is crucial for managing namespaces and writing modular Common Lisp code. It allows you to organize your code into logical units and prevent naming collisions. The next section will cover protocols (using generic functions and CLOS)."}),"\n",(0,i.jsx)(n.h2,{id:"3-protocols-with-generic-functions-and-clos",children:"3. Protocols (with Generic Functions and CLOS)"}),"\n",(0,i.jsxs)(n.p,{children:["In Common Lisp, ",(0,i.jsx)(n.em,{children:"protocols"})," are often implemented using generic functions and the Common Lisp Object System (CLOS). A protocol defines a set of operations (functions) that objects of different classes should support. This allows for polymorphism and extensibility."]}),"\n",(0,i.jsx)(n.h3,{id:"31-defining-protocols-using-generic-functions",children:"3.1 Defining Protocols Using Generic Functions"}),"\n",(0,i.jsx)(n.p,{children:"A protocol is defined by declaring a set of generic functions. A generic function is a function that can have different behaviors (methods) depending on the types of its arguments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defgeneric area (object)\n  (:documentation "Computes the area of an object."))\n\n(defgeneric perimeter (object)\n  (:documentation "Computes the perimeter of an object."))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, we define two generic functions: ",(0,i.jsx)(n.code,{children:"area"})," and ",(0,i.jsx)(n.code,{children:"perimeter"}),'. These functions constitute our "geometric shape" protocol. They don\'t have any specific implementation yet; they simply declare the operations that should be supported.']}),"\n",(0,i.jsx)(n.h3,{id:"32-implementing-protocols-with-methods",children:"3.2 Implementing Protocols with Methods"}),"\n",(0,i.jsx)(n.p,{children:"To implement a protocol for a specific class, you define methods for the generic functions. Methods are specialized on the types of their arguments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defclass rectangle ()\n  ((width :initarg :width :accessor rectangle-width)\n   (height :initarg :height :accessor rectangle-height)))\n\n(defmethod area ((r rectangle))\n  (* (rectangle-width r) (rectangle-height r)))\n\n(defmethod perimeter ((r rectangle))\n  (* 2 (+ (rectangle-width r) (rectangle-height r))))\n\n(defclass circle ()\n  ((radius :initarg :radius :accessor circle-radius)))\n\n(defmethod area ((c circle))\n  (* pi (expt (circle-radius c) 2)))\n\n(defmethod perimeter ((c circle))\n  (* 2 pi (circle-radius c)))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, we define two classes, ",(0,i.jsx)(n.code,{children:"rectangle"})," and ",(0,i.jsx)(n.code,{children:"circle"}),", and provide methods for ",(0,i.jsx)(n.code,{children:"area"})," and ",(0,i.jsx)(n.code,{children:"perimeter"}),' for each class. Now, objects of these classes implement the "geometric shape" protocol.']}),"\n",(0,i.jsx)(n.h3,{id:"33-benefits-of-using-protocols",children:"3.3 Benefits of Using Protocols"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Polymorphism:"})," You can write code that works with objects of different classes as long as they implement the same protocol."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defun describe-shape (shape)\n  (format t \"Area: ~a, Perimeter: ~a~%\" (area shape) (perimeter shape)))\n\n(let ((rect (make-instance 'rectangle :width 5 :height 10))\n      (circ (make-instance 'circle :radius 3)))\n  (describe-shape rect) ; Calls the rectangle methods\n  (describe-shape circ)) ; Calls the circle methods\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Extensibility:"})," You can easily add new classes that implement the protocol without modifying existing code."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defclass square (rectangle)\n  ())\n\n(defmethod area ((s square))\n    (expt (rectangle-width s) 2))\n\n(defmethod perimeter ((s square))\n    (* 4 (rectangle-width s)))\n\n(describe-shape (make-instance 'square :width 4))\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Abstraction:"})," Protocols define an interface, separating the implementation from the usage. This makes code more modular and easier to maintain."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"34-example-of-a-simple-protocol",children:"3.4 Example of a Simple Protocol"}),"\n",(0,i.jsx)(n.p,{children:'Let\'s consider a simple "printable" protocol:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defgeneric print-object-nicely (object stream)\n  (:documentation "Prints an object in a user-friendly format to a stream."))\n\n(defmethod print-object-nicely ((object t) stream)\n  (print-object object stream)) ; Default method: use the standard print-object\n\n(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age)))\n\n(defmethod print-object-nicely ((p person) stream)\n  (format stream "Person: ~a (Age: ~a)" (person-name p) (person-age p)))\n\n(let ((person (make-instance \'person :name "Alice" :age 30)))\n  (print-object-nicely person t)) ; Prints "Person: Alice (Age: 30)" to the standard output\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This defines a ",(0,i.jsx)(n.code,{children:"print-object-nicely"})," generic function. The default method simply uses the standard ",(0,i.jsx)(n.code,{children:"print-object"}),". The method specialized on ",(0,i.jsx)(n.code,{children:"person"})," provides a custom printing format."]}),"\n",(0,i.jsx)(n.p,{children:"This section explained how to define and implement protocols using generic functions and CLOS. Protocols are a powerful tool for writing extensible and maintainable code in Common Lisp. The next section will cover loading code from files."}),"\n",(0,i.jsx)(n.h2,{id:"4-loading-code-from-files",children:"4. Loading Code from Files"}),"\n",(0,i.jsxs)(n.p,{children:["As your Lisp projects grow, you'll want to organize your code into multiple files. Common Lisp provides functions for loading code from files. This section covers ",(0,i.jsx)(n.code,{children:"load"})," and ",(0,i.jsx)(n.code,{children:"require"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"41-load-evaluating-lisp-code-from-a-file",children:["4.1 ",(0,i.jsx)(n.code,{children:"load"}),": Evaluating Lisp Code from a File"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"load"})," function evaluates Lisp code from a file. Its basic syntax is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(load pathname &key verbose print compile if-does-not-exist external-format)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"pathname"}),":"]})," The pathname of the file to load (a string, pathname object, or logical pathname)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"verbose"}),":"]})," If true (default), prints messages indicating which files are being loaded."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"print"}),":"]})," If true, prints the values returned by the top-level forms in the file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"compile"}),":"]})," If true, compiles the file before loading (if it's not already compiled)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"if-does-not-exist"}),":"]})," Specifies what to do if the file does not exist (",(0,i.jsx)(n.code,{children:":error"})," (default), ",(0,i.jsx)(n.code,{children:":ignore"}),", or a function to call)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"external-format"}),":"]})," Specifies the character encoding of the file."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's say you have a file named ",(0,i.jsx)(n.code,{children:"my-functions.lisp"})," with the following content:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(in-package :my-utils)\n\n(defun greet (name)\n  (format t "Hello, ~a!~%" name))\n\n(defvar *my-special-variable* 42)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can load this file using ",(0,i.jsx)(n.code,{children:"load"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(load "my-functions.lisp") ; Loads and evaluates the code in the file\n'})}),"\n",(0,i.jsx)(n.p,{children:"After loading, you can use the functions and variables defined in the file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(in-package :cl-user)\n(use-package :my-utils)\n\n(greet "World") ; Prints "Hello, World!"\n(print *my-special-variable*) ; Prints 42\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pathnames:"})}),"\n",(0,i.jsxs)(n.p,{children:["It's generally better to use pathname objects rather than strings for file names, as they are more portable. You can create pathname objects using ",(0,i.jsx)(n.code,{children:"pathname"})," or ",(0,i.jsx)(n.code,{children:"#p"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(load (pathname "my-functions.lisp"))\n(load #p"my-functions.lisp")\n'})}),"\n",(0,i.jsx)(n.p,{children:"You can also specify absolute or relative paths:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(load #p"/path/to/my/file.lisp") ; Absolute path\n(load #p"../another/file.lisp")   ; Relative path\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Compiling Files:"})}),"\n",(0,i.jsxs)(n.p,{children:["You can compile a file using ",(0,i.jsx)(n.code,{children:"compile-file"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(compile-file "my-functions.lisp") ; Creates a fasl file (compiled code)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Loading the compiled file is generally faster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(load "my-functions.fasl")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"42-require-loading-a-file-only-once",children:["4.2 ",(0,i.jsx)(n.code,{children:"require"}),": Loading a File Only Once"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"require"})," function is similar to ",(0,i.jsx)(n.code,{children:"load"}),", but it ensures that a file is loaded only ",(0,i.jsx)(n.em,{children:"once"}),". If the file has already been loaded, ",(0,i.jsx)(n.code,{children:"require"})," does nothing. This is important to prevent redefinitions and potential errors."]}),"\n",(0,i.jsx)(n.p,{children:"The syntax is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(require module-name &optional pathname)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"module-name"}),":"]})," A symbol representing the module (usually the file name without the extension)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"pathname"}),":"]})," An optional pathname for the file. If omitted, ",(0,i.jsx)(n.code,{children:"require"})," searches for a file named ",(0,i.jsx)(n.code,{children:"module-name.lisp"})," or ",(0,i.jsx)(n.code,{children:"module-name.fasl"})," in implementation dependent locations."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(require :my-functions) ; Loads my-functions.lisp (or .fasl) if it hasn't been loaded yet\n(require :my-functions) ; Does nothing because my-functions is already loaded\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"require"})," is commonly used to load libraries and dependencies. It's good practice to use ",(0,i.jsx)(n.code,{children:"require"})," instead of ",(0,i.jsx)(n.code,{children:"load"})," whenever you want to ensure that a file is loaded only once."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example using pathname:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(require :my-functions #p"path/to/my-functions.lisp")\n'})}),"\n",(0,i.jsx)(n.p,{children:"This will load the file specified by the pathname, regardless of the module name."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Order of loading:"})}),"\n",(0,i.jsx)(n.p,{children:"When you have multiple files that depend on each other, the order in which you load them is important. You should load files in dependency order, starting with the files that have no dependencies and ending with the files that depend on others. ASDF (covered in the next section) helps manage this automatically."}),"\n",(0,i.jsxs)(n.p,{children:["This section explained how to load code from files using ",(0,i.jsx)(n.code,{children:"load"})," and ",(0,i.jsx)(n.code,{children:"require"}),". Using these functions is essential for organizing your Lisp code into manageable modules. The next section will cover ASDF, which is a standard build system that handles multi-file projects and dependencies."]}),"\n",(0,i.jsx)(n.h2,{id:"5-organizing-code-into-systems-with-asdf",children:"5. Organizing Code into Systems with ASDF"}),"\n",(0,i.jsx)(n.p,{children:"ASDF (Another System Definition Facility) is the standard build system for Common Lisp. It provides a way to define software components (systems) and their dependencies, making it easier to build, load, and manage multi-file Lisp projects. This section focuses on how ASDF helps organize code across multiple files."}),"\n",(0,i.jsx)(n.h3,{id:"51-asdf-basics-recap-focusing-on-multi-file-aspects",children:"5.1 ASDF Basics (Recap Focusing on Multi-File Aspects)"}),"\n",(0,i.jsxs)(n.p,{children:["As a quick recap (since this was discussed ",(0,i.jsx)(n.a,{href:"/docs/tutorial/using-cl-implementation#4-build-tools-asdf",children:"here"}),"), ASDF uses system definition files (",(0,i.jsx)(n.code,{children:".asd"})," files) to describe the structure of a project. A system is a collection of files (Lisp source code, data files, etc.) that make up a logical unit of software."]}),"\n",(0,i.jsx)(n.p,{children:"A basic system definition looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "My awesome project"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :components ((:file "my-project")))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This simple example defines a system named ",(0,i.jsx)(n.code,{children:":my-project"})," with a single component: a Lisp source file named ",(0,i.jsx)(n.code,{children:"my-project.lisp"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For multi-file projects, the ",(0,i.jsx)(n.code,{children:":components"})," list becomes more important."]}),"\n",(0,i.jsx)(n.h3,{id:"52-defining-systems-with-multiple-components-files",children:"5.2 Defining Systems with Multiple Components (Files)"}),"\n",(0,i.jsxs)(n.p,{children:["To define a system with multiple files, you list multiple components in the ",(0,i.jsx)(n.code,{children:":components"})," list. The order of the components is important, as ASDF uses this order to determine the loading and compilation order."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's say you have a project with three files: ",(0,i.jsx)(n.code,{children:"utils.lisp"}),", ",(0,i.jsx)(n.code,{children:"core.lisp"}),", and ",(0,i.jsx)(n.code,{children:"main.lisp"}),". ",(0,i.jsx)(n.code,{children:"main.lisp"})," depends on ",(0,i.jsx)(n.code,{children:"core.lisp"}),", and ",(0,i.jsx)(n.code,{children:"core.lisp"})," depends on ",(0,i.jsx)(n.code,{children:"utils.lisp"}),". Your project directory would look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"my-project/\n\u251c\u2500\u2500 my-project.asd\n\u251c\u2500\u2500 utils.lisp\n\u251c\u2500\u2500 core.lisp\n\u2514\u2500\u2500 main.lisp\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Your ",(0,i.jsx)(n.code,{children:"my-project.asd"})," file would look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "A multi-file project"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :components ((:file "utils")\n               (:file "core")\n               (:file "main")))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["ASDF will ensure that ",(0,i.jsx)(n.code,{children:"utils.lisp"})," is loaded before ",(0,i.jsx)(n.code,{children:"core.lisp"}),", and ",(0,i.jsx)(n.code,{children:"core.lisp"})," is loaded before ",(0,i.jsx)(n.code,{children:"main.lisp"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Using Modules:"})}),"\n",(0,i.jsxs)(n.p,{children:["For larger projects, you can use ",(0,i.jsx)(n.em,{children:"modules"})," to organize components into subdirectories."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.p,{children:"Let's reorganize the project:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"my-project/\n\u251c\u2500\u2500 my-project.asd\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 utils.lisp\n    \u251c\u2500\u2500 core.lisp\n    \u2514\u2500\u2500 main.lisp\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"my-project.asd"})," file would then be:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "A multi-file project with modules"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :components ((:module "src"\n                 :components ((:file "utils")\n                              (:file "core")\n                              (:file "main")))))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["ASDF will now look for the files in the ",(0,i.jsx)(n.code,{children:"src"})," subdirectory."]}),"\n",(0,i.jsx)(n.h3,{id:"53-dependencies-between-systems",children:"5.3 Dependencies Between Systems"}),"\n",(0,i.jsxs)(n.p,{children:["One of the most powerful features of ASDF is its ability to manage dependencies between systems. If your project depends on other libraries or systems, you can specify these dependencies in the ",(0,i.jsx)(n.code,{children:":depends-on"})," list of your system definition."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's say your ",(0,i.jsx)(n.code,{children:"main.lisp"})," file uses the ",(0,i.jsx)(n.code,{children:"drakma"})," library for making HTTP requests. You would add ",(0,i.jsx)(n.code,{children:":drakma"})," to the ",(0,i.jsx)(n.code,{children:":depends-on"})," list:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "A project with dependencies"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :depends-on (:drakma) ; Declares dependency on drakma\n  :components ((:module "src"\n                 :components ((:file "utils")\n                              (:file "core")\n                              (:file "main")))))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When you load ",(0,i.jsx)(n.code,{children:":my-project"})," using ",(0,i.jsx)(n.code,{children:"asdf:load-system"}),", ASDF will automatically load ",(0,i.jsx)(n.code,{children:"drakma"})," (if it's not already loaded) before loading your project's files. This greatly simplifies dependency management."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Local Projects:"})}),"\n",(0,i.jsxs)(n.p,{children:["If you are developing a library that you want to include as a dependency, you can use local projects. You put the library's ",(0,i.jsx)(n.code,{children:".asd"})," file into ",(0,i.jsx)(n.code,{children:"~/.quicklisp/local-projects"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsxs)(n.p,{children:["You have a local library called ",(0,i.jsx)(n.code,{children:"my-local-lib"})," in ",(0,i.jsx)(n.code,{children:"~/.quicklisp/local-projects/my-local-lib.asd"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "A project with local dependencies"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :depends-on (:my-local-lib) ; Declares dependency on local project\n  :components ((:module "src"\n                 :components ((:file "utils")\n                              (:file "core")\n                              (:file "main")))))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["ASDF will look for the ",(0,i.jsx)(n.code,{children:"my-local-lib"})," system in the local projects directory."]}),"\n",(0,i.jsx)(n.p,{children:"By using ASDF, you can easily manage complex multi-file projects, handle dependencies, and ensure that your code is loaded and compiled in the correct order. This makes your Lisp development workflow much more efficient and organized. The next section will cover best practices and examples of structuring multi-file projects."}),"\n",(0,i.jsx)(n.h2,{id:"6-best-practices-and-examples",children:"6. Best Practices and Examples"}),"\n",(0,i.jsx)(n.p,{children:"This section provides best practices for structuring multi-file projects in Common Lisp and presents a comprehensive example that integrates packages, protocols, and ASDF."}),"\n",(0,i.jsx)(n.h3,{id:"61-structuring-a-multi-file-project",children:"6.1 Structuring a Multi-File Project"}),"\n",(0,i.jsx)(n.p,{children:"Here are some recommended practices for organizing your Lisp projects:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"One System per Project:"})," Typically, you'll have one ASDF system definition (",(0,i.jsx)(n.code,{children:".asd"})," file) per project."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Directory Structure:"})," Use a clear and consistent directory structure. A common approach is:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"my-project/\n\u251c\u2500\u2500 my-project.asd     ; ASDF system definition\n\u251c\u2500\u2500 src/               ; Source code\n\u2502   \u251c\u2500\u2500 package.lisp   ; Package definition\n\u2502   \u251c\u2500\u2500 utils.lisp     ; Utility functions\n\u2502   \u251c\u2500\u2500 core.lisp      ; Core logic\n\u2502   \u2514\u2500\u2500 main.lisp      ; Main entry point\n\u2514\u2500\u2500 tests/             ; Unit tests (optional)\n    \u2514\u2500\u2500 test-suite.lisp\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Package Definitions:"})," Define your packages in a separate ",(0,i.jsx)(n.code,{children:"package.lisp"})," file within your ",(0,i.jsx)(n.code,{children:"src"})," directory. This makes it clear which symbols are exported."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency Order:"})," Ensure that your components in the ",(0,i.jsx)(n.code,{children:".asd"})," file are listed in the correct dependency order. Files defining packages should generally be loaded first."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Modules for Subsystems:"})," For larger projects, use modules to group related components into subdirectories."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Separate Tests:"})," Keep your unit tests in a separate ",(0,i.jsx)(n.code,{children:"tests"})," directory."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"62-example-of-a-project-using-packages-protocols-and-asdf",children:"6.2 Example of a Project Using Packages, Protocols, and ASDF"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a simple project that simulates different types of animals."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Directory Structure:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"animal-simulator/\n\u251c\u2500\u2500 animal-simulator.asd\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 package.lisp\n    \u251c\u2500\u2500 animal.lisp\n    \u2514\u2500\u2500 simulator.lisp\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"src/package.lisp:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defpackage :animal-simulator\n  (:use :common-lisp)\n  (:export :animal :make-animal :animal-name :animal-sound\n           :simulate-round))\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"src/animal.lisp:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(in-package :animal-simulator)\n\n(defclass animal ()\n  ((name :initarg :name :accessor animal-name)))\n\n(defgeneric animal-sound (animal)\n  (:documentation "Returns the sound an animal makes."))\n\n(defmethod animal-sound ((animal animal))\n  "Generic animal sound")\n\n(defclass dog (animal) ())\n\n(defmethod animal-sound ((dog dog))\n  "Woof!")\n\n(defclass cat (animal) ())\n\n(defmethod animal-sound ((cat cat))\n  "Meow!")\n\n(defun make-animal (type name)\n  (make-instance type :name name))\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"src/simulator.lisp:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(in-package :animal-simulator)\n\n(defun simulate-round (animals)\n  (dolist (animal animals)\n    (format t "~a says ~a~%" (animal-name animal) (animal-sound animal))))\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"animal-simulator.asd:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :animal-simulator\n  :description "A simple animal simulator"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :components ((:file "src/package")\n               (:file "src/animal")\n               (:file "src/simulator")))\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Using the Project:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Load the system:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(ql:quickload :animal-simulator)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use the functions:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(in-package :animal-simulator)\n\n(let ((animals (list (make-animal \'dog "Rover")\n                     (make-animal \'cat "Whiskers")\n                     (make-animal \'animal "Generic"))))\n  (simulate-round animals))\n; Output:\n; Rover says Woof!\n; Whiskers says Meow!\n; Generic says Generic animal sound\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This example demonstrates how to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Define a package (",(0,i.jsx)(n.code,{children:"animal-simulator"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Define a protocol (",(0,i.jsx)(n.code,{children:"animal-sound"})," as a generic function)."]}),"\n",(0,i.jsxs)(n.li,{children:["Implement the protocol for different classes (",(0,i.jsx)(n.code,{children:"dog"})," and ",(0,i.jsx)(n.code,{children:"cat"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Organize the code into multiple files."}),"\n",(0,i.jsx)(n.li,{children:"Use ASDF to manage the project."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By following these best practices and using the tools provided by Common Lisp, you can effectively structure and manage even complex projects. This concludes the tutorial on packages, protocols, and multi-file projects. You should now be equipped to organize your Lisp code in a modular and maintainable way."})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>l});var i=s(7294);const a={},o=i.createContext(a);function l(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);