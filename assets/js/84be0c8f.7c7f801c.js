"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[4792],{2190:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});var i=s(5893),r=s(1151);const a={sidebar_position:9},o="Macros",t={id:"tutorial/macros",title:"Macros",description:"This article needs to be checked!.",source:"@site/docs/tutorial/macros.md",sourceDirName:"tutorial",slug:"/tutorial/macros",permalink:"/docs/tutorial/macros",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/macros.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Condition System",permalink:"/docs/tutorial/conditions"},next:{title:"Advanced Topics",permalink:"/docs/category/advanced-topics"}},l={},c=[{value:"Introduction to Macros in Common Lisp",id:"introduction-to-macros-in-common-lisp",level:2},{value:"1. Introduction to Macros",id:"1-introduction-to-macros",level:2},{value:"1.1 What are Macros?",id:"11-what-are-macros",level:3},{value:"1.2 Macros vs. Functions",id:"12-macros-vs-functions",level:3},{value:"Example",id:"example",level:4},{value:"1.3 The Macro Expansion Process",id:"13-the-macro-expansion-process",level:3},{value:"Example of Macro Expansion",id:"example-of-macro-expansion",level:4},{value:"2. Defining Macros with <code>defmacro</code>",id:"2-defining-macros-with-defmacro",level:2},{value:"2.1 Basic <code>defmacro</code> Syntax",id:"21-basic-defmacro-syntax",level:3},{value:"2.2 Macro Parameters",id:"22-macro-parameters",level:3},{value:"Examples of Parameter Lists",id:"examples-of-parameter-lists",level:4},{value:"2.3 The Macro Body",id:"23-the-macro-body",level:3},{value:"Example: A Simple Macro",id:"example-a-simple-macro",level:4},{value:"Example with <code>&amp;rest</code> and <code>,@</code>",id:"example-with-rest-and-",level:4},{value:"Example with <code>&amp;key</code>",id:"example-with-key",level:4},{value:"3. Backquote (`) and Comma (,)",id:"3-backquote--and-comma-",level:2},{value:"3.1 Backquote for Quoting Code Templates",id:"31-backquote-for-quoting-code-templates",level:3},{value:"3.2 Comma for Unquoting Expressions within Backquoted Templates",id:"32-comma-for-unquoting-expressions-within-backquoted-templates",level:3},{value:"Example",id:"example-1",level:4},{value:"3.3 Comma-at (<code>,@</code>) for Splicing Lists",id:"33-comma-at--for-splicing-lists",level:3},{value:"Example",id:"example-2",level:4},{value:"Example showing the difference between , and ,@",id:"example-showing-the-difference-between--and-",level:4},{value:"4. Macro Expansion",id:"4-macro-expansion",level:2},{value:"4.1 <code>macroexpand-1</code>: Expanding a Macro Call Once",id:"41-macroexpand-1-expanding-a-macro-call-once",level:3},{value:"Examples",id:"examples",level:4},{value:"Example with nested macros",id:"example-with-nested-macros",level:4},{value:"4.2 <code>macroexpand</code>: Fully Expanding a Macro Call",id:"42-macroexpand-fully-expanding-a-macro-call",level:3},{value:"Example using the nested macros from above",id:"example-using-the-nested-macros-from-above",level:4},{value:"Example with no macros",id:"example-with-no-macros",level:4},{value:"Example",id:"example-3",level:4},{value:"5. Macro Arguments",id:"5-macro-arguments",level:2},{value:"5.1 Required, Optional, and Rest Parameters in Macros",id:"51-required-optional-and-rest-parameters-in-macros",level:3},{value:"Examples",id:"examples-1",level:4},{value:"5.2 Destructuring in Macro Parameters",id:"52-destructuring-in-macro-parameters",level:3},{value:"Example",id:"example-4",level:4},{value:"6. Macro Hygiene and <code>gensym</code>",id:"6-macro-hygiene-and-gensym",level:2},{value:"6.1 The Problem of Variable Capture",id:"61-the-problem-of-variable-capture",level:3},{value:"Example of Variable Capture",id:"example-of-variable-capture",level:4},{value:"6.2 Using <code>gensym</code> to Create Unique Symbols",id:"62-using-gensym-to-create-unique-symbols",level:3},{value:"7. Examples and Advanced Techniques",id:"7-examples-and-advanced-techniques",level:2},{value:"7.1 Creating Control Flow Macros",id:"71-creating-control-flow-macros",level:3},{value:"7.2 Implementing Domain-Specific Languages (DSLs)",id:"72-implementing-domain-specific-languages-dsls",level:3},{value:"Example: A simple HTML DSL",id:"example-a-simple-html-dsl",level:4},{value:"7.3 Debugging Macros",id:"73-debugging-macros",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"macros",children:"Macros"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["This article ",(0,i.jsx)(n.strong,{children:"needs to be checked!"}),".\nPlease help contribute by checking it and making changes in ",(0,i.jsx)(n.a,{href:"https://github.com/lisp-docs/lisp-docs.github.io",children:"our repository"}),' or by clicking on the "Edit this page" link below.']})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-macros-in-common-lisp",children:"Introduction to Macros in Common Lisp"}),"\n",(0,i.jsxs)(n.p,{children:["Macros are a powerful metaprogramming feature in Common Lisp that allow you to extend the language itself. Unlike functions, which operate on evaluated arguments at runtime, macros operate on the ",(0,i.jsx)(n.em,{children:"unevaluated"})," code (the abstract syntax tree or AST) at compile time. This allows you to perform code transformations, create new syntactic forms, and implement domain-specific languages within Lisp."]}),"\n",(0,i.jsx)(n.p,{children:"This tutorial will introduce you to the fundamental concepts of macros, including how they work, how to define them, and how to use them effectively. We'll also cover related concepts like backquote, comma, and macro expansion."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code as Data:"})," Lisp code is represented as lists, which are also Lisp data structures. This allows macros to manipulate code as data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Macro Expansion:"})," The process of transforming macro calls into Lisp code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"defmacro"}),":"]})," The special form used to define macros."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backquote (`) and Comma (,):"})," Special operators used for constructing Lisp code within macros."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Macro Arguments:"})," The unevaluated forms passed to a macro."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hygiene:"})," Preventing unintended variable capture in macros."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Table of Contents:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Introduction to Macros:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What are macros?"}),"\n",(0,i.jsx)(n.li,{children:"Macros vs. functions."}),"\n",(0,i.jsx)(n.li,{children:"The macro expansion process."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["2. Defining Macros with ",(0,i.jsx)(n.code,{children:"defmacro"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Basic ",(0,i.jsx)(n.code,{children:"defmacro"})," syntax."]}),"\n",(0,i.jsx)(n.li,{children:"Macro parameters."}),"\n",(0,i.jsx)(n.li,{children:"The macro body."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Backquote (`) and Comma (,):"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Backquote for quoting code templates."}),"\n",(0,i.jsx)(n.li,{children:"Comma for unquoting expressions within backquoted templates."}),"\n",(0,i.jsxs)(n.li,{children:["Comma-at (",(0,i.jsx)(n.code,{children:",@"}),") for splicing lists."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Macro Expansion:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"macroexpand-1"}),": Expanding a macro call once."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"macroexpand"}),": Fully expanding a macro call."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Macro Arguments:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Required, optional, and rest parameters in macros."}),"\n",(0,i.jsx)(n.li,{children:"Destructuring in macro parameters."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["6. Macro Hygiene and ",(0,i.jsx)(n.code,{children:"gensym"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The problem of variable capture."}),"\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"gensym"})," to create unique symbols."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7. Examples and Advanced Techniques:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creating control flow macros."}),"\n",(0,i.jsx)(n.li,{children:"Implementing domain-specific languages (DSLs)."}),"\n",(0,i.jsx)(n.li,{children:"Debugging macros."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This tutorial will provide a comprehensive introduction to macros in Common Lisp, equipping you with the knowledge to extend the language and write more expressive and powerful code."}),"\n",(0,i.jsx)(n.h2,{id:"1-introduction-to-macros",children:"1. Introduction to Macros"}),"\n",(0,i.jsx)(n.p,{children:"Macros are a powerful feature of Common Lisp that allow you to extend the syntax of the language. They operate on code at compile time, transforming it before it is evaluated. This section introduces the basic concepts of macros."}),"\n",(0,i.jsx)(n.h3,{id:"11-what-are-macros",children:"1.1 What are Macros?"}),"\n",(0,i.jsx)(n.p,{children:"Macros are essentially code transformers. They take Lisp code as input (in its unevaluated form) and produce new Lisp code as output. This output is then evaluated by the Lisp interpreter or compiler."}),"\n",(0,i.jsxs)(n.p,{children:["Think of macros as functions that operate on ",(0,i.jsx)(n.em,{children:"code"})," rather than ",(0,i.jsx)(n.em,{children:"data"}),". While a function receives evaluated arguments and returns a value, a macro receives unevaluated code forms (lists, symbols, etc.) and returns a new code form."]}),"\n",(0,i.jsx)(n.h3,{id:"12-macros-vs-functions",children:"1.2 Macros vs. Functions"}),"\n",(0,i.jsx)(n.p,{children:"Here's a comparison highlighting the key differences between macros and functions:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Macro"}),(0,i.jsx)(n.th,{children:"Function"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Evaluation Time"}),(0,i.jsx)(n.td,{children:"Compile time (before evaluation)"}),(0,i.jsx)(n.td,{children:"Runtime (during evaluation)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Arguments"}),(0,i.jsx)(n.td,{children:"Unevaluated code forms (syntax trees)"}),(0,i.jsx)(n.td,{children:"Evaluated values"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Return Value"}),(0,i.jsx)(n.td,{children:"A new code form (to be evaluated)"}),(0,i.jsx)(n.td,{children:"A value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Purpose"}),(0,i.jsx)(n.td,{children:"Code transformation, syntax extension"}),(0,i.jsx)(n.td,{children:"Computation, data manipulation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"How it works"}),(0,i.jsx)(n.td,{children:"Transforms code before it is interpreted/compiled"}),(0,i.jsx)(n.td,{children:"Executes code to compute a result based on arguments"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["Let's imagine we want a shorthand for a simple ",(0,i.jsx)(n.code,{children:"if"})," statement that checks if a number is positive:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Function approach (less ideal for syntax extension):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defun is-positive-then (number then-form)\n  (if (> number 0)\n      (eval then-form) ; Avoid using eval in most cases\n      nil))\n\n(is-positive-then 5 \'(print "Positive!")) ; Prints "Positive!"\n(is-positive-then -1 \'(print "Positive!")) ; Returns NIL\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This function takes the ",(0,i.jsx)(n.code,{children:"then-form"})," as a list and uses ",(0,i.jsx)(n.code,{children:"eval"})," to evaluate it. This is generally discouraged due to performance and scoping issues."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Macro approach (more powerful):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro when-positive (number &body body)\n  `(if (> ,number 0)\n       (progn ,@body)))\n\n(when-positive 5 (print "Positive!") (print "Another action!")) ; Prints "Positive!" and "Another action!"\n(when-positive -1 (print "Positive!")) ; Does nothing\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This macro takes the ",(0,i.jsx)(n.code,{children:"body"})," as a list of forms and uses backquote and comma (explained in the next section) to construct the ",(0,i.jsx)(n.code,{children:"if"})," expression. The key advantage here is that the ",(0,i.jsx)(n.code,{children:"body"})," forms are ",(0,i.jsx)(n.em,{children:"not"})," evaluated by the macro itself; they are inserted directly into the resulting code, which is then evaluated by Lisp."]}),"\n",(0,i.jsx)(n.h3,{id:"13-the-macro-expansion-process",children:"1.3 The Macro Expansion Process"}),"\n",(0,i.jsx)(n.p,{children:"The macro expansion process happens before the code is evaluated or compiled. It consists of the following steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Macro Call:"})," The Lisp system encounters a form where the first element is a macro name (e.g., ",(0,i.jsx)(n.code,{children:"when-positive"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Macro Expansion:"})," The macro function associated with the macro name is called. The unevaluated arguments of the macro call are passed to the macro function."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code Transformation:"})," The macro function performs its code transformation and returns a new Lisp form."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result Evaluation/Compilation:"})," The resulting form (the ",(0,i.jsx)(n.em,{children:"macro expansion"}),") replaces the original macro call in the code. This expanded code is then evaluated or compiled as usual."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-of-macro-expansion",children:"Example of Macro Expansion"}),"\n",(0,i.jsxs)(n.p,{children:["Let's trace the expansion of the ",(0,i.jsx)(n.code,{children:"when-positive"})," macro:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(when-positive 5 (print "Positive!"))\n'})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Macro Call:"})," The Lisp system sees ",(0,i.jsx)(n.code,{children:'(when-positive 5 (print "Positive!"))'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Macro Expansion:"})," The ",(0,i.jsx)(n.code,{children:"when-positive"})," macro function is called with the arguments ",(0,i.jsx)(n.code,{children:"5"})," and ",(0,i.jsx)(n.code,{children:'(print "Positive!")'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Code Transformation:"})," The macro function returns the following code form:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(if (> 5 0)\n    (progn (print "Positive!")))\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Result Evaluation:"}),' This expanded form is now evaluated by Lisp, printing "Positive!".']}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," and ",(0,i.jsx)(n.code,{children:"macroexpand"})," functions (covered later) are crucial for inspecting the results of macro expansion."]}),"\n",(0,i.jsxs)(n.p,{children:["Understanding the macro expansion process is key to understanding how macros work and how to write them effectively. The next section will cover the ",(0,i.jsx)(n.code,{children:"defmacro"})," special form, which is used to define macros."]}),"\n",(0,i.jsxs)(n.h2,{id:"2-defining-macros-with-defmacro",children:["2. Defining Macros with ",(0,i.jsx)(n.code,{children:"defmacro"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"defmacro"})," special form is used to define macros in Common Lisp. This section explains the syntax of ",(0,i.jsx)(n.code,{children:"defmacro"})," and how to use it to create your own macros."]}),"\n",(0,i.jsxs)(n.h3,{id:"21-basic-defmacro-syntax",children:["2.1 Basic ",(0,i.jsx)(n.code,{children:"defmacro"})," Syntax"]}),"\n",(0,i.jsxs)(n.p,{children:["The basic syntax of ",(0,i.jsx)(n.code,{children:"defmacro"})," is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro macro-name (parameter-list)\n  "Optional documentation string"\n  body)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"macro-name"})}),": The name of the macro (a symbol)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"parameter-list"})}),": A list of parameters that the macro accepts."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:'"Optional documentation string"'}),": A string that describes the macro's purpose. This is good practice for documenting your macros."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"body"})}),": The Lisp code that performs the macro's transformation. This code should return a new Lisp form."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"22-macro-parameters",children:"2.2 Macro Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"parameter-list"})," in ",(0,i.jsx)(n.code,{children:"defmacro"})," can contain several types of parameters:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Required parameters:"})," These are parameters that must be provided when the macro is called. They are represented by symbols."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optional parameters:"})," These parameters are optional and can have default values. They are specified using ",(0,i.jsx)(n.code,{children:"&optional"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rest parameter:"})," This parameter collects any remaining arguments into a list. It is specified using ",(0,i.jsx)(n.code,{children:"&rest"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Keyword parameters:"})," These parameters are passed using keywords (e.g., ",(0,i.jsx)(n.code,{children:":key1 value1"}),"). They are specified using ",(0,i.jsx)(n.code,{children:"&key"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Auxiliary variables:"})," These are local variables used within the macro body. They are specified using ",(0,i.jsx)(n.code,{children:"&aux"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"examples-of-parameter-lists",children:"Examples of Parameter Lists"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x y)"}),": Two required parameters, ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x &optional y)"}),": One required parameter ",(0,i.jsx)(n.code,{children:"x"})," and one optional parameter ",(0,i.jsx)(n.code,{children:"y"})," (default value is ",(0,i.jsx)(n.code,{children:"nil"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x &optional (y 10))"}),": One required parameter ",(0,i.jsx)(n.code,{children:"x"})," and one optional parameter ",(0,i.jsx)(n.code,{children:"y"})," with a default value of ",(0,i.jsx)(n.code,{children:"10"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x &rest rest)"}),": One required parameter ",(0,i.jsx)(n.code,{children:"x"})," and a rest parameter ",(0,i.jsx)(n.code,{children:"rest"})," (which will be a list of any remaining arguments)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(&key name age)"}),": Two keyword parameters ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"age"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'(&key (name "default") (age 20))'})," Keyword parameters with default values."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x &aux (z (+ x 1)))"}),": One required parameter x and an auxiliary variable ",(0,i.jsx)(n.code,{children:"z"})," initialized to ",(0,i.jsx)(n.code,{children:"(+ x 1)"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"23-the-macro-body",children:"2.3 The Macro Body"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"body"})," of a ",(0,i.jsx)(n.code,{children:"defmacro"})," form contains the Lisp code that performs the macro's transformation. This code should return a new Lisp form, which will replace the original macro call."]}),"\n",(0,i.jsxs)(n.p,{children:["The most common way to construct the new Lisp form is to use ",(0,i.jsx)(n.em,{children:"backquote"})," (`) and ",(0,i.jsx)(n.em,{children:"comma"})," (,)."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backquote (`)"}),": Creates a template for the new code form. Expressions within the backquoted template are not evaluated unless they are preceded by a comma."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Comma (,):"})," Unquotes an expression within a backquoted template. The expression is evaluated, and its result is inserted into the template."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Comma-at (",(0,i.jsx)(n.code,{children:",@"}),"):"]})," Splices a list into a backquoted template. The elements of the list are inserted directly into the template, without creating a sublist."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-a-simple-macro",children:"Example: A Simple Macro"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-add (x y)\n  `(+ ,x ,y))\n\n(my-add 2 3) ; Expands to (+ 2 3), which evaluates to 5\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"defmacro"})," form defines a macro named ",(0,i.jsx)(n.code,{children:"my-add"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The parameter list is ",(0,i.jsx)(n.code,{children:"(x y)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The body is ",(0,i.jsx)(n.code,{children:"`(+ ,x ,y)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The backquote creates the template ",(0,i.jsx)(n.code,{children:"(+ ,x ,y)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The commas before ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"})," cause their values to be inserted into the template."]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"example-with-rest-and-",children:["Example with ",(0,i.jsx)(n.code,{children:"&rest"})," and ",(0,i.jsx)(n.code,{children:",@"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-sum (&rest numbers)\n  `(+ ,@numbers))\n\n(my-sum 1 2 3 4) ; Expands to (+ 1 2 3 4), which evaluates to 10\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"&rest numbers"})," parameter collects all arguments into a list named ",(0,i.jsx)(n.code,{children:"numbers"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:",@numbers"})," splices the elements of the ",(0,i.jsx)(n.code,{children:"numbers"})," list into the ",(0,i.jsx)(n.code,{children:"+"})," form."]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"example-with-key",children:["Example with ",(0,i.jsx)(n.code,{children:"&key"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro make-point (&key (x 0) (y 0))\n  `(list :x ,x :y ,y))\n\n(make-point :x 10 :y 20) ; Expands to (LIST :X 10 :Y 20)\n(make-point :x 5)      ; Expands to (LIST :X 5 :Y 0)\n(make-point)           ; Expands to (LIST :X 0 :Y 0)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This macro creates a point represented as a list with ",(0,i.jsx)(n.code,{children:":x"})," and ",(0,i.jsx)(n.code,{children:":y"})," keys. It uses keyword parameters with default values."]}),"\n",(0,i.jsxs)(n.p,{children:["Understanding ",(0,i.jsx)(n.code,{children:"defmacro"}),", parameter lists, backquote, comma, and comma-at is essential for writing effective macros in Common Lisp. The next section will cover macro expansion in more detail."]}),"\n",(0,i.jsx)(n.h2,{id:"3-backquote--and-comma-",children:"3. Backquote (`) and Comma (,)"}),"\n",(0,i.jsx)(n.p,{children:"Backquote (`) and comma (,) are special operators in Common Lisp that are essential for writing macros. They provide a concise and powerful way to construct Lisp code templates."}),"\n",(0,i.jsx)(n.h3,{id:"31-backquote-for-quoting-code-templates",children:"3.1 Backquote for Quoting Code Templates"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"backquote"})," character (",(0,i.jsx)(n.code,{children:") is a shorthand for the"}),"quote` special form, but with the added ability to ",(0,i.jsx)(n.em,{children:"unquote"})," expressions within the quoted form. It creates a template for Lisp code, where most parts are treated literally, but some parts can be dynamically inserted."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Basic Usage:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"`(a b c) ; Equivalent to (quote (a b c))\n        ; Evaluates to (A B C)\n\n`(1 2 3) ; Equivalent to (quote (1 2 3))\n        ; Evaluates to (1 2 3)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In these simple cases, backquote behaves exactly like ",(0,i.jsx)(n.code,{children:"quote"}),". However, its power comes into play when combined with the comma."]}),"\n",(0,i.jsx)(n.h3,{id:"32-comma-for-unquoting-expressions-within-backquoted-templates",children:"3.2 Comma for Unquoting Expressions within Backquoted Templates"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"comma"})," character (,) is used to ",(0,i.jsx)(n.em,{children:"unquote"})," an expression within a backquoted template. The expression following the comma is evaluated, and its result is inserted into the template."]}),"\n",(0,i.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(let ((x 10))\n  `(a b ,x c)) ; Evaluates to (A B 10 C)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here's how it works:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The backquote creates a template ",(0,i.jsx)(n.code,{children:"(a b ,x c)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The comma before ",(0,i.jsx)(n.code,{children:"x"})," causes the value of ",(0,i.jsx)(n.code,{children:"x"})," (which is 10) to be inserted into the template."]}),"\n",(0,i.jsxs)(n.li,{children:["The resulting list ",(0,i.jsx)(n.code,{children:"(A B 10 C)"})," is returned."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"More Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(let ((name "Alice"))\n  `(hello ,name)) ; Evaluates to (HELLO "Alice")\n\n(let ((operation \'+))\n  `(,operation 5 3)) ; Evaluates to (+ 5 3), which then evaluates to 8\n\n(let ((list \'(1 2 3)))\n    `(a ,list b)) ; Evaluates to (A (1 2 3) B)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Without the comma, the ",(0,i.jsx)(n.code,{children:"x"})," in ",(0,i.jsx)(n.code,{children:"`(a b x c)"})," would be treated as a literal symbol ",(0,i.jsx)(n.code,{children:"X"}),", not the value of the variable ",(0,i.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"33-comma-at--for-splicing-lists",children:["3.3 Comma-at (",(0,i.jsx)(n.code,{children:",@"}),") for Splicing Lists"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"comma-at"})," operator (",(0,i.jsx)(n.code,{children:",@"}),") is used to ",(0,i.jsx)(n.em,{children:"splice"})," a list into a backquoted template. This means that the ",(0,i.jsx)(n.em,{children:"elements"})," of the list are inserted directly into the template, rather than the list itself being inserted as a sublist."]}),"\n",(0,i.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(let ((numbers '(1 2 3)))\n  `(a ,@numbers b)) ; Evaluates to (A 1 2 3 B)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here's the difference between comma and comma-at:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:","})," inserts the ",(0,i.jsx)(n.em,{children:"value"})," of the expression."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:",@"})," inserts the ",(0,i.jsx)(n.em,{children:"elements"})," of the list that is the value of the expression."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"More Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(let ((names \'("Alice" "Bob")))\n    `(hello ,@names and everyone else)) ; Evaluates to (HELLO "Alice" "Bob" AND EVERYONE ELSE)\n\n(let ((forms \'((+ 1 2) (* 3 4))))\n    `(progn ,@forms)) ; Evaluates to (PROGN (+ 1 2) (* 3 4))\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Common Use Case in Macros:"})}),"\n",(0,i.jsxs)(n.p,{children:["Comma-at is commonly used with ",(0,i.jsx)(n.code,{children:"&rest"})," parameters in macros to insert the collected arguments into the generated code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-list (&rest items)\n  `(list ,@items))\n\n(my-list 1 2 3) ; Expands to (LIST 1 2 3)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this macro, ",(0,i.jsx)(n.code,{children:"&rest items"})," collects all arguments into the list ",(0,i.jsx)(n.code,{children:"items"}),". The ",(0,i.jsx)(n.code,{children:",@items"})," then splices the elements of ",(0,i.jsx)(n.code,{children:"items"})," into the ",(0,i.jsx)(n.code,{children:"list"})," form."]}),"\n",(0,i.jsx)(n.h4,{id:"example-showing-the-difference-between--and-",children:"Example showing the difference between , and ,@"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(let ((items '(1 2 3)))\n  `(list ,items)) ; Evaluates to (LIST (1 2 3)) ; A sublist\n\n(let ((items '(1 2 3)))\n  `(list ,@items)) ; Evaluates to (LIST 1 2 3)     ; Splices the elements\n"})}),"\n",(0,i.jsx)(n.p,{children:"Understanding backquote, comma, and comma-at is crucial for writing effective and concise macros. They provide a powerful way to construct and manipulate Lisp code within macros. The next section will cover macro expansion in more detail."}),"\n",(0,i.jsx)(n.h2,{id:"4-macro-expansion",children:"4. Macro Expansion"}),"\n",(0,i.jsxs)(n.p,{children:["Understanding macro expansion is crucial for debugging and understanding how macros work. Common Lisp provides two functions for inspecting the result of macro expansion: ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," and ",(0,i.jsx)(n.code,{children:"macroexpand"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"41-macroexpand-1-expanding-a-macro-call-once",children:["4.1 ",(0,i.jsx)(n.code,{children:"macroexpand-1"}),": Expanding a Macro Call Once"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," function expands a macro call ",(0,i.jsx)(n.em,{children:"once"}),". If the given form is not a macro call, it simply returns the form unchanged."]}),"\n",(0,i.jsx)(n.p,{children:"The syntax is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(macroexpand-1 form &optional environment)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"form"}),": The Lisp form to expand."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"environment"}),": An optional environment to use for expansion (usually not needed for simple cases)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"macroexpand-1"})," returns two values:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The expanded form."}),"\n",(0,i.jsx)(n.li,{children:"A boolean indicating whether the form was expanded (T) or not (NIL)."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(n.p,{children:["Let's use the ",(0,i.jsx)(n.code,{children:"when-positive"})," macro from a previous example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro when-positive (number &body body)\n  `(if (> ,number 0)\n       (progn ,@body)))\n\n(macroexpand-1 \'(when-positive 5 (print "Positive!")))\n; Returns:\n; (IF (> 5 0) (PROGN (PRINT "Positive!")))\n; T\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," expands the ",(0,i.jsx)(n.code,{children:"when-positive"})," macro call into its corresponding ",(0,i.jsx)(n.code,{children:"if"})," form. The second return value ",(0,i.jsx)(n.code,{children:"T"})," indicates that an expansion occurred."]}),"\n",(0,i.jsx)(n.p,{children:"If the form is not a macro call:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(macroexpand-1 '(+ 1 2))\n; Returns:\n; (+ 1 2)\n; NIL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this case, ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," returns the form unchanged, and the second return value is ",(0,i.jsx)(n.code,{children:"NIL"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"example-with-nested-macros",children:"Example with nested macros"}),"\n",(0,i.jsxs)(n.p,{children:["If you have nested macros, ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," only expands the outermost macro:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro my-print (x) `(print ,x))\n(defmacro my-when (condition &body body) `(if ,condition (progn ,@body)))\n\n(macroexpand-1 \'(my-when (> 5 0) (my-print "Hello")))\n; Returns:\n; (IF (> 5 0) (PROGN (MY-PRINT "Hello")))\n; T\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Only ",(0,i.jsx)(n.code,{children:"my-when"})," is expanded. ",(0,i.jsx)(n.code,{children:"my-print"})," is left as is."]}),"\n",(0,i.jsxs)(n.h3,{id:"42-macroexpand-fully-expanding-a-macro-call",children:["4.2 ",(0,i.jsx)(n.code,{children:"macroexpand"}),": Fully Expanding a Macro Call"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"macroexpand"})," function fully expands a macro call, recursively expanding any nested macros until no more expansions are possible."]}),"\n",(0,i.jsx)(n.p,{children:"The syntax is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(macroexpand form &optional environment)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"form"}),": The Lisp form to expand."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"environment"}),": An optional environment to use for expansion (usually not needed for simple cases)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"macroexpand"})," also returns two values:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The fully expanded form."}),"\n",(0,i.jsx)(n.li,{children:"A boolean indicating whether the form was expanded (T) or not (NIL)."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-using-the-nested-macros-from-above",children:"Example using the nested macros from above"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(macroexpand \'(my-when (> 5 0) (my-print "Hello")))\n; Returns:\n; (IF (> 5 0) (PROGN (PRINT "Hello")))\n; T\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This time, ",(0,i.jsx)(n.code,{children:"macroexpand"})," expands both ",(0,i.jsx)(n.code,{children:"my-when"})," ",(0,i.jsx)(n.em,{children:"and"})," ",(0,i.jsx)(n.code,{children:"my-print"}),", resulting in the fully expanded form."]}),"\n",(0,i.jsx)(n.h4,{id:"example-with-no-macros",children:"Example with no macros"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(macroexpand '(+ 1 2))\n; Returns:\n; (+ 1 2)\n; NIL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the form contains no macros, ",(0,i.jsx)(n.code,{children:"macroexpand"})," returns the form unchanged, just like ",(0,i.jsx)(n.code,{children:"macroexpand-1"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Using ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," and ",(0,i.jsx)(n.code,{children:"macroexpand"})," for Debugging:"]})}),"\n",(0,i.jsx)(n.p,{children:"These functions are invaluable for debugging macros. By inspecting the expanded code, you can see exactly what your macro is generating and identify any errors in your macro definition."}),"\n",(0,i.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["If you have a macro that's not behaving as expected, you can use ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," or ",(0,i.jsx)(n.code,{children:"macroexpand"})," to see the generated code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro buggy-macro (x) `(setf y ,x)) ; Intended to set a local variable\n\n(macroexpand-1 '(buggy-macro 10))\n; Returns:\n; (SETF Y 10)\n; T\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This reveals that the macro is setting the ",(0,i.jsx)(n.em,{children:"global"})," variable ",(0,i.jsx)(n.code,{children:"y"}),", not a local variable. To fix this, you would need to use ",(0,i.jsx)(n.code,{children:"gensym"})," (as explained in the next section) to create a unique local variable name."]}),"\n",(0,i.jsxs)(n.p,{children:["Understanding ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," and ",(0,i.jsx)(n.code,{children:"macroexpand"})," is essential for debugging and understanding how macros transform code. They provide a powerful way to inspect the inner workings of macros. The next section will cover macro arguments in more detail."]}),"\n",(0,i.jsx)(n.h2,{id:"5-macro-arguments",children:"5. Macro Arguments"}),"\n",(0,i.jsx)(n.p,{children:"This section covers how to handle arguments passed to macros, including required, optional, rest, and keyword parameters, as well as destructuring."}),"\n",(0,i.jsx)(n.h3,{id:"51-required-optional-and-rest-parameters-in-macros",children:"5.1 Required, Optional, and Rest Parameters in Macros"}),"\n",(0,i.jsx)(n.p,{children:"Macro parameter lists support the same kinds of parameters as function parameter lists: required, optional, and rest parameters."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Required parameters:"})," These parameters ",(0,i.jsx)(n.em,{children:"must"})," be provided when the macro is called."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optional parameters:"})," These parameters are optional and can have default values. They are introduced by ",(0,i.jsx)(n.code,{children:"&optional"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rest parameter:"})," This parameter collects any remaining arguments into a list. It is introduced by ",(0,i.jsx)(n.code,{children:"&rest"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"examples-1",children:"Examples"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Required parameters:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-times (x y)\n  `(* ,x ,y))\n\n(my-times 2 3) ; Expands to (* 2 3)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"})," are required parameters."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Optional parameters:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-increment (x &optional (by 1))\n  `(+ ,x ,by))\n\n(my-increment 5)    ; Expands to (+ 5 1)\n(my-increment 5 3)  ; Expands to (+ 5 3)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"by"})," is an optional parameter with a default value of ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Rest parameter:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro my-print-all (&rest items)\n  `(progn ,@(mapcar #\'(lambda (item) `(print ,item)) items)))\n\n(my-print-all 1 "hello" \'foo)\n; Expands to:\n; (PROGN (PRINT 1) (PRINT "hello") (PRINT \'FOO))\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"items"})," is a rest parameter that collects all remaining arguments into a list. ",(0,i.jsx)(n.code,{children:"mapcar"})," is used to generate a list of ",(0,i.jsx)(n.code,{children:"print"})," forms, which are then spliced into the ",(0,i.jsx)(n.code,{children:"progn"})," form using ",(0,i.jsx)(n.code,{children:",@"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Keyword parameters:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro make-person (&key name (age 0))\n    `(list :name ,name :age ,age))\n\n(make-person :name "John" :age 30) ; Expands to (LIST :NAME "John" :AGE 30)\n(make-person :name "Jane")       ; Expands to (LIST :NAME "Jane" :AGE 0)\n(make-person :age 25)           ; Expands to (LIST :NAME NIL :AGE 25)\n(make-person)                   ; Expands to (LIST :NAME NIL :AGE 0)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"age"})," are keyword parameters with default values."]}),"\n",(0,i.jsx)(n.h3,{id:"52-destructuring-in-macro-parameters",children:"5.2 Destructuring in Macro Parameters"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Destructuring"})," allows you to match complex data structures in macro parameter lists. This is particularly useful when you want to handle list arguments with specific structures."]}),"\n",(0,i.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro set-point (point value)\n  `(setf (aref ,point 0) (car ,value)\n         (aref ,point 1) (cdr ,value)))\n\n(let ((p (make-array 2)))\n  (set-point p '(10 20))\n  p) ; Returns #(10 20)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This macro expects the ",(0,i.jsx)(n.code,{children:"value"})," argument to be a cons cell (a list of two elements)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Destructuring with nested lists:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro set-point ((x y) value)\n  `(progn\n     (setf ,x (car ,value))\n     (setf ,y (cadr ,value))))\n\n(let ((x 0) (y 0))\n    (set-point (x y) '(10 20))\n    (list x y)) ; Returns (10 20)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, the parameter list ",(0,i.jsx)(n.code,{children:"(x y)"})," destructures the first argument. If you call the macro with ",(0,i.jsx)(n.code,{children:"(set-point (a b) '(10 20))"}),", ",(0,i.jsx)(n.code,{children:"a"})," will be bound to ",(0,i.jsx)(n.code,{children:"10"}),", and ",(0,i.jsx)(n.code,{children:"b"})," will be bound to ",(0,i.jsx)(n.code,{children:"20"}),". This is much more concise and readable than manually accessing the elements of the list."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Combining destructuring with ",(0,i.jsx)(n.code,{children:"&rest"}),":"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-map (function &rest lists)\n  `(mapcar ,function ,@lists))\n\n(my-map #'+ '(1 2 3) '(4 5 6)) ; Expands to (MAPCAR #'+ '(1 2 3) '(4 5 6))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This macro uses ",(0,i.jsx)(n.code,{children:"&rest"})," to collect multiple lists and then splices them into the ",(0,i.jsx)(n.code,{children:"mapcar"})," form."]}),"\n",(0,i.jsxs)(n.p,{children:["Destructuring is a powerful feature that makes macros more expressive and easier to use when dealing with structured data. It greatly simplifies code transformation within macros. The next section will cover macro hygiene and ",(0,i.jsx)(n.code,{children:"gensym"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"6-macro-hygiene-and-gensym",children:["6. Macro Hygiene and ",(0,i.jsx)(n.code,{children:"gensym"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Macro hygiene"})," is a crucial concept in Lisp macro programming. It refers to the property that macros should not inadvertently capture variables in the code where they are used. This section explains the problem of variable capture and how to solve it using ",(0,i.jsx)(n.code,{children:"gensym"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"61-the-problem-of-variable-capture",children:"6.1 The Problem of Variable Capture"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Variable capture"})," occurs when a macro introduces a variable name that clashes with a variable name already present in the code where the macro is used. This can lead to unexpected behavior and hard-to-debug errors."]}),"\n",(0,i.jsx)(n.h4,{id:"example-of-variable-capture",children:"Example of Variable Capture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-loop (n &body body)\n  `(let ((i 0)) ; Introduces a variable i\n     (loop repeat ,n\n           do (progn ,@body)\n              (incf i))))\n\n(let ((i 100)) ; Outer i\n  (my-loop 5 (print i))) ; Prints 0, 1, 2, 3, 4, not 100\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the ",(0,i.jsx)(n.code,{children:"my-loop"})," macro introduces a variable ",(0,i.jsx)(n.code,{children:"i"})," for its internal loop counter. However, the code where the macro is used also has a variable named ",(0,i.jsx)(n.code,{children:"i"}),". This causes the macro's ",(0,i.jsx)(n.code,{children:"i"})," to ",(0,i.jsx)(n.em,{children:"capture"})," the outer ",(0,i.jsx)(n.code,{children:"i"}),", resulting in incorrect behavior. The outer ",(0,i.jsx)(n.code,{children:"i"})," is shadowed by the inner ",(0,i.jsx)(n.code,{children:"i"})," of the macro."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Another Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro with-temp-list (list-var &body body)\n  `(let ((temp-list nil))\n     (setf temp-list ,list-var)\n     ,@body\n     temp-list))\n\n(let ((temp-list '(1 2 3)))\n  (with-temp-list '(4 5 6) (print temp-list)))\n;Output: (4 5 6)\n;instead of (1 2 3)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, the ",(0,i.jsx)(n.code,{children:"with-temp-list"})," macro introduces ",(0,i.jsx)(n.code,{children:"temp-list"}),", which unintentionally shadows the outer ",(0,i.jsx)(n.code,{children:"temp-list"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"62-using-gensym-to-create-unique-symbols",children:["6.2 Using ",(0,i.jsx)(n.code,{children:"gensym"})," to Create Unique Symbols"]}),"\n",(0,i.jsxs)(n.p,{children:["The solution to variable capture is to use ",(0,i.jsx)(n.code,{children:"gensym"})," (generate symbol) to create unique, uninterned symbols for internal macro variables. These symbols are guaranteed not to clash with any user-defined variables."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"gensym"})," creates a new symbol that is guaranteed to be different from any other symbol in the system."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(gensym)     ; Returns a unique symbol like #:G123\n(gensym "X-") ; Returns a unique symbol with a prefix like #:X-456\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Fixing the ",(0,i.jsx)(n.code,{children:"my-loop"})," macro:"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro my-loop (n &body body)\n  (let ((i (gensym))) ; Create a unique symbol\n    `(let ((,i 0))\n       (loop repeat ,n\n             do (progn ,@body)\n                (incf ,i)))))\n\n(let ((i 100))\n  (my-loop 5 (print i))) ; Now correctly prints 100 five times\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By using ",(0,i.jsx)(n.code,{children:"(gensym)"})," to create the ",(0,i.jsx)(n.code,{children:"i"})," variable, we ensure that it does not clash with any other variables in the surrounding code."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Fixing the ",(0,i.jsx)(n.code,{children:"with-temp-list"})," macro:"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro with-temp-list (list-var &body body)\n  (let ((temp-list (gensym)))\n    `(let ((,temp-list nil))\n       (setf ,temp-list ,list-var)\n       ,@body\n       ,temp-list)))\n\n(let ((temp-list '(1 2 3)))\n  (with-temp-list '(4 5 6) (print temp-list)))\n;Output: (1 2 3)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now the outer ",(0,i.jsx)(n.code,{children:"temp-list"})," is not shadowed."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Best Practice:"})}),"\n",(0,i.jsxs)(n.p,{children:["It's a best practice to ",(0,i.jsx)(n.em,{children:"always"})," use ",(0,i.jsx)(n.code,{children:"gensym"})," for any variables that are introduced by your macros. This will prevent variable capture and make your macros more robust."]}),"\n",(0,i.jsxs)(n.p,{children:["By understanding macro hygiene and using ",(0,i.jsx)(n.code,{children:"gensym"}),", you can write macros that are safe and predictable. This is essential for building complex Lisp systems and extending the language effectively. The next section will cover examples and advanced macro techniques."]}),"\n",(0,i.jsx)(n.h2,{id:"7-examples-and-advanced-techniques",children:"7. Examples and Advanced Techniques"}),"\n",(0,i.jsx)(n.p,{children:"This section demonstrates some practical applications of macros, including creating control flow macros, implementing simple domain-specific languages (DSLs), and debugging macros."}),"\n",(0,i.jsx)(n.h3,{id:"71-creating-control-flow-macros",children:"7.1 Creating Control Flow Macros"}),"\n",(0,i.jsx)(n.p,{children:"Macros are well-suited for creating custom control flow constructs."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["1. A ",(0,i.jsx)(n.code,{children:"unless"})," macro:"]})}),"\n",(0,i.jsxs)(n.p,{children:["The standard Common Lisp provides ",(0,i.jsx)(n.code,{children:"when"})," and ",(0,i.jsx)(n.code,{children:"unless"}),"; here's an example of how to create ",(0,i.jsx)(n.code,{children:"unless"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro unless (condition &body body)\n  `(when (not ,condition)\n     ,@body))\n\n(let ((x 5))\n  (unless (< x 0)\n    (print "x is not negative"))) ; Prints "x is not negative"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This macro simply inverts the condition of a ",(0,i.jsx)(n.code,{children:"when"})," form."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["2. A ",(0,i.jsx)(n.code,{children:"for-each"})," macro:"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defmacro for-each ((var list) &body body)\n  (let ((glist (gensym)))\n    `(dolist (,var ,glist)\n       (let ((,glist ,list))\n         ,@body))))\n\n(for-each (x '(1 2 3 4 5)) (print x))\n; Prints 1, 2, 3, 4, 5\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This macro iterates over the elements of a list, binding each element to the specified variable. The use of ",(0,i.jsx)(n.code,{children:"gensym"})," prevents variable capture if the user's code already uses a variable with the same name as the list variable."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["3. A ",(0,i.jsx)(n.code,{children:"dotimes-indexed"})," macro:"]})}),"\n",(0,i.jsx)(n.p,{children:"This macro provides an index in addition to the value in each loop iteration."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro dotimes-indexed ((index var sequence) &body body)\n  (let ((gseq (gensym))\n        (gindex (gensym)))\n    `(let ((,gseq ,sequence))\n       (loop for ,gindex from 0 below (length ,gseq)\n             for ,var across ,gseq\n             do (let ((,index ,gindex))\n                  ,@body)))))\n\n(dotimes-indexed (i x #(a b c))\n  (format t "Element ~a at index ~a~%" x i))\n;Prints:\n;Element A at index 0\n;Element B at index 1\n;Element C at index 2\n'})}),"\n",(0,i.jsx)(n.h3,{id:"72-implementing-domain-specific-languages-dsls",children:"7.2 Implementing Domain-Specific Languages (DSLs)"}),"\n",(0,i.jsx)(n.p,{children:"Macros are extremely useful for creating small, embedded DSLs within Lisp."}),"\n",(0,i.jsx)(n.h4,{id:"example-a-simple-html-dsl",children:"Example: A simple HTML DSL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defmacro html (&rest body)\n  `(concatenate \'string ,@body))\n\n(defmacro tag (name &rest content)\n  `(format nil "<~a>~{~a~^ ~}</~a>" ,name ,content ,name))\n\n(defmacro bold (&rest content)\n  `(tag "b" ,@content))\n\n(defmacro paragraph (&rest content)\n  `(tag "p" ,@content))\n\n(html (tag "html"\n           (tag "head" (tag "title" "My Page"))\n           (tag "body"\n                (paragraph (bold "Hello") " world!"))))\n\n;Expands to:\n;(concatenate \'string\n; (format nil "<~a>~{~a~^ ~}</~a>" "html"\n;         (format nil "<~a>~{~a~^ ~}</~a>" "head" (format nil "<~a>~{~a~^ ~}</~a>" "title" "My Page"))\n;         (format nil "<~a>~{~a~^ ~}</~a>" "body" (format nil "<~a>~{~a~^ ~}</~a>" "p" (format nil "<~a>~{~a~^ ~}</~a>" "b" "Hello") " world!")))\n\n;Evaluates to:\n;"<html><head><title>My Page</title></head><body><p><b>Hello</b> world!</p></body></html>"\n'})}),"\n",(0,i.jsx)(n.p,{children:"This example defines macros for creating HTML tags, making it easier to write HTML within Lisp code."}),"\n",(0,i.jsx)(n.h3,{id:"73-debugging-macros",children:"7.3 Debugging Macros"}),"\n",(0,i.jsxs)(n.p,{children:["Debugging macros can be tricky because they operate at compile time. However, the ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," and ",(0,i.jsx)(n.code,{children:"macroexpand"})," functions are invaluable for this purpose."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["1. Using ",(0,i.jsx)(n.code,{children:"macroexpand-1"})," and ",(0,i.jsx)(n.code,{children:"macroexpand"}),":"]})}),"\n",(0,i.jsx)(n.p,{children:"As explained previously, these functions allow you to see the expanded code generated by a macro."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(macroexpand-1 \'(my-loop 3 (print "Hello"))) ; See one level of expansion\n(macroexpand \'(my-loop 3 (print "Hello")))   ; See the fully expanded code\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["2. ",(0,i.jsx)(n.code,{children:"trace"}),":"]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"trace"})," macro can be used to trace the execution of functions, including macro functions. This can be helpful for understanding the steps involved in macro expansion."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(trace my-loop)\n(my-loop 2 (print "Test")) ; Shows the macro expansion process\n\n(untrace my-loop) ; Stop tracing\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Breakpoints in Macros:"})}),"\n",(0,i.jsxs)(n.p,{children:["Some Lisp development environments (like SLIME) allow you to set breakpoints ",(0,i.jsx)(n.em,{children:"within"})," macro definitions. This allows you to step through the macro expansion process and inspect the values of variables at each step."]}),"\n",(0,i.jsx)(n.p,{children:"By using these debugging techniques, you can effectively debug your macros and ensure they are generating the correct code."}),"\n",(0,i.jsx)(n.p,{children:"This section provided examples of creating control flow macros, implementing DSLs, and debugging macros. With these techniques, you can leverage the power of macros to extend Common Lisp and write more expressive code. This concludes the tutorial on macros."})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>t,a:()=>o});var i=s(7294);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);