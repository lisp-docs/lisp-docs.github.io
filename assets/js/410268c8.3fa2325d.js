"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[2622],{986:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>o});var i=n(5893),r=n(1151);const t={sidebar_position:5},a="Data Structures",l={id:"tutorial/data-structures",title:"Data Structures",description:"Introduction to Data Structures in Common Lisp",source:"@site/docs/tutorial/data-structures.md",sourceDirName:"tutorial",slug:"/tutorial/data-structures",permalink:"/docs/tutorial/data-structures",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/data-structures.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Control Flow",permalink:"/docs/tutorial/control-flows"},next:{title:"Functions",permalink:"/docs/tutorial/functions"}},c={},o=[{value:"Introduction to Data Structures in Common Lisp",id:"introduction-to-data-structures-in-common-lisp",level:2},{value:"1. Conses and Lists in Common Lisp",id:"1-conses-and-lists-in-common-lisp",level:2},{value:"1.1 <code>cons</code>: Constructing Cons Cells",id:"11-cons-constructing-cons-cells",level:3},{value:"1.2 <code>car</code> and <code>cdr</code>: Accessing Parts of a Cons Cell",id:"12-car-and-cdr-accessing-parts-of-a-cons-cell",level:3},{value:"1.3 <code>list</code>: Creating Lists",id:"13-list-creating-lists",level:3},{value:"1.4 List Manipulation Functions",id:"14-list-manipulation-functions",level:3},{value:"1.5 Dotted Lists",id:"15-dotted-lists",level:3},{value:"1.6 Association Lists (Alists)",id:"16-association-lists-alists",level:3},{value:"1.7 Property Lists (Plists)",id:"17-property-lists-plists",level:3},{value:"2. Arrays in Common Lisp",id:"2-arrays-in-common-lisp",level:2},{value:"2.1 <code>make-array</code>: Creating Arrays",id:"21-make-array-creating-arrays",level:3},{value:"2.2 <code>aref</code>: Accessing Array Elements",id:"22-aref-accessing-array-elements",level:3},{value:"2.3 Multi-dimensional Arrays",id:"23-multi-dimensional-arrays",level:3},{value:"2.4 Adjustable Arrays",id:"24-adjustable-arrays",level:3},{value:"2.5 Specialized Arrays",id:"25-specialized-arrays",level:3},{value:"3. Structures in Common Lisp",id:"3-structures-in-common-lisp",level:2},{value:"3.1 <code>defstruct</code>: Defining Structures",id:"31-defstruct-defining-structures",level:3},{value:"3.2 Structure Accessors",id:"32-structure-accessors",level:3},{value:"4. Hash Tables in Common Lisp",id:"4-hash-tables-in-common-lisp",level:2},{value:"4.1 <code>make-hash-table</code>: Creating Hash Tables",id:"41-make-hash-table-creating-hash-tables",level:3},{value:"4.2 <code>gethash</code> and <code>setf gethash</code>: Accessing and Modifying Hash Table Entries",id:"42-gethash-and-setf-gethash-accessing-and-modifying-hash-table-entries",level:3},{value:"4.3 Hash Table Options",id:"43-hash-table-options",level:3},{value:"4.4 Iterating over Hash Tables",id:"44-iterating-over-hash-tables",level:3},{value:"5. Strings in Common Lisp",id:"5-strings-in-common-lisp",level:2},{value:"5.1 String Literals",id:"51-string-literals",level:3},{value:"5.2 String Manipulation Functions",id:"52-string-manipulation-functions",level:3},{value:"6. Characters in Common Lisp",id:"6-characters-in-common-lisp",level:2},{value:"6.1 Character Literals",id:"61-character-literals",level:3},{value:"6.2 Character Comparison Functions",id:"62-character-comparison-functions",level:3},{value:"7. Symbols in Common Lisp",id:"7-symbols-in-common-lisp",level:2},{value:"7.1 Symbol Literals",id:"71-symbol-literals",level:3},{value:"7.2 Using Symbols as Keys and Identifiers",id:"72-using-symbols-as-keys-and-identifiers",level:3}];function d(e){const s={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"data-structures",children:"Data Structures"}),"\n",(0,i.jsx)(s.h2,{id:"introduction-to-data-structures-in-common-lisp",children:"Introduction to Data Structures in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Data structures are fundamental to programming, providing ways to organize and store data efficiently. Common Lisp offers a rich set of built-in data structures, each with its own strengths and weaknesses, suitable for different tasks. This tutorial will guide you through the most important data structures in Common Lisp and the forms used to manipulate them."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Key Concepts:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Data Types:"})," Understanding the basic data types in Common Lisp, such as numbers, characters, strings, symbols, and conses."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Data Structure Properties:"})," Considering factors like mutability (whether a structure can be modified), access time (how quickly elements can be retrieved), and memory usage when choosing a data structure."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Constructors and Accessors:"})," Functions for creating and accessing elements within data structures."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Table of Contents:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"1. Conses and Lists:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"cons"}),": Constructing cons cells (the building blocks of lists)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"car"}),", ",(0,i.jsx)(s.code,{children:"cdr"}),": Accessing the parts of a cons cell."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"list"}),": Creating lists."]}),"\n",(0,i.jsxs)(s.li,{children:["List manipulation functions: ",(0,i.jsx)(s.code,{children:"append"}),", ",(0,i.jsx)(s.code,{children:"reverse"}),", ",(0,i.jsx)(s.code,{children:"nth"}),", ",(0,i.jsx)(s.code,{children:"nthcdr"}),", ",(0,i.jsx)(s.code,{children:"member"}),", ",(0,i.jsx)(s.code,{children:"assoc"}),", and others."]}),"\n",(0,i.jsx)(s.li,{children:"Dotted lists."}),"\n",(0,i.jsx)(s.li,{children:"Association lists (alists)."}),"\n",(0,i.jsx)(s.li,{children:"Property lists (plists)."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"2. Arrays:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"make-array"}),": Creating arrays."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"aref"}),": Accessing array elements."]}),"\n",(0,i.jsx)(s.li,{children:"Multi-dimensional arrays."}),"\n",(0,i.jsx)(s.li,{children:"Adjustable arrays."}),"\n",(0,i.jsx)(s.li,{children:"Specialized arrays."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"3. Structures:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"defstruct"}),": Defining structures (user-defined record types)."]}),"\n",(0,i.jsx)(s.li,{children:"Structure accessors."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4. Hash Tables:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"make-hash-table"}),": Creating hash tables."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"gethash"}),", ",(0,i.jsx)(s.code,{children:"setf gethash"}),": Accessing and modifying hash table entries."]}),"\n",(0,i.jsxs)(s.li,{children:["Hash table options: ",(0,i.jsx)(s.code,{children:":test"}),", ",(0,i.jsx)(s.code,{children:":size"}),", ",(0,i.jsx)(s.code,{children:":rehash-size"}),", ",(0,i.jsx)(s.code,{children:":rehash-threshold"}),"."]}),"\n",(0,i.jsx)(s.li,{children:"Iterating over hash tables."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"5. Strings:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"String literals."}),"\n",(0,i.jsxs)(s.li,{children:["String manipulation functions: ",(0,i.jsx)(s.code,{children:"concatenate"}),", ",(0,i.jsx)(s.code,{children:"subseq"}),", ",(0,i.jsx)(s.code,{children:"string-upcase"}),", ",(0,i.jsx)(s.code,{children:"string-downcase"}),", ",(0,i.jsx)(s.code,{children:"string="}),", and others."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"6. Characters:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Character literals."}),"\n",(0,i.jsx)(s.li,{children:"Character comparison functions."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"7. Symbols:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Symbol literals."}),"\n",(0,i.jsx)(s.li,{children:"Using symbols as keys and identifiers."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This tutorial will provide clear explanations and examples for each data structure, helping you understand their usage and choose the appropriate structure for your specific programming needs. We will also cover common operations and functions for manipulating these structures."}),"\n",(0,i.jsx)(s.h2,{id:"1-conses-and-lists-in-common-lisp",children:"1. Conses and Lists in Common Lisp"}),"\n",(0,i.jsxs)(s.p,{children:["Lists are a fundamental data structure in Common Lisp. They are built from ",(0,i.jsx)(s.em,{children:"cons cells"}),", which are pairs of values. Understanding conses is crucial for understanding how lists work."]}),"\n",(0,i.jsxs)(s.h3,{id:"11-cons-constructing-cons-cells",children:["1.1 ",(0,i.jsx)(s.code,{children:"cons"}),": Constructing Cons Cells"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"cons"})," function creates a new cons cell. It takes two arguments:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The first argument becomes the ",(0,i.jsx)(s.em,{children:"car"})," (Contents of Address part of Register) of the cons cell."]}),"\n",(0,i.jsxs)(s.li,{children:["The second argument becomes the ",(0,i.jsx)(s.em,{children:"cdr"})," (Contents of Decrement part of Register) of the cons cell."]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(cons 1 2)  ; Creates a cons cell whose car is 1 and cdr is 2.\n"})}),"\n",(0,i.jsx)(s.p,{children:"This is often represented visually as a box with two compartments:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"+---+---+\n| 1 | 2 |\n+---+---+\n  car cdr\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"12-car-and-cdr-accessing-parts-of-a-cons-cell",children:["1.2 ",(0,i.jsx)(s.code,{children:"car"})," and ",(0,i.jsx)(s.code,{children:"cdr"}),": Accessing Parts of a Cons Cell"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"car"})," function returns the car of a cons cell, and the ",(0,i.jsx)(s.code,{children:"cdr"})," function returns the cdr."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((my-cons (cons 1 2)))\n  (print (car my-cons)) ; Prints 1\n  (print (cdr my-cons))) ; Prints 2\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You can chain ",(0,i.jsx)(s.code,{children:"car"})," and ",(0,i.jsx)(s.code,{children:"cdr"})," calls using abbreviations like ",(0,i.jsx)(s.code,{children:"cadr"}),", ",(0,i.jsx)(s.code,{children:"cddr"}),", ",(0,i.jsx)(s.code,{children:"caddr"}),", etc."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((my-list (cons 1 (cons 2 (cons 3 nil)))))\n  (print (cadr my-list))) ; Equivalent to (car (cdr my-list)), prints 2\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"13-list-creating-lists",children:["1.3 ",(0,i.jsx)(s.code,{children:"list"}),": Creating Lists"]}),"\n",(0,i.jsxs)(s.p,{children:["While you can create lists using nested ",(0,i.jsx)(s.code,{children:"cons"})," calls, the ",(0,i.jsx)(s.code,{children:"list"})," function provides a more convenient way."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(list 1 2 3) ; Creates a list containing 1, 2, and 3.\n"})}),"\n",(0,i.jsx)(s.p,{children:"This is equivalent to:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(cons 1 (cons 2 (cons 3 nil)))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["A list is simply a chain of cons cells where the cdr of the last cell is ",(0,i.jsx)(s.code,{children:"nil"}),". ",(0,i.jsx)(s.code,{children:"nil"})," represents the empty list."]}),"\n",(0,i.jsxs)(s.p,{children:["Visual representation of ",(0,i.jsx)(s.code,{children:"(list 1 2 3)"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"+---+---+     +---+---+     +---+---+\n| 1 | --+----\x3e| 2 | --+----\x3e| 3 |nil|\n+---+---+     +---+---+     +---+---+\n"})}),"\n",(0,i.jsx)(s.h3,{id:"14-list-manipulation-functions",children:"1.4 List Manipulation Functions"}),"\n",(0,i.jsx)(s.p,{children:"Common Lisp provides many functions for manipulating lists:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"append"})}),": Creates a ",(0,i.jsx)(s.em,{children:"new"})," list by concatenating two or more lists."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(append (list 1 2) (list 3 4)) ; Returns (1 2 3 4)\n(append (list 1 2) '(3 4))      ; Also returns (1 2 3 4)\n(append '(1 2) '(3) '(4 5 6)) ; Returns (1 2 3 4 5 6)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["It's important to remember that ",(0,i.jsx)(s.code,{children:"append"})," ",(0,i.jsx)(s.em,{children:"copies"})," the lists (except possibly the last argument). If you want to modify a list in place, you should use ",(0,i.jsx)(s.code,{children:"nconc"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"nconc"})}),": Concatenates lists by modifying the ",(0,i.jsx)(s.em,{children:"cdr"})," of the last cons cell of the first list. This is a destructive operation."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((list1 (list 1 2)) (list2 (list 3 4)))\n    (nconc list1 list2) ; Returns (1 2 3 4). list1 is now (1 2 3 4).\n    (print list1))\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"reverse"})}),": Creates a ",(0,i.jsx)(s.em,{children:"new"})," list with the elements in reverse order."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(reverse (list 1 2 3)) ; Returns (3 2 1)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"nth"})}),": Returns the nth element of a list (zero-based indexing)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(nth 1 (list 'a 'b 'c)) ; Returns B\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"nthcdr"})}),": Returns the cdr of a list n times."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(nthcdr 2 (list 'a 'b 'c 'd)) ; Returns (C D)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"member"})}),": Tests if an element is a member of a list. Returns the tail of the list starting with the element if found, otherwise ",(0,i.jsx)(s.code,{children:"nil"}),". Uses ",(0,i.jsx)(s.code,{children:"eql"})," for comparison by default."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(member 'b (list 'a 'b 'c)) ; Returns (B C)\n(member 'd (list 'a 'b 'c)) ; Returns NIL\n(member '(1 2) (list (list 1) (list 1 2))) ; Returns NIL because (list 1 2) and '(1 2) are different objects.\n(member '(1 2) (list (list 1) (list 1 2)) :test #'equal) ; Returns ((1 2)) because equal compares list contents.\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"assoc"})}),": Searches an association list (alist) for a key. Returns the cons cell whose car is ",(0,i.jsx)(s.code,{children:"eql"})," to the key, or ",(0,i.jsx)(s.code,{children:"nil"})," if not found."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(assoc 'b '((a 1) (b 2) (c 3))) ; Returns (B 2)\n(assoc 'd '((a 1) (b 2) (c 3))) ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"remove"})}),": Creates a ",(0,i.jsx)(s.em,{children:"new"})," list with all occurrences of a specified element removed."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(remove 'b (list 'a 'b 'c 'b 'd)) ; Returns (A C D)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"remove-duplicates"})}),": Creates a ",(0,i.jsx)(s.em,{children:"new"})," list with duplicate elements removed."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(remove-duplicates (list 1 2 1 3 2 4 1)) ; Returns (1 2 3 4) (order may vary)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"subst"})}),": Creates a ",(0,i.jsx)(s.em,{children:"new"})," list with all occurrences of an old element substituted with a new element."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(subst 'x 'b (list 'a 'b 'c 'b 'd)) ; Returns (A X C X D)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"15-dotted-lists",children:"1.5 Dotted Lists"}),"\n",(0,i.jsxs)(s.p,{children:["A dotted list is a cons cell where the cdr is ",(0,i.jsx)(s.em,{children:"not"})," ",(0,i.jsx)(s.code,{children:"nil"})," or another cons cell."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(cons 1 2) ; This is a dotted list: (1 . 2)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Dotted lists are less common than proper lists (lists that end in ",(0,i.jsx)(s.code,{children:"nil"}),"). They are mainly used for specific low level operations."]}),"\n",(0,i.jsx)(s.h3,{id:"16-association-lists-alists",children:"1.6 Association Lists (Alists)"}),"\n",(0,i.jsxs)(s.p,{children:["An association list (alist) is a list of cons cells, where each cons cell represents a key-value pair. ",(0,i.jsx)(s.code,{children:"assoc"})," is used to retrieve values from an alist by key."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(let ((my-alist \'((name "Alice") (age 30) (city "New York"))))\n  (print (cdr (assoc \'name my-alist))) ; Prints "Alice"\n  (print (cdr (assoc \'age my-alist))))    ; Prints 30\n'})}),"\n",(0,i.jsx)(s.h3,{id:"17-property-lists-plists",children:"1.7 Property Lists (Plists)"}),"\n",(0,i.jsxs)(s.p,{children:["A property list (plist) is a list of alternating keys and values. ",(0,i.jsx)(s.code,{children:"getf"})," is used to retrieve values from a plist by key."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(let ((my-plist \'(name "Bob" age 25 city "London")))\n  (print (getf my-plist \'name)) ; Prints "Bob"\n  (print (getf my-plist \'age)))  ; Prints 25\n'})}),"\n",(0,i.jsx)(s.p,{children:"Plists are often used for storing metadata associated with objects or other data structures. They are used in CLOS to store information about classes, for example."}),"\n",(0,i.jsx)(s.p,{children:"This section covered the fundamental data structure of lists in Common Lisp, including the underlying cons cells and important list manipulation functions. Understanding these concepts is essential for working effectively with Lisp. The next section will cover vectors."}),"\n",(0,i.jsx)(s.h2,{id:"2-arrays-in-common-lisp",children:"2. Arrays in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Arrays in Common Lisp are ordered collections of elements, similar to vectors, but they can have multiple dimensions. They provide efficient access to elements using integer indices."}),"\n",(0,i.jsxs)(s.h3,{id:"21-make-array-creating-arrays",children:["2.1 ",(0,i.jsx)(s.code,{children:"make-array"}),": Creating Arrays"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"make-array"})," function is used to create arrays. It takes several keyword arguments to control the array's properties."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":dimensions"})}),": This is a required argument. It specifies the dimensions of the array. For a one-dimensional array (a vector), it's a single integer. For multi-dimensional arrays, it's a list of integers."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":initial-element"})}),": Specifies the initial value for all elements in the array."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":element-type"})}),": Specifies the data type of the elements that the array can hold. This can improve efficiency."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":adjustable"})}),": Specifies whether the array's size can be changed after creation."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":fill-pointer"})}),": For adjustable arrays, this tracks the number of currently active elements."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating a one-dimensional array (vector) of 5 elements, initialized to 0:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-array 5 :initial-element 0)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating a two-dimensional array (a matrix) of 3 rows and 4 columns:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-array '(3 4))\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating a vector of 10 strings:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-array 10 :element-type 'string)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating a vector of 10 characters:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-array 10 :element-type 'character)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating an adjustable vector with a fill pointer:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-array 5 :adjustable t :fill-pointer 0)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.h3,{id:"22-aref-accessing-array-elements",children:["2.2 ",(0,i.jsx)(s.code,{children:"aref"}),": Accessing Array Elements"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"aref"})," function is used to access elements of an array. It takes the array and the indices as arguments."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((my-vector (make-array 5 :initial-element 0)))\n  (setf (aref my-vector 2) 10) ; Sets the element at index 2 to 10\n  (print (aref my-vector 2))    ; Prints 10\n  (print (aref my-vector 0)))    ; Prints 0\n"})}),"\n",(0,i.jsx)(s.p,{children:"For multi-dimensional arrays, you provide multiple indices:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((my-matrix (make-array '(3 4))))\n  (setf (aref my-matrix 1 2) 42) ; Sets the element at row 1, column 2 to 42\n  (print (aref my-matrix 1 2)))    ; Prints 42\n"})}),"\n",(0,i.jsx)(s.h3,{id:"23-multi-dimensional-arrays",children:"2.3 Multi-dimensional Arrays"}),"\n",(0,i.jsxs)(s.p,{children:["As shown above, you create multi-dimensional arrays by providing a list of dimensions to ",(0,i.jsx)(s.code,{children:"make-array"}),". You access elements using ",(0,i.jsx)(s.code,{children:"aref"})," with multiple indices."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((cube (make-array '(2 3 4) :initial-element 0))) ; A 2x3x4 array\n  (setf (aref cube 1 2 3) 123)\n  (print (aref cube 1 2 3))) ; Prints 123\n"})}),"\n",(0,i.jsx)(s.h3,{id:"24-adjustable-arrays",children:"2.4 Adjustable Arrays"}),"\n",(0,i.jsxs)(s.p,{children:["Adjustable arrays can be resized after they are created. You create them using the ",(0,i.jsx)(s.code,{children:":adjustable t"})," keyword argument to ",(0,i.jsx)(s.code,{children:"make-array"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((my-adjustable-vector (make-array 3 :adjustable t :fill-pointer 3 :initial-contents '(1 2 3))))\n    (print my-adjustable-vector)\n    (array-total-size my-adjustable-vector) ; the total size of the array\n    (array-dimensions my-adjustable-vector) ; the dimensions of the array\n    (array-has-fill-pointer-p my-adjustable-vector) ; t because it has a fill pointer\n    (fill-pointer my-adjustable-vector) ; the fill pointer\n    (vector-push-extend 4 my-adjustable-vector) ; adds element to the end and extends the array if needed\n    (print my-adjustable-vector)\n    (fill-pointer my-adjustable-vector) ; the fill pointer has been increased\n    (vector-push-extend 5 my-adjustable-vector)\n    (print my-adjustable-vector)\n    (array-total-size my-adjustable-vector) ; the total size has been increased\n    (fill-pointer my-adjustable-vector)\n    (vector-pop my-adjustable-vector) ; removes the last element and decreases the fill pointer\n    (print my-adjustable-vector)\n    (fill-pointer my-adjustable-vector)\n    (vector-push 6 my-adjustable-vector) ; adds the element at the index of the fill pointer and increases the fill pointer by one\n    (print my-adjustable-vector)\n    (fill-pointer my-adjustable-vector)\n)\n"})}),"\n",(0,i.jsx)(s.p,{children:"Key functions for working with adjustable arrays:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"array-total-size"})}),": Returns the total number of elements the array ",(0,i.jsx)(s.em,{children:"can"})," hold."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"array-dimensions"})}),": Returns a list of the dimensions of the array."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"array-has-fill-pointer-p"})}),": Checks if the array has a fill pointer."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"fill-pointer"})}),": Returns or sets the fill pointer of an adjustable array."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"vector-push-extend"})}),": Adds an element to the end of an adjustable vector, extending the vector if necessary."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"vector-pop"})}),": Removes the last element of an adjustable vector and decreases the fill pointer."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"vector-push"})}),": Adds an element at the index of the fill pointer and increases the fill pointer by one."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"25-specialized-arrays",children:"2.5 Specialized Arrays"}),"\n",(0,i.jsxs)(s.p,{children:["Specialized arrays can hold elements of a specific data type. This can improve performance and reduce memory usage. You specify the element type using the ",(0,i.jsx)(s.code,{children:":element-type"})," keyword argument to ",(0,i.jsx)(s.code,{children:"make-array"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-array 10 :element-type 'bit)       ; An array of bits\n(make-array 20 :element-type 'character) ; An array of characters\n(make-array '(2 2) :element-type 'single-float) ; A 2x2 array of single-precision floating-point numbers\n"})}),"\n",(0,i.jsx)(s.p,{children:"Commonly used element types include:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"bit"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"character"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"base-char"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"single-float"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"double-float"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"integer"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"t"})," (the most general type, can hold any Lisp object)"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Using specialized arrays can be more efficient than using general arrays (with ",(0,i.jsx)(s.code,{children:":element-type 't"}),") when you know the type of data you will be storing."]}),"\n",(0,i.jsx)(s.p,{children:"This section covered the basics of arrays in Common Lisp, including how to create them, access their elements, and work with multi-dimensional, adjustable, and specialized arrays. Arrays are a powerful and efficient data structure for many programming tasks. Remember that vectors are one-dimensional arrays and therefore all the functions that work on arrays also work on vectors. However there are some functions that only work on vectors, like the ones that use the fill pointer."}),"\n",(0,i.jsx)(s.h2,{id:"3-structures-in-common-lisp",children:"3. Structures in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Structures in Common Lisp provide a way to define user-defined record types, similar to structs in C or records in Pascal. They allow you to group related data into a single named entity with named fields (slots)."}),"\n",(0,i.jsxs)(s.h3,{id:"31-defstruct-defining-structures",children:["3.1 ",(0,i.jsx)(s.code,{children:"defstruct"}),": Defining Structures"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"defstruct"})," macro is used to define structures. Its basic syntax is:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defstruct structure-name\n  slot-name1\n  slot-name2\n  ...)\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"structure-name"})}),": A symbol that names the structure."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.code,{children:"slot-name1"}),", ",(0,i.jsx)(s.code,{children:"slot-name2"}),", ..."]}),": Symbols that name the slots (fields) of the structure."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defstruct point\n  x\n  y)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["This defines a structure named ",(0,i.jsx)(s.code,{children:"point"})," with two slots: ",(0,i.jsx)(s.code,{children:"x"})," and ",(0,i.jsx)(s.code,{children:"y"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"defstruct"})," automatically generates several functions:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Constructor:"})," ",(0,i.jsx)(s.code,{children:"make-structure-name"})," (e.g., ",(0,i.jsx)(s.code,{children:"make-point"}),"). This function creates instances of the structure."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Accessors:"})," ",(0,i.jsx)(s.code,{children:"structure-name-slot-name"})," (e.g., ",(0,i.jsx)(s.code,{children:"point-x"}),", ",(0,i.jsx)(s.code,{children:"point-y"}),"). These functions access the values of the slots."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"32-structure-accessors",children:"3.2 Structure Accessors"}),"\n",(0,i.jsxs)(s.p,{children:["Let's use the ",(0,i.jsx)(s.code,{children:"point"})," structure we defined earlier:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defstruct point\n  x\n  y)\n\n(let ((p (make-point :x 10 :y 20))) ; Create a point instance\n  (print (point-x p)) ; Access the x slot (prints 10)\n  (print (point-y p)) ; Access the y slot (prints 20)\n\n  (setf (point-x p) 30) ; Modify the x slot\n  (print (point-x p))) ; Prints 30\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"make-point"})," takes keyword arguments corresponding to the slot names to initialize the slots. The accessors ",(0,i.jsx)(s.code,{children:"point-x"})," and ",(0,i.jsx)(s.code,{children:"point-y"})," are used to read and write the slot values. ",(0,i.jsx)(s.code,{children:"setf"})," is used to set the value of a slot using the accessor function."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsxs)(s.strong,{children:["More ",(0,i.jsx)(s.code,{children:"defstruct"})," Options:"]})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"defstruct"})," provides several options to customize the behavior of structures:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":include"})}),": Allows a structure to inherit slots from another structure."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defstruct (3d-point (:include point)) ; 3d-point inherits from point\n  z)\n\n(let ((p3 (make-3d-point :x 10 :y 20 :z 30)))\n  (print (point-x p3)) ; Access inherited slot (prints 10)\n  (print (3d-point-z p3))) ; Access z slot (prints 30)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":conc-name"})}),": Changes the prefix of the accessor functions."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defstruct (my-point (:conc-name mp-)) ; Accessors will be mp-x, mp-y\n  x\n  y)\n\n(let ((p (make-my-point :x 5 :y 7)))\n  (print (mp-x p))) ; Prints 5\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":type"})}),": Specifies the underlying representation of the structure. This can be used for efficiency or to interact with other systems. Common types include ",(0,i.jsx)(s.code,{children:":list"}),", ",(0,i.jsx)(s.code,{children:":vector"}),", and others. If no type is specified, the structure is implemented as a record."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defstruct (vector-point (:type vector))\n  x\n  y)\n(let ((vp (make-vector-point :x 10 :y 20)))\n    (print vp) ; prints #((10 20) VECTOR-POINT)\n    (print (vector-point-x vp)) ; prints 10\n)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":named"})}),": Creates a predicate function ",(0,i.jsx)(s.code,{children:"structure-name-p"})," that tests if an object is an instance of the structure."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defstruct (person (:named person-p))\n  name\n  age)\n\n(let ((alice (make-person :name "Alice" :age 30))\n      (not-a-person \'(a b c)))\n  (print (person-p alice))      ; Prints T\n  (print (person-p not-a-person))) ; Prints NIL\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":print-function"})}),": Specifies a function that is used to print the structure."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defstruct (colored-point (:print-function print-colored-point))\n    x\n    y\n    color)\n(defun print-colored-point (point stream depth)\n    (declare (ignore depth))\n    (format stream "#<Colored Point (~a,~a) ~a>" (colored-point-x point) (colored-point-y point) (colored-point-color point)))\n(let ((cp (make-colored-point :x 10 :y 20 :color "red")))\n    (print cp)) ; prints #<Colored Point (10,20) red>\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Structures are a convenient way to create simple data aggregates in Common Lisp. They are less flexible than CLOS classes (which we covered earlier), but they are often simpler to use for basic data structures. If you need more advanced object-oriented features like inheritance, method dispatch, or method combination, you should use CLOS classes."}),"\n",(0,i.jsx)(s.h2,{id:"4-hash-tables-in-common-lisp",children:"4. Hash Tables in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Hash tables are a powerful data structure in Common Lisp for storing key-value pairs. They provide efficient access to values based on their associated keys."}),"\n",(0,i.jsxs)(s.h3,{id:"41-make-hash-table-creating-hash-tables",children:["4.1 ",(0,i.jsx)(s.code,{children:"make-hash-table"}),": Creating Hash Tables"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"make-hash-table"})," function creates a new hash table. It takes several keyword arguments to customize the hash table's behavior:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":test"})}),": Specifies the equality test used to compare keys. The default is ",(0,i.jsx)(s.code,{children:"eql"}),". Common options include:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"eql"}),": Tests for object identity (the default)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"equal"}),": Tests for structural equality (compares the contents of objects)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"eq"}),": Tests for object identity (stricter than ",(0,i.jsx)(s.code,{children:"eql"})," for numbers and characters)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"equalp"}),": Tests for structural equality, ignoring case for strings and some other minor differences."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":size"})}),": An initial estimate of the number of entries the hash table will hold. This is a hint to the implementation and doesn't limit the hash table's capacity."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":rehash-size"})}),": Controls how much the hash table's size is increased when it needs to be rehashed (resized). It can be a positive integer (the number of new buckets) or a floating-point number greater than 1 (a multiplicative factor). The default is implementation-dependent."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:":rehash-threshold"})}),": A floating-point number between 0 and 1 that determines when the hash table is rehashed. When the ratio of the number of entries to the size of the hash table exceeds this threshold, the hash table is rehashed. The default is implementation-dependent."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:["Creating a hash table using the default ",(0,i.jsx)(s.code,{children:"eql"})," test:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-hash-table)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:["Creating a hash table that uses ",(0,i.jsx)(s.code,{children:"equal"})," for key comparison (useful for comparing strings):"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-hash-table :test #'equal)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating a hash table with an initial size of 100:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-hash-table :size 100)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"Creating a hash table with a rehash-size of 1.5 (increase size by 50% on rehash):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(make-hash-table :rehash-size 1.5)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.h3,{id:"42-gethash-and-setf-gethash-accessing-and-modifying-hash-table-entries",children:["4.2 ",(0,i.jsx)(s.code,{children:"gethash"})," and ",(0,i.jsx)(s.code,{children:"setf gethash"}),": Accessing and Modifying Hash Table Entries"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"gethash"})," function retrieves the value associated with a key in a hash table. It takes the key and the hash table as arguments. It returns two values: the value associated with the key, and a boolean value indicating whether the key was found in the hash table."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(let ((my-hash (make-hash-table)))\n  (setf (gethash \'a my-hash) 1)\n  (setf (gethash \'b my-hash) 2)\n\n  (multiple-value-bind (value present) (gethash \'a my-hash)\n    (format t "Value of a: ~a, Present: ~a~%" value present)) ; Prints "Value of a: 1, Present: T"\n\n  (multiple-value-bind (value present) (gethash \'c my-hash)\n    (format t "Value of c: ~a, Present: ~a~%" value present)) ; Prints "Value of c: NIL, Present: NIL"\n)\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"setf gethash"})," is used to associate a value with a key in a hash table. It takes the value, the key, and the hash table as arguments."]}),"\n",(0,i.jsxs)(s.p,{children:["If the key is not found ",(0,i.jsx)(s.code,{children:"gethash"})," returns ",(0,i.jsx)(s.code,{children:"nil"})," as the value and ",(0,i.jsx)(s.code,{children:"nil"})," as the present indicator. You can provide a default value as a third argument to ",(0,i.jsx)(s.code,{children:"gethash"})," that will be returned if the key is not found:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((my-hash (make-hash-table)))\n  (gethash 'd my-hash 42)) ; returns 42, nil\n"})}),"\n",(0,i.jsx)(s.h3,{id:"43-hash-table-options",children:"4.3 Hash Table Options"}),"\n",(0,i.jsxs)(s.p,{children:["We've already covered the main hash table options in the ",(0,i.jsx)(s.code,{children:"make-hash-table"})," section. Here's a quick recap:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:":test"}),": Equality test for keys (",(0,i.jsx)(s.code,{children:"eql"}),", ",(0,i.jsx)(s.code,{children:"equal"}),", ",(0,i.jsx)(s.code,{children:"eq"}),", ",(0,i.jsx)(s.code,{children:"equalp"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:":size"}),": Initial size hint."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:":rehash-size"}),": How much to increase the size when rehashing."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:":rehash-threshold"}),": When to rehash (ratio of entries to size)."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Choosing the appropriate ",(0,i.jsx)(s.code,{children:":test"})," is important. If you are using strings as keys, you should use ",(0,i.jsx)(s.code,{children:":test #'equal"})," or ",(0,i.jsx)(s.code,{children:":test #'equalp"}),". If you are using symbols or numbers, ",(0,i.jsx)(s.code,{children:"eql"})," is usually sufficient."]}),"\n",(0,i.jsx)(s.h3,{id:"44-iterating-over-hash-tables",children:"4.4 Iterating over Hash Tables"}),"\n",(0,i.jsxs)(s.p,{children:["You can iterate over the entries in a hash table using the ",(0,i.jsx)(s.code,{children:"maphash"})," function. It takes a function and the hash table as arguments. The function is called for each key-value pair in the hash table."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(let ((my-hash (make-hash-table :test #\'equal)))\n  (setf (gethash "apple" my-hash) 1)\n  (setf (gethash "banana" my-hash) 2)\n  (setf (gethash "cherry" my-hash) 3)\n\n  (maphash #\'(lambda (key value)\n               (format t "Key: ~a, Value: ~a~%" key value))\n           my-hash))\n'})}),"\n",(0,i.jsx)(s.p,{children:"The output might be in a different order depending on the implementation but will contain:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"Key: cherry, Value: 3\nKey: banana, Value: 2\nKey: apple, Value: 1\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"maphash"})," is primarily used for side effects (like printing), as it returns ",(0,i.jsx)(s.code,{children:"nil"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Hash tables are a very efficient data structure for lookups, insertions, and deletions when you need to associate values with keys. They are widely used in Common Lisp programming."}),"\n",(0,i.jsx)(s.h2,{id:"5-strings-in-common-lisp",children:"5. Strings in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Strings in Common Lisp are sequences of characters. They are represented as arrays of characters and are mutable (their contents can be changed)."}),"\n",(0,i.jsx)(s.h3,{id:"51-string-literals",children:"5.1 String Literals"}),"\n",(0,i.jsx)(s.p,{children:"String literals are enclosed in double quotes:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'"This is a string."\n"Another string with \\"escaped quotes\\"."\n"" ; The empty string\n'})}),"\n",(0,i.jsx)(s.h3,{id:"52-string-manipulation-functions",children:"5.2 String Manipulation Functions"}),"\n",(0,i.jsx)(s.p,{children:"Common Lisp provides a rich set of functions for manipulating strings:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"concatenate"})}),": Creates a new string by concatenating two or more strings (or sequences)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(concatenate \'string "Hello, " "world!") ; Returns "Hello, world!"\n(concatenate \'string "The number is " 42) ; Type error, 42 is not a sequence. Use format instead for mixed data.\n'})}),"\n",(0,i.jsxs)(s.p,{children:["For mixed data types use ",(0,i.jsx)(s.code,{children:"format"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(format nil "The number is ~a" 42) ; Returns "The number is 42"\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"subseq"})}),": Extracts a subsequence (substring) from a string."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(subseq "Hello, world!" 7)    ; Returns "world!" (from index 7 to the end)\n(subseq "Hello, world!" 0 5)  ; Returns "Hello" (from index 0 up to, but not including, index 5)\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"string-upcase"})}),": Creates a new string with all characters converted to uppercase."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(string-upcase "hello") ; Returns "HELLO"\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"string-downcase"})}),": Creates a new string with all characters converted to lowercase."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(string-downcase "HELLO") ; Returns "hello"\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"string="})}),": Compares two strings for equality (case-sensitive)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(string= "hello" "hello") ; Returns T\n(string= "hello" "Hello") ; Returns NIL\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"string-equal"})}),": Compares two strings for equality (case-insensitive)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(string-equal "hello" "Hello") ; Returns T\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.code,{children:"string<"}),", ",(0,i.jsx)(s.code,{children:"string>"}),", ",(0,i.jsx)(s.code,{children:"string<="}),", ",(0,i.jsx)(s.code,{children:"string>="})]}),": Perform lexicographical comparisons (case-sensitive). There are also case-insensitive versions: ",(0,i.jsx)(s.code,{children:"string-lessp"}),", ",(0,i.jsx)(s.code,{children:"string-greaterp"}),", ",(0,i.jsx)(s.code,{children:"string-not-greaterp"}),", ",(0,i.jsx)(s.code,{children:"string-not-lessp"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(string< "apple" "banana") ; Returns T\n(string> "zebra" "apple") ; Returns T\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"length"})}),": Returns the length of a string."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(length "Common Lisp") ; Returns 11\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"char"})}),": Accesses a character at a specific index in a string (zero-based)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(char "Common Lisp" 7) ; Returns #\\L\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"string"})}),": Converts various objects (like symbols or characters) to strings."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(string \'symbol) ; Returns "SYMBOL"\n(string #\\a)    ; Returns "a"\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"6-characters-in-common-lisp",children:"6. Characters in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Characters in Common Lisp represent individual textual characters."}),"\n",(0,i.jsx)(s.h3,{id:"61-character-literals",children:"6.1 Character Literals"}),"\n",(0,i.jsxs)(s.p,{children:["Character literals are prefixed with ",(0,i.jsx)(s.code,{children:"#\\"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"#\\a       ; Lowercase 'a'\n#\\A       ; Uppercase 'A'\n#\\Space   ; The space character\n#\\Newline ; The newline character\n#\\\\       ; The backslash character\n"})}),"\n",(0,i.jsx)(s.h3,{id:"62-character-comparison-functions",children:"6.2 Character Comparison Functions"}),"\n",(0,i.jsx)(s.p,{children:"Common Lisp provides functions for comparing characters:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"char="})}),": Compares two characters for equality (case-sensitive)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(char= #\\a #\\a) ; Returns T\n(char= #\\a #\\A) ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"char-equal"})}),": Compares two characters for equality (case-insensitive)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(char-equal #\\a #\\A) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.code,{children:"char<"}),", ",(0,i.jsx)(s.code,{children:"char>"}),", ",(0,i.jsx)(s.code,{children:"char<="}),", ",(0,i.jsx)(s.code,{children:"char>="})]}),": Perform lexicographical comparisons (case-sensitive). There are also case-insensitive versions: ",(0,i.jsx)(s.code,{children:"char-lessp"}),", ",(0,i.jsx)(s.code,{children:"char-greaterp"}),", ",(0,i.jsx)(s.code,{children:"char-not-greaterp"}),", ",(0,i.jsx)(s.code,{children:"char-not-lessp"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(char< #\\a #\\b) ; Returns T\n(char> #\\z #\\a) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"char-code"})}),": Returns the numeric character code of a character (typically its ASCII or Unicode value)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(char-code #\\a) ; Returns 97 (in most implementations using ASCII or UTF-8)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"code-char"})}),": Returns the character corresponding to a given numeric character code."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(code-char 97) ; Returns #\\a (in most implementations using ASCII or UTF-8)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This section covered strings and characters, which are fundamental data types for working with text in Common Lisp. Understanding string manipulation functions and character comparison is essential for many programming tasks."}),"\n",(0,i.jsx)(s.h2,{id:"7-symbols-in-common-lisp",children:"7. Symbols in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"Symbols are a unique data type in Lisp, distinct from strings, characters, or numbers. They are atomic data objects with a name, a value (which can be anything), a function definition (which can be a function), and a property list (which can store arbitrary properties). This tutorial focuses on their basic use as literals, keys, and identifiers."}),"\n",(0,i.jsx)(s.h3,{id:"71-symbol-literals",children:"7.1 Symbol Literals"}),"\n",(0,i.jsxs)(s.p,{children:["Symbol literals are typically written as a sequence of alphanumeric characters and certain other characters (like ",(0,i.jsx)(s.code,{children:"-"}),", ",(0,i.jsx)(s.code,{children:"+"}),", ",(0,i.jsx)(s.code,{children:"*"}),", ",(0,i.jsx)(s.code,{children:"/"}),", ",(0,i.jsx)(s.code,{children:"<"}),", ",(0,i.jsx)(s.code,{children:">"}),", ",(0,i.jsx)(s.code,{children:"="}),", etc.), without double quotes. By default, symbols are read as uppercase."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"foo\nBAR\nmy-variable\n+addition\n*multiplication\n<less-than\n"})}),"\n",(0,i.jsxs)(s.p,{children:["If you need to include lowercase letters or other special characters in a symbol's name, you can escape them with a backslash ",(0,i.jsx)(s.code,{children:"\\"})," or enclose the entire symbol in vertical bars ",(0,i.jsx)(s.code,{children:"|"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"|MixedCaseSymbol|\n\\|Special Characters!\\|\n"})}),"\n",(0,i.jsxs)(s.p,{children:["When the Lisp reader encounters an unescaped symbol, it ",(0,i.jsx)(s.em,{children:"interns"})," it, meaning it checks if a symbol with that name already exists in the current ",(0,i.jsx)(s.em,{children:"package"}),". If it does, it returns the existing symbol; otherwise, it creates a new one. This ensures that symbols with the same name are ",(0,i.jsx)(s.code,{children:"eq"})," to each other (i.e., they are the same object in memory)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(eq 'foo 'foo) ; Returns T\n(eq 'foo 'FOO) ; Returns T (symbols are read as uppercase by default)\n(eq |Foo| |foo|) ; Returns NIL (because case matters inside vertical bars)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The single quote ",(0,i.jsx)(s.code,{children:"'"})," is a shorthand for ",(0,i.jsx)(s.code,{children:"(quote ...)"}),". ",(0,i.jsx)(s.code,{children:"(quote foo)"})," evaluates to the symbol ",(0,i.jsx)(s.code,{children:"foo"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"72-using-symbols-as-keys-and-identifiers",children:"7.2 Using Symbols as Keys and Identifiers"}),"\n",(0,i.jsx)(s.p,{children:"Symbols are commonly used in two main ways:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"As keys in data structures:"})," Symbols are often used as keys in association lists (alists), property lists (plists), and hash tables. Because of the interning process, comparing symbols for equality using ",(0,i.jsx)(s.code,{children:"eq"})," is very fast."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(let ((my-plist \'(name "Alice" age 30 city "New York")))\n  (getf my-plist \'name)) ; Returns "Alice"\n\n(let ((my-alist \'((name . "Bob") (age . 25))))\n    (cdr (assoc \'name my-alist))) ; returns "Bob"\n\n    (let ((my-hash (make-hash-table)))\n        (setf (gethash \'country my-hash) "Israel")\n        (gethash \'country my-hash)) ; returns "Israel", T\n)\n'})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"As identifiers (variable and function names):"})," Symbols are used to name variables, functions, classes, and other program entities."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defvar *my-global-variable* 10) ; *...* is a naming convention for global variables\n(defun my-function (x) (+ x 5))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["In this context, the symbol represents the entity it names. When you refer to ",(0,i.jsx)(s.code,{children:"*my-global-variable*"})," or ",(0,i.jsx)(s.code,{children:"my-function"})," in your code, the Lisp system looks up the value or function definition associated with that symbol."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Packages:"})}),"\n",(0,i.jsxs)(s.p,{children:["Symbols are organized into ",(0,i.jsx)(s.em,{children:"packages"}),", which are namespaces that help prevent name collisions. By default, when you type a symbol at the top level of the Lisp REPL, it is interned in the ",(0,i.jsx)(s.code,{children:"COMMON-LISP-USER"})," package (often abbreviated as ",(0,i.jsx)(s.code,{children:"USER"}),")."]}),"\n",(0,i.jsxs)(s.p,{children:["To refer to a symbol in a different package, you use the package prefix ",(0,i.jsx)(s.code,{children:"package-name::symbol-name"})," or ",(0,i.jsx)(s.code,{children:"package-name:symbol-name"}),". The double colon ",(0,i.jsx)(s.code,{children:"::"})," means the symbol is ",(0,i.jsx)(s.em,{children:"external"})," to the package and therefore accessible from other packages. The single colon ",(0,i.jsx)(s.code,{children:":"})," means the symbol is ",(0,i.jsx)(s.em,{children:"internal"})," to the package and by default not accessible from other packages."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"CL:list ; Refers to the list function in the CL (COMMON-LISP) package\nKEYWORD:test ; Refers to the test keyword in the KEYWORD package.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Understanding how symbols are interned and how packages work is essential for writing larger Lisp programs and avoiding name conflicts. For most simple programs you will use the ",(0,i.jsx)(s.code,{children:"USER"})," package and don't need to worry about packages."]}),"\n",(0,i.jsx)(s.p,{children:"This section covered the basics of symbols in Common Lisp, their use as literals, keys, and identifiers, and the concept of packages. Symbols are a fundamental part of the Lisp language and play a crucial role in its flexibility and expressiveness."})]})}function h(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>l,a:()=>a});var i=n(7294);const r={},t=i.createContext(r);function a(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);