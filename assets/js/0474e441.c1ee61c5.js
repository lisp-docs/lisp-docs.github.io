"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[9226],{2057:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var s=i(5893),r=i(1151);const t={sidebar_position:3},o="Common Lisp Implementations",l={id:"tutorial/using-cl-implementation",title:"Common Lisp Implementations",description:"Quickstart",source:"@site/docs/tutorial/using-cl-implementation.md",sourceDirName:"tutorial",slug:"/tutorial/using-cl-implementation",permalink:"/docs/tutorial/using-cl-implementation",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/using-cl-implementation.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Motivation",permalink:"/docs/tutorial/motivation"},next:{title:"An Informal Introduction to Common Lisp",permalink:"/docs/tutorial/informal-introduction-to-lisp"}},a={},c=[{value:"Quickstart",id:"quickstart",level:2},{value:"Introduction to Common Lisp Implementations",id:"introduction-to-common-lisp-implementations",level:2},{value:"1. Popular Common Lisp Implementations",id:"1-popular-common-lisp-implementations",level:2},{value:"1.1 SBCL (Steel Bank Common Lisp)",id:"11-sbcl-steel-bank-common-lisp",level:3},{value:"1.2 CCL (Clozure Common Lisp)",id:"12-ccl-clozure-common-lisp",level:3},{value:"1.3 ECL (Embeddable Common Lisp)",id:"13-ecl-embeddable-common-lisp",level:3},{value:"1.4 ABCL (Armed Bear Common Lisp)",id:"14-abcl-armed-bear-common-lisp",level:3},{value:"1.5 LispWorks",id:"15-lispworks",level:3},{value:"2. Choosing a Common Lisp Implementation",id:"2-choosing-a-common-lisp-implementation",level:2},{value:"2.1 Performance Considerations",id:"21-performance-considerations",level:3},{value:"2.2 Platform Compatibility",id:"22-platform-compatibility",level:3},{value:"2.3 Available Libraries and Tools",id:"23-available-libraries-and-tools",level:3},{value:"2.4 Licensing and Support",id:"24-licensing-and-support",level:3},{value:"3. Package Managers in Common Lisp: Quicklisp",id:"3-package-managers-in-common-lisp-quicklisp",level:2},{value:"3.1 Quicklisp: A Widely Used Package Manager",id:"31-quicklisp-a-widely-used-package-manager",level:3},{value:"3.2 Using Quicklisp to Install and Manage Libraries",id:"32-using-quicklisp-to-install-and-manage-libraries",level:3},{value:"3.3 Qlot",id:"33-qlot",level:3},{value:"3.4 OCICL",id:"34-ocicl",level:3},{value:"4. Build Tools: ASDF",id:"4-build-tools-asdf",level:2},{value:"4.1 ASDF (Another System Definition Facility): A Standard Build System",id:"41-asdf-another-system-definition-facility-a-standard-build-system",level:3},{value:"4.2 Defining Systems and Dependencies with ASDF",id:"42-defining-systems-and-dependencies-with-asdf",level:3},{value:"4.3 Building and Loading Lisp Projects",id:"43-building-and-loading-lisp-projects",level:3},{value:"5. Foreign Function Interface (FFI) in Common Lisp",id:"5-foreign-function-interface-ffi-in-common-lisp",level:2},{value:"5.1 Interacting with C code using CFFI",id:"51-interacting-with-c-code-using-cffi",level:3},{value:"5.2 Calling C Functions from Lisp",id:"52-calling-c-functions-from-lisp",level:3},{value:"5.3 Using Lisp Data Structures in C",id:"53-using-lisp-data-structures-in-c",level:3},{value:"6. Development Environments for Common Lisp",id:"6-development-environments-for-common-lisp",level:2},{value:"6.1 SLIME (Superior Lisp Interaction Mode for Emacs) (and Sly)",id:"61-slime-superior-lisp-interaction-mode-for-emacs-and-sly",level:3},{value:"6.2 Other Lisp IDEs",id:"62-other-lisp-ides",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"common-lisp-implementations",children:"Common Lisp Implementations"}),"\n",(0,s.jsx)(n.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,s.jsxs)(n.p,{children:["If you are looking to just hit the ground running and learn Common Lisp I recommend just ",(0,s.jsx)(n.a,{href:"https://www.sbcl.org/getting.html",children:"installing SBCL"})," and ",(0,s.jsx)(n.a,{href:"/docs/tutorial/informal-introduction-to-lisp",children:"going ahead"})," with the tutorial."]}),"\n",(0,s.jsx)(n.p,{children:"If you are on a linux/debian type system, you can run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt-get install sbcl\n"})}),"\n",(0,s.jsx)(n.p,{children:"For macOS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"brew install sbcl\n"})}),"\n",(0,s.jsx)(n.p,{children:"For Arch Linux"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo pacman -S sbcl\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For other systems, Windows, or to just get the latest version instead of the one in your package manager, you can ",(0,s.jsx)(n.a,{href:"https://www.sbcl.org/platform-table.html",children:"download a binary here"})," (click on the green cell in the table corresponding to your system, they are actually links). Then follow these instructions: ",(0,s.jsx)(n.a,{href:"https://www.sbcl.org/getting.html",children:"SBCL's Getting Started"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["I recommend now to ",(0,s.jsx)(n.a,{href:"/docs/tutorial/informal-introduction-to-lisp",children:"continue"})," with the tutorial. Otherwise, for a more detailed explanation, read ahead."]}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-common-lisp-implementations",children:"Introduction to Common Lisp Implementations"}),"\n",(0,s.jsxs)(n.p,{children:["Common Lisp is defined by a standard, but it's the ",(0,s.jsx)(n.em,{children:"implementations"})," that bring that standard to life. A Common Lisp implementation is a software system that provides a Lisp environment, including a compiler or interpreter, a runtime system, and often additional tools like debuggers, profilers, and development environments. Choosing the right implementation is important, as they can differ in performance, features, supported platforms, and available libraries."]}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will introduce you to some of the most popular and actively maintained Common Lisp implementations, discuss their strengths and weaknesses, and cover associated concepts like package managers and build tools."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implementation:"})," A concrete realization of the Common Lisp standard."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compiler/Interpreter:"})," The component that translates Lisp code into executable instructions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runtime System:"})," The environment that supports the execution of Lisp programs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Foreign Function Interface (FFI):"})," A mechanism for interacting with code written in other languages (like C)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Package Managers:"})," Tools for managing Lisp libraries and dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Build Tools:"})," Tools for building and distributing Lisp applications."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Table of Contents:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Popular Common Lisp Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SBCL (Steel Bank Common Lisp):"})," A high-performance, open-source compiler."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CCL (Clozure Common Lisp):"})," A fast, native compiler with good support for macOS and other platforms."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ECL (Embeddable Common Lisp):"})," A lightweight implementation suitable for embedding in other applications."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ABCL (Armed Bear Common Lisp):"})," A Java-based implementation that runs on the Java Virtual Machine (JVM)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LispWorks:"})," A commercial implementation with a comprehensive IDE and advanced features."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Choosing an Implementation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Performance considerations."}),"\n",(0,s.jsx)(n.li,{children:"Platform compatibility."}),"\n",(0,s.jsx)(n.li,{children:"Available libraries and tools."}),"\n",(0,s.jsx)(n.li,{children:"Licensing and support."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Package Managers:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Quicklisp:"})," A widely used package manager for Common Lisp."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qlot"}),": for project based environments. It uses quicklisp as well as git, http, and other ways of fetching dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ocicl"}),": new project aiming to replace quicklisp, it's also for project based environments."]}),"\n",(0,s.jsx)(n.li,{children:"Using Quicklisp to install and manage libraries."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. Build Tools:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ASDF (Another System Definition Facility):"})," A standard build system for Common Lisp."]}),"\n",(0,s.jsx)(n.li,{children:"Defining systems and dependencies with ASDF."}),"\n",(0,s.jsx)(n.li,{children:"Building and loading Lisp projects."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"5. Foreign Function Interface (FFI):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Interacting with C code using CFFI."}),"\n",(0,s.jsx)(n.li,{children:"Calling C functions from Lisp."}),"\n",(0,s.jsx)(n.li,{children:"Using Lisp data structures in C."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"6. Development Environments:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SLIME (Superior Lisp Interaction Mode for Emacs) (Sly is a fork of SLIME, so whatever applies to SLIME applies to sly as well)."}),"\n",(0,s.jsx)(n.li,{children:"Other Lisp IDEs."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This tutorial aims to provide a practical overview of Common Lisp implementations and the ecosystem surrounding them. By the end, you should be able to choose an implementation suitable for your needs, manage libraries, and build Lisp projects effectively."}),"\n",(0,s.jsx)(n.h2,{id:"1-popular-common-lisp-implementations",children:"1. Popular Common Lisp Implementations"}),"\n",(0,s.jsx)(n.p,{children:"This section introduces some of the most widely used and actively developed Common Lisp implementations."}),"\n",(0,s.jsx)(n.h3,{id:"11-sbcl-steel-bank-common-lisp",children:"1.1 SBCL (Steel Bank Common Lisp)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Primarily a compiler, but also includes an interpreter."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"License:"})," Open source (primarily a combination of public domain and a BSD-style license)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Platforms:"})," Runs on a wide range of platforms, including Linux, macOS, Windows, and various Unix-like systems, on x86, x86-64, ARM, PowerPC, and other architectures."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Known for its excellent performance, often considered one of the fastest Common Lisp implementations. It has a robust compiler that generates efficient native code. It also has a very active development community."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Weaknesses:"})," The focus on performance can sometimes make it less forgiving of non-standard code or certain edge cases."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases:"})," General-purpose Lisp development, performance-critical applications, systems programming."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"SBCL is a great choice for users who prioritize performance and want a robust, open-source implementation."}),"\n",(0,s.jsx)(n.h3,{id:"12-ccl-clozure-common-lisp",children:"1.2 CCL (Clozure Common Lisp)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Native compiler."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"License:"})," Open source (LLGPL)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Platforms:"})," Excellent support for macOS, also runs on Linux, Windows, and other platforms. Supports x86, x86-64, PowerPC, and ARM architectures."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Very fast and generates high-quality native code. It has a long history and a strong focus on stability. It is known for its excellent support on macOS."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Weaknesses:"})," The development community is smaller compared to SBCL."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases:"})," macOS development, general-purpose Lisp development, applications requiring good performance."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"CCL is a solid choice, particularly for macOS users."}),"\n",(0,s.jsx)(n.h3,{id:"13-ecl-embeddable-common-lisp",children:"1.3 ECL (Embeddable Common Lisp)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Bytecode compiler and interpreter."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"License:"})," Open source (LGPL)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Platforms:"})," Highly portable, runs on many platforms, including embedded systems."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Designed to be easily embedded in other applications written in C or other languages. It has a small footprint and is very portable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Weaknesses:"})," Performance is generally not as high as SBCL or CCL, as it uses a bytecode interpreter."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases:"})," Embedding Lisp functionality in other applications, scripting, small footprint systems."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ECL is an excellent choice when you need to integrate Lisp functionality into a larger system written in another language."}),"\n",(0,s.jsx)(n.h3,{id:"14-abcl-armed-bear-common-lisp",children:"1.4 ABCL (Armed Bear Common Lisp)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Compiler that targets the Java Virtual Machine (JVM)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"License:"})," Open source (MIT)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Platforms:"})," Runs on any platform with a JVM."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Excellent integration with Java libraries and the Java ecosystem. This allows you to leverage existing Java code and tools from Lisp."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Weaknesses:"})," Performance is dependent on the JVM and is typically not as high as native compilers like SBCL or CCL."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases:"})," Integrating Lisp with Java applications, using Java libraries from Lisp, cross-platform development where JVM portability is important."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ABCL is a good choice if you need to work closely with Java or require JVM portability."}),"\n",(0,s.jsx)(n.h3,{id:"15-lispworks",children:"1.5 LispWorks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Commercial implementation with both a compiler and an interpreter."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"License:"})," Commercial."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Platforms:"})," Supports macOS, Windows, Linux, and other platforms."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Provides a comprehensive integrated development environment (IDE) with advanced features like a visual debugger, profiler, and GUI builder. It also offers excellent support and commercial-grade stability."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Weaknesses:"})," It is a commercial product, so it requires a license purchase."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases:"})," Large-scale commercial projects, applications requiring a full-featured IDE and commercial support."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"LispWorks is a powerful choice for professional Lisp development, especially for large teams or projects requiring advanced tools and support."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Summary Table:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Implementation"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"License"}),(0,s.jsx)(n.th,{children:"Platforms"}),(0,s.jsx)(n.th,{children:"Strengths"}),(0,s.jsx)(n.th,{children:"Weaknesses"}),(0,s.jsx)(n.th,{children:"Use Cases"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SBCL"}),(0,s.jsx)(n.td,{children:"Compiler"}),(0,s.jsx)(n.td,{children:"Open Source"}),(0,s.jsx)(n.td,{children:"Many (Linux, macOS, Windows, etc.)"}),(0,s.jsx)(n.td,{children:"Excellent performance, robust compiler, active community"}),(0,s.jsx)(n.td,{children:"Can be less forgiving of non-standard code"}),(0,s.jsx)(n.td,{children:"Performance-critical applications, general-purpose development"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CCL"}),(0,s.jsx)(n.td,{children:"Compiler"}),(0,s.jsx)(n.td,{children:"Open Source"}),(0,s.jsx)(n.td,{children:"macOS, Linux, Windows, etc."}),(0,s.jsx)(n.td,{children:"Very fast, stable, excellent macOS support"}),(0,s.jsx)(n.td,{children:"Smaller community than SBCL"}),(0,s.jsx)(n.td,{children:"macOS development, general-purpose development"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ECL"}),(0,s.jsx)(n.td,{children:"Bytecode/Int"}),(0,s.jsx)(n.td,{children:"Open Source"}),(0,s.jsx)(n.td,{children:"Highly portable"}),(0,s.jsx)(n.td,{children:"Embeddable, small footprint"}),(0,s.jsx)(n.td,{children:"Lower performance than native compilers"}),(0,s.jsx)(n.td,{children:"Embedding Lisp, scripting"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ABCL"}),(0,s.jsx)(n.td,{children:"JVM-based"}),(0,s.jsx)(n.td,{children:"Open Source"}),(0,s.jsx)(n.td,{children:"Any platform with a JVM"}),(0,s.jsx)(n.td,{children:"Java integration, JVM portability"}),(0,s.jsx)(n.td,{children:"Performance dependent on JVM"}),(0,s.jsx)(n.td,{children:"Java integration, cross-platform development"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LispWorks"}),(0,s.jsx)(n.td,{children:"Compiler/Int"}),(0,s.jsx)(n.td,{children:"Commercial"}),(0,s.jsx)(n.td,{children:"macOS, Windows, Linux, etc."}),(0,s.jsx)(n.td,{children:"Comprehensive IDE, advanced features, commercial support, high stability"}),(0,s.jsx)(n.td,{children:"Requires a license"}),(0,s.jsx)(n.td,{children:"Large-scale commercial projects, applications requiring advanced tools and support"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This section provided an overview of some of the most popular Common Lisp implementations. The next sections will cover related concepts like package managers, build tools, and the Foreign Function Interface."}),"\n",(0,s.jsx)(n.h2,{id:"2-choosing-a-common-lisp-implementation",children:"2. Choosing a Common Lisp Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Selecting the right Common Lisp implementation depends on your specific needs and priorities. This section outlines key factors to consider when making your choice."}),"\n",(0,s.jsx)(n.h3,{id:"21-performance-considerations",children:"2.1 Performance Considerations"}),"\n",(0,s.jsx)(n.p,{children:"Performance is often a primary concern. Different implementations have different strengths and weaknesses when it comes to speed."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Native Compilers (SBCL, CCL):"})," Generally offer the best performance, as they compile Lisp code directly to native machine code. SBCL is often considered the fastest, but CCL is also very performant, especially on macOS. If raw speed is critical, these are usually the best choices."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bytecode Compilers/Interpreters (ECL):"})," Trade some performance for portability and embeddability. ECL's performance is generally lower than that of native compilers, but it's often sufficient for many applications, especially when embedding is a key requirement."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JVM-based Implementations (ABCL):"})," Performance depends on the underlying Java Virtual Machine. While JVMs have improved significantly in performance, they generally don't match the raw speed of native compilers for computationally intensive Lisp code. However, ABCL provides seamless integration with Java libraries, which can be a significant advantage."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When evaluating performance, consider the type of application you're building. For CPU-bound tasks, native compilers are usually preferable. For applications that rely heavily on I/O or interaction with external systems, the performance differences might be less significant."}),"\n",(0,s.jsx)(n.h3,{id:"22-platform-compatibility",children:"2.2 Platform Compatibility"}),"\n",(0,s.jsx)(n.p,{children:"Ensure the implementation you choose supports the platforms you need to target."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-Platform Implementations (SBCL, CCL, ECL, ABCL):"})," These implementations support a variety of operating systems and architectures. SBCL, ECL and ABCL are good choices for cross-platform development. CCL has excellent support for macOS as well as other platforms."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operating System Specific Implementations:"})," Some implementations might have stronger support for specific operating systems."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Consider both your development environment and the target deployment environment when evaluating platform compatibility."}),"\n",(0,s.jsx)(n.h3,{id:"23-available-libraries-and-tools",children:"2.3 Available Libraries and Tools"}),"\n",(0,s.jsx)(n.p,{children:"The availability of libraries and tools can significantly impact your development process."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Quicklisp:"})," A package manager that provides access to a large collection of open-source Lisp libraries. Most implementations support Quicklisp, making library management relatively consistent across implementations. However, some libraries may have better support or performance on specific implementations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FFI (Foreign Function Interface):"})," The ability to interact with code written in other languages (like C) is crucial for many applications. Most major implementations provide a Foreign Function Interface (FFI). CFFI is a common and portable FFI library that works across multiple implementations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IDEs and Development Tools:"})," SLIME (Superior Lisp Interaction Mode for Emacs) is a popular development environment for Common Lisp. It works well with most implementations. LispWorks provides its own comprehensive IDE."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Consider the libraries and tools you'll need for your project and ensure they are compatible with the implementation you choose."}),"\n",(0,s.jsx)(n.h3,{id:"24-licensing-and-support",children:"2.4 Licensing and Support"}),"\n",(0,s.jsx)(n.p,{children:"Licensing and support are important factors, especially for commercial projects."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open-Source Implementations (SBCL, CCL, ECL, ABCL):"})," These are free to use and distribute, making them attractive for open-source projects and hobbyists."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Commercial Implementations (LispWorks):"})," Offer commercial support, which can be valuable for large organizations or projects requiring guaranteed assistance."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Consider your project's licensing requirements and the level of support you might need when making your decision."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Summary of Choosing Factors:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Factor"}),(0,s.jsx)(n.th,{children:"Considerations"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Performance"}),(0,s.jsx)(n.td,{children:"Native compilers (SBCL, CCL) are generally fastest. Consider the type of application (CPU-bound vs. I/O-bound)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Platform"}),(0,s.jsx)(n.td,{children:"Ensure compatibility with your development and deployment environments."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Libraries/Tools"}),(0,s.jsx)(n.td,{children:"Check for compatibility with Quicklisp and necessary libraries. Consider FFI and IDE support."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Licensing/Support"}),(0,s.jsx)(n.td,{children:"Open-source implementations are free. Commercial implementations offer support."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"By considering these factors, you can make an informed decision about which Common Lisp implementation is best suited for your project. Often, SBCL is a good default choice due to its performance and active community, but other implementations might be more appropriate depending on your specific needs."}),"\n",(0,s.jsx)(n.h2,{id:"3-package-managers-in-common-lisp-quicklisp",children:"3. Package Managers in Common Lisp: Quicklisp"}),"\n",(0,s.jsx)(n.p,{children:"Managing external libraries and dependencies is crucial for any software project. In Common Lisp, Quicklisp is the de facto standard package manager, simplifying the process of finding, installing, and using libraries."}),"\n",(0,s.jsx)(n.h3,{id:"31-quicklisp-a-widely-used-package-manager",children:"3.1 Quicklisp: A Widely Used Package Manager"}),"\n",(0,s.jsx)(n.p,{children:"Quicklisp is a package manager that provides access to a large collection of open-source Common Lisp libraries. It makes it easy to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Install libraries:"})," Download and install libraries with a single command."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manage dependencies:"})," Automatically handle library dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update libraries:"})," Keep your installed libraries up to date."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create local projects:"})," Manage dependencies for individual projects."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Quicklisp works by maintaining a central repository of library metadata (information about libraries, their dependencies, and where to download them). When you install a library, Quicklisp downloads the library's source code and any necessary dependencies."}),"\n",(0,s.jsx)(n.h3,{id:"32-using-quicklisp-to-install-and-manage-libraries",children:"3.2 Using Quicklisp to Install and Manage Libraries"}),"\n",(0,s.jsx)(n.p,{children:"Here's how to get started with Quicklisp and use it to manage libraries:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Installation:"})}),"\n",(0,s.jsx)(n.p,{children:"The easiest way to install Quicklisp is to load it directly from its website. Start your Lisp REPL and evaluate the following form:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "quicklisp")\n'})}),"\n",(0,s.jsx)(n.p,{children:"This will download and install Quicklisp. After the installation is complete, you'll need to load it again, and set it up locally:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(load (merge-pathnames "setup.lisp" (user-homedir-pathname)))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This creates a local Quicklisp installation in your home directory (usually ",(0,s.jsx)(n.code,{children:"~/.quicklisp/"}),")."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Loading Quicklisp in your Lisp environment:"})}),"\n",(0,s.jsx)(n.p,{children:"After the initial installation, you can load Quicklisp in your Lisp environment by evaluating:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "quicklisp")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You can add this form to your Lisp initialization file (e.g., ",(0,s.jsx)(n.code,{children:"~/.sbclrc"})," for SBCL) so that Quicklisp is loaded automatically when you start your Lisp environment."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Installing Libraries:"})}),"\n",(0,s.jsxs)(n.p,{children:["To install a library using Quicklisp, use the ",(0,s.jsx)(n.code,{children:"ql:quickload"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "drakma") ; Installs the Drakma HTTP client library\n'})}),"\n",(0,s.jsx)(n.p,{children:"Quicklisp will download and install the specified library and any dependencies it requires. Once a library is quickloaded it is available in the current lisp session."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. Using Installed Libraries:"})}),"\n",(0,s.jsxs)(n.p,{children:["Once a library is installed, you can use it in your code using ",(0,s.jsx)(n.code,{children:"require"})," or ",(0,s.jsx)(n.code,{children:"ql:quickload"}),". ",(0,s.jsx)(n.code,{children:"require"})," is the traditional way to load a library, however it only works if the library is already loaded in the lisp environment. ",(0,s.jsx)(n.code,{children:"ql:quickload"})," will load the library if it is not already loaded, therefore it is more convenient."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "drakma")\n(drakma:http-request "http://www.google.com")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"5. Updating Quicklisp and Libraries:"})}),"\n",(0,s.jsxs)(n.p,{children:["To update Quicklisp itself, use the ",(0,s.jsx)(n.code,{children:"ql:update-dist"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(ql:update-dist)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To update all installed libraries, use the ",(0,s.jsx)(n.code,{children:"ql:update-all-dists"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(ql:update-all-dists)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"6. Local Projects:"})}),"\n",(0,s.jsx)(n.p,{children:"Quicklisp also supports managing dependencies for individual projects. You can create a local projects directory and use a local-projects file to manage dependencies for each project independently."}),"\n",(0,s.jsxs)(n.p,{children:["First, create a ",(0,s.jsx)(n.code,{children:"local-projects"})," directory inside your ",(0,s.jsx)(n.code,{children:"~/.quicklisp"})," directory if it doesn't exist:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"mkdir -p ~/.quicklisp/local-projects\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then, create a file named ",(0,s.jsx)(n.code,{children:"<your-project-name>.asd"})," inside the ",(0,s.jsx)(n.code,{children:"local-projects"})," directory with the following content:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :version "1.0.0"\n  :description "My awesome project"\n  :author "Your Name"\n  :license "MIT"\n  :depends-on ("drakma" "other-library"))\n'})}),"\n",(0,s.jsx)(n.p,{children:"Then, in your Lisp environment, load your project:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(ql:quickload :my-project)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will load your project and all its dependencies."}),"\n",(0,s.jsx)(n.p,{children:"Quicklisp is an essential tool for any Common Lisp developer. It simplifies library management and makes it easy to use external code in your projects. This section provided a basic introduction to Quicklisp. For more advanced features and options, refer to the Quicklisp documentation. The next section will cover ASDF, the standard build tool for Common Lisp."}),"\n",(0,s.jsx)(n.h3,{id:"33-qlot",children:"3.3 Qlot"}),"\n",(0,s.jsx)(n.p,{children:"Qlot is basically a way to manage project specific dependencies and it can fetch those dependencies from a varierty of sources including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"multiple quicklisp distributions"}),"\n",(0,s.jsx)(n.li,{children:"git repositories"}),"\n",(0,s.jsx)(n.li,{children:"http(s) files"}),"\n",(0,s.jsx)(n.li,{children:"and others"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It's extensible to be able to add different types of sources."}),"\n",(0,s.jsx)(n.p,{children:"The tutorial in the repository is the best source of information. I personally use qlot for managing the code in my small company and it has been very useful."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/fukamachi/qlot",children:"https://github.com/fukamachi/qlot"})}),"\n",(0,s.jsx)(n.h3,{id:"34-ocicl",children:"3.4 OCICL"}),"\n",(0,s.jsxs)(n.p,{children:["OCICL is a new alternative to quicklisp, and like qlot, it sets up project specific dependency management. Here's ",(0,s.jsx)(n.a,{href:"https://github.com/ocicl/ocicl",children:"a link"})," to the repository with its tutorial."]}),"\n",(0,s.jsx)(n.h2,{id:"4-build-tools-asdf",children:"4. Build Tools: ASDF"}),"\n",(0,s.jsx)(n.p,{children:"ASDF (Another System Definition Facility) is the standard build system for Common Lisp. It provides a way to define software components (systems) and their dependencies, making it easier to build, load, and manage Lisp projects."}),"\n",(0,s.jsx)(n.h3,{id:"41-asdf-another-system-definition-facility-a-standard-build-system",children:"4.1 ASDF (Another System Definition Facility): A Standard Build System"}),"\n",(0,s.jsxs)(n.p,{children:["ASDF provides a declarative way to describe software components (systems) and their dependencies. A ",(0,s.jsx)(n.em,{children:"system"})," is a collection of files (Lisp source code, data files, etc.) that make up a logical unit of software. ASDF handles the details of compiling, loading, and linking these files in the correct order."]}),"\n",(0,s.jsx)(n.p,{children:"Key features of ASDF:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System definitions:"})," Describe the components of a software project and their dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependency management:"})," Automatically loads required libraries and systems."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Build operations:"})," Provides operations like compiling, loading, and testing."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Portability:"})," Works across different Common Lisp implementations."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"42-defining-systems-and-dependencies-with-asdf",children:"4.2 Defining Systems and Dependencies with ASDF"}),"\n",(0,s.jsxs)(n.p,{children:["System definitions are written in Lisp and typically stored in files with the ",(0,s.jsx)(n.code,{children:".asd"})," extension. A basic system definition looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "My awesome project"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :depends-on ("cl-ppcre") ; Dependencies\n  :components ((:file "my-project") ; Source file\n               (:file "utils")))     ; Another source file\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's break down the components of this definition:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"asdf:defsystem"})}),": Defines a new system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:":my-project"}),": The name of the system (a keyword)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:":description"}),", ",(0,s.jsx)(n.strong,{children:":author"}),", ",(0,s.jsx)(n.strong,{children:":license"}),", ",(0,s.jsx)(n.strong,{children:":version"}),": Metadata about the system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:":depends-on"}),": A list of other systems that this system depends on. ASDF will ensure that these dependencies are loaded before loading the current system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:":components"}),": A list of components that make up the system. In this case, we have two source files: ",(0,s.jsx)(n.code,{children:"my-project.lisp"})," and ",(0,s.jsx)(n.code,{children:"utils.lisp"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Component Types:"})}),"\n",(0,s.jsx)(n.p,{children:"ASDF supports various component types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:":file"})}),": Represents a Lisp source file."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:":module"})}),": Represents a subdirectory containing other components."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:":static-file"})}),": Represents a file that should be copied as-is (e.g., data files)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example with Modules:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :description "My awesome project"\n  :author "Your Name"\n  :license "MIT"\n  :version "1.0.0"\n  :depends-on ("cl-ppcre")\n  :components ((:module "src" ; A module (subdirectory)\n                 :components ((:file "src/my-project")\n                              (:file "src/utils")))\n               (:file "tests/my-project-tests"))) ; Test file\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This example defines a module ",(0,s.jsx)(n.code,{children:"src"})," containing the source files and a separate test file. The files would be located in the directory structure:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"my-project/\n\u251c\u2500\u2500 my-project.asd\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 my-project.lisp\n    \u2514\u2500\u2500 utils.lisp\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 my-project-tests.lisp\n"})}),"\n",(0,s.jsx)(n.h3,{id:"43-building-and-loading-lisp-projects",children:"4.3 Building and Loading Lisp Projects"}),"\n",(0,s.jsx)(n.p,{children:"Once you have defined a system, you can use ASDF to build and load it."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Loading ASDF:"})}),"\n",(0,s.jsx)(n.p,{children:"If it is not already loaded by your lisp environment, you can load ASDF using quicklisp:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "asdf")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Loading a System:"})}),"\n",(0,s.jsxs)(n.p,{children:["To load a system, use the ",(0,s.jsx)(n.code,{children:"asdf:load-system"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(asdf:load-system :my-project)\n"})}),"\n",(0,s.jsx)(n.p,{children:"ASDF will automatically compile the source files (if necessary) and load them in the correct order, resolving any dependencies."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Compiling a System:"})}),"\n",(0,s.jsxs)(n.p,{children:["You can explicitly compile a system using the ",(0,s.jsx)(n.code,{children:"asdf:compile-system"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(asdf:compile-system :my-project)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will compile the source files without loading them. This is useful for creating compiled fasl files that can be loaded more quickly later."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. Other ASDF Operations:"})}),"\n",(0,s.jsx)(n.p,{children:"ASDF provides other useful operations, such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"asdf:test-system"}),": Runs the tests associated with a system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"asdf:upgrade-system"}),": Upgrades a system to a newer version."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's say you have the following ",(0,s.jsx)(n.code,{children:"my-project.asd"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(asdf:defsystem :my-project\n  :version "1.0.0"\n  :description "A simple project"\n  :author "Your Name"\n  :license "MIT"\n  :components ((:file "my-project")))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And a corresponding ",(0,s.jsx)(n.code,{children:"my-project.lisp"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defpackage :my-project\n  (:use :cl)\n  (:export :hello))\n\n(in-package :my-project)\n\n(defun hello ()\n  (format t "Hello, world!~%"))\n'})}),"\n",(0,s.jsx)(n.p,{children:"You can load and use the project like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(asdf:load-system :my-project)\n(my-project:hello) ; Prints "Hello, world!"\n'})}),"\n",(0,s.jsx)(n.p,{children:"ASDF is an essential tool for managing Lisp projects. It provides a standardized and portable way to define systems, manage dependencies, and build your code. This section provided a basic introduction to ASDF. For more advanced features and options, refer to the ASDF documentation. The next section will cover the Foreign Function Interface (FFI)."}),"\n",(0,s.jsx)(n.h2,{id:"5-foreign-function-interface-ffi-in-common-lisp",children:"5. Foreign Function Interface (FFI) in Common Lisp"}),"\n",(0,s.jsx)(n.p,{children:"The Foreign Function Interface (FFI) allows Common Lisp programs to interact with code written in other programming languages, most commonly C. This is crucial for accessing system libraries, using existing C codebases, or improving performance by offloading computationally intensive tasks to C. CFFI (C Foreign Function Interface) is a widely used and portable library that simplifies FFI interactions in Common Lisp."}),"\n",(0,s.jsx)(n.h3,{id:"51-interacting-with-c-code-using-cffi",children:"5.1 Interacting with C code using CFFI"}),"\n",(0,s.jsx)(n.p,{children:"CFFI provides a high-level interface for defining foreign functions and data structures, making it easier to call C code from Lisp and vice versa. It handles the details of data type conversions and calling conventions, allowing you to focus on the logic of your interaction with the foreign code."}),"\n",(0,s.jsx)(n.p,{children:"To use CFFI, you first need to load it using Quicklisp:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "cffi")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"52-calling-c-functions-from-lisp",children:"5.2 Calling C Functions from Lisp"}),"\n",(0,s.jsxs)(n.p,{children:["To call a C function from Lisp, you need to declare it using ",(0,s.jsx)(n.code,{children:"cffi:defcfun"}),". The syntax is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(cffi:defcfun c-function-name return-type\n  (lisp-argument-name1 c-argument-type1)\n  (lisp-argument-name2 c-argument-type2)\n  ...)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"c-function-name"})}),": The name of the C function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"return-type"})}),": The C type of the return value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"lisp-argument-name"})}),": The name you'll use in Lisp to refer to the argument."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"c-argument-type"})}),": The C type of the argument."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's say you have a simple C function in ",(0,s.jsx)(n.code,{children:"my_c_library.c"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n\nint add(int a, int b) {\n  return a + b;\n}\n\nvoid print_message(const char *message) {\n    printf("%s\\n", message);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And you compile it into a shared library ",(0,s.jsx)(n.code,{children:"libmy_c_library.so"})," (on Linux/macOS) or ",(0,s.jsx)(n.code,{children:"my_c_library.dll"})," (on Windows). You can then define the corresponding Lisp functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(cffi:load-foreign-library "libmy_c_library") ; Load the shared library\n\n(cffi:defcfun add (:int)\n  (a :int)\n  (b :int))\n\n(cffi:defcfun print-message :void\n    (message :string))\n\n(add 10 20) ; Returns 30\n(print-message "Hello from Lisp!") ; Prints "Hello from Lisp!" to standard output\n'})}),"\n",(0,s.jsxs)(n.p,{children:["CFFI provides a wide range of C types that you can use in ",(0,s.jsx)(n.code,{children:"defcfun"}),", including ",(0,s.jsx)(n.code,{children:":int"}),", ",(0,s.jsx)(n.code,{children:":unsigned-int"}),", ",(0,s.jsx)(n.code,{children:":float"}),", ",(0,s.jsx)(n.code,{children:":double"}),", ",(0,s.jsx)(n.code,{children:":pointer"}),", ",(0,s.jsx)(n.code,{children:":string"}),", and many others."]}),"\n",(0,s.jsx)(n.h3,{id:"53-using-lisp-data-structures-in-c",children:"5.3 Using Lisp Data Structures in C"}),"\n",(0,s.jsx)(n.p,{children:"CFFI also allows you to pass Lisp data structures to C functions and vice-versa. This is typically done using pointers and foreign memory."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Passing an array to C:"})}),"\n",(0,s.jsx)(n.p,{children:"Let's modify the C library to accept an array of integers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <stdio.h>\n\nint sum_array(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i < len; i++) {\n    sum += arr[i];\n  }\n  return sum;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And the corresponding Lisp code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(cffi:load-foreign-library "libmy_c_library")\n\n(cffi:defcfun sum-array :int\n  (arr :pointer)\n  (len :int))\n\n(let ((lisp-array (vector 1 2 3 4 5)))\n  (cffi:with-foreign-object (c-array :int (length lisp-array)) ; Allocate foreign memory\n    (loop for i from 0 below (length lisp-array)\n          do (setf (cffi:mem-aref c-array :int i) (aref lisp-array i))) ; Copy Lisp array to C array\n    (sum-array c-array (length lisp-array)))) ; Call the C function\n; Returns 15\n'})}),"\n",(0,s.jsx)(n.p,{children:"Here's what's happening:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cffi:with-foreign-object"})," allocates a block of foreign memory of the appropriate size to hold the C array."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cffi:mem-aref"})," is used to access and set elements in the foreign memory as if it were a C array."]}),"\n",(0,s.jsxs)(n.li,{children:["The pointer to the foreign memory is passed to the C function ",(0,s.jsx)(n.code,{children:"sum_array"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Returning a string from C:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'#include <string.h>\n#include <stdlib.h>\n\nchar* create_message(const char *name) {\n    char *message = (char*) malloc(100 * sizeof(char)); // Allocate memory\n    strcpy(message, "Hello, ");\n    strcat(message, name);\n    return message;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(cffi:load-foreign-library "libmy_c_library")\n\n(cffi:defcfun create-message :string\n    (name :string))\n\n(create-message "Lisp") ; Returns "Hello, Lisp"\n'})}),"\n",(0,s.jsx)(n.p,{children:"CFFI handles the conversion of the C string to a Lisp string and also frees the memory allocated in C."}),"\n",(0,s.jsx)(n.p,{children:"CFFI provides many more features for interacting with C, including defining structures, unions, callbacks, and more. This section provided a basic introduction to CFFI. For more advanced usage, consult the CFFI documentation. The next section will briefly cover some popular Lisp development environments."}),"\n",(0,s.jsx)(n.h2,{id:"6-development-environments-for-common-lisp",children:"6. Development Environments for Common Lisp"}),"\n",(0,s.jsx)(n.p,{children:"A good development environment can significantly improve your productivity when working with any programming language. This section introduces SLIME, the most popular development environment for Common Lisp, and briefly mentions other available options."}),"\n",(0,s.jsx)(n.h3,{id:"61-slime-superior-lisp-interaction-mode-for-emacs-and-sly",children:"6.1 SLIME (Superior Lisp Interaction Mode for Emacs) (and Sly)"}),"\n",(0,s.jsx)(n.p,{children:"SLIME (Superior Lisp Interaction Mode for Emacs) is an Emacs mode that provides a powerful and interactive development environment for Common Lisp. It's the most widely used and highly regarded Lisp development environment."}),"\n",(0,s.jsx)(n.p,{children:"Key features of SLIME:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"REPL integration:"})," Provides a fully integrated REPL within Emacs, allowing you to evaluate Lisp code interactively."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Code completion:"})," Offers intelligent code completion for symbols, functions, and other Lisp constructs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging:"})," Provides powerful debugging features, including stepping through code, inspecting variables, and setting breakpoints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-referencing:"})," Allows you to easily navigate between function definitions, variable usages, and other code elements."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation lookup:"})," Provides quick access to Lisp documentation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration with Quicklisp and ASDF:"})," Seamlessly integrates with Quicklisp for library management and ASDF for project management."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Setting up SLIME:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Install Emacs:"})," If you don't already have it, install Emacs."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Install Quicklisp:"})," Follow the instructions in the previous section to install Quicklisp."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Install SLIME via Quicklisp:"})," Within your Lisp REPL, evaluate:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "slime")\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configure Emacs:"})," Add the following lines to your Emacs initialization file (e.g., ",(0,s.jsx)(n.code,{children:"~/.emacs"})," or ",(0,s.jsx)(n.code,{children:"~/.emacs.d/init.el"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-elisp",children:"(add-to-list 'load-path \"~/.quicklisp/dists/quicklisp/software/slime-20231022/\") ; Replace with correct path\n(require 'slime)\n(slime-setup '(sbcl)) ; Replace sbcl with your Lisp implementation of choice\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Make sure to replace the path with the actual location of your SLIME installation. You can find the correct path by evaluating ",(0,s.jsx)(n.code,{children:'(ql:qmerge "slime/slime.el")'})," in your Lisp REPL. The path shown might be slightly different depending on the version of SLIME you installed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Start SLIME:"})," After restarting Emacs, you can start SLIME by running the command ",(0,s.jsx)(n.code,{children:"M-x slime"}),". This will connect Emacs to your Lisp implementation."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Basic SLIME Usage:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"C-x C-e"})," (eval-last-expression):"]})," Evaluates the Lisp expression before the cursor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"C-c C-c"})," (compile-defun):"]})," Compiles the top-level form (e.g., function, class) where the cursor is."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"M-."})," (find-definition):"]})," Jumps to the definition of the symbol at the cursor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"C-c d d"})," (describe-symbol):"]})," Displays information about the symbol at the cursor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"C-c C-z"})," (switch-to-slime-repl):"]})," Switches to the SLIME REPL buffer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"C-c C-d"})," (slime-documentation-lookup):"]})," Lookups the documentation for the symbol at the cursor."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"SLIME provides many other powerful features that can greatly enhance your Lisp development workflow. Learning the basic commands and exploring the available features is highly recommended."}),"\n",(0,s.jsx)(n.h3,{id:"62-other-lisp-ides",children:"6.2 Other Lisp IDEs"}),"\n",(0,s.jsx)(n.p,{children:"While SLIME is the most popular choice, other Lisp IDEs and development tools are available:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LispWorks IDE:"})," As mentioned earlier, LispWorks provides its own comprehensive IDE with advanced features. It's a commercial product but offers a very polished and professional development experience."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Portacle:"})," A portable Common Lisp development environment that includes SBCL, SLIME, and other tools in a single package. It's a good option for beginners as it simplifies the setup process."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lem:"})," A Common Lisp editor inspired by Emacs. While not strictly an IDE like SLIME, it offers Lisp-specific features and can be a good alternative for those who prefer a more modern editor experience. Lem is making quick strides with an incredibly active communty to a point where it seems the aim is to replace emacs altogether. They even have their own version of magit called legit, and they keep coming up with new improvements all the time. With that said, the documentation is not as extensive, and it assumes you know how to use emacs, since most of the key bindinds are similar. I would suggest beginners to use emacs instead."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visual Studio Code:"})," has a slynk connector to a slime server. I personally started using this because of the high barrier to entry to lisp. However, once I finally made the jump to emacs, the improvement in the workflow was very big. While programming in CL in visual studio is still better than say python or any other language because of the REPL, it is still really behind using emacs. The emacs integration to the Common Lisp REPL programming workflow is unmatched."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sublime Text:"})," also has a REPL package, which can sometimes be better than Visual Studio since the REPL is loaded as a new tab and it makes it much more convenient than Visual Studio (this is my personal experience)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atom:"})," even though the editor itself is discontinued, the CL REPL integration is still pretty good and accessible for beginners."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"climacs:"})," this is hopefully going to be the future once it's fully implemented. It integrates with CL in a way no other editor, including emacs, has. However, the actual editor functionality is not ready."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["My personal recommendation if you are starting with Common Lisp and don't want to waste time learning emacs is to use either VSCode, Sublime Text, or Atom. This is ",(0,s.jsx)(n.strong,{children:"not"})," the standard recommendation. Once you decide to invest in Common Lisp and actually code any medium to large project, my recommendation is to jump ship immediately and invest in learning emacs. Most people will recommend just using emacs right away, which I agree is the right approach once you have commited to Common Lisp, however, I understand the frustration involved in the slowdown of having to learn a very different IDE than all the ",(0,s.jsx)(n.em,{children:"modern"})," ones. I will say though that once you learn emacs, this by itself will be worth it and it may even become your standard editor for a lot of things. Emacs is very powerful and customizable, it's just that the steep learning curve makes it hard to start. I recommend to start using org mode right away to manage your todo lists even if you don't use it to program, that way you slowly get used to using emacs, and after a while of using even very basic org mode functionality, you will realize it's a better editor than basically anything else out there including Visual Studio Code, Sublime Text, Zed, and the rest, so that will then make it obvious to switch to programming with emacs, and will make the transition smoother. It's much easier to just have to learn how to use the Slime/Sly IDE features instead of having to learn text editing features and IDE features at the same time."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>o});var s=i(7294);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);