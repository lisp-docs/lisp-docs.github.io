"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[7473],{7901:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var t=i(5893),s=i(1151);const o={sidebar_position:14},r="Documenting your Code",c={id:"tutorial/documentation",title:"Documenting your Code",description:"Introduction to Documenting Code in Common Lisp",source:"@site/docs/tutorial/documentation.md",sourceDirName:"tutorial",slug:"/tutorial/documentation",permalink:"/docs/tutorial/documentation",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/documentation.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"Structuring Large Projects",permalink:"/docs/tutorial/projects/structuring_large_projects"},next:{title:"Index",permalink:"/docs/tutorial/index"}},a={},d=[{value:"Introduction to Documenting Code in Common Lisp",id:"introduction-to-documenting-code-in-common-lisp",level:2},{value:"1. Documentation Strings",id:"1-documentation-strings",level:2},{value:"1.1 What are Documentation Strings?",id:"11-what-are-documentation-strings",level:3},{value:"1.2 Syntax for Attaching Documentation Strings",id:"12-syntax-for-attaching-documentation-strings",level:3},{value:"1.3 Placement of Documentation Strings",id:"13-placement-of-documentation-strings",level:3},{value:"2. The <code>documentation</code> Function",id:"2-the-documentation-function",level:2},{value:"2.1 Basic Usage of <code>documentation</code>",id:"21-basic-usage-of-documentation",level:3},{value:"2.2 Specifying the Documentation Type",id:"22-specifying-the-documentation-type",level:3},{value:"2.3 Handling Missing Documentation",id:"23-handling-missing-documentation",level:3},{value:"3. Documenting Different Entities",id:"3-documenting-different-entities",level:2},{value:"3.1 Documenting Functions (<code>defun</code>)",id:"31-documenting-functions-defun",level:3},{value:"3.2 Documenting Macros (<code>defmacro</code>)",id:"32-documenting-macros-defmacro",level:3},{value:"3.3 Documenting Variables (<code>defvar</code>, <code>defparameter</code>, <code>defconstant</code>)",id:"33-documenting-variables-defvar-defparameter-defconstant",level:3},{value:"3.4 Documenting Classes (<code>defclass</code>)",id:"34-documenting-classes-defclass",level:3},{value:"3.5 Documenting Packages (<code>defpackage</code>)",id:"35-documenting-packages-defpackage",level:3},{value:"3.6 Documenting Generic Functions (<code>defgeneric</code>)",id:"36-documenting-generic-functions-defgeneric",level:3},{value:"3.7 Documenting Methods (<code>defmethod</code>)",id:"37-documenting-methods-defmethod",level:3},{value:"3.8 Documenting Structures (<code>defstruct</code>)",id:"38-documenting-structures-defstruct",level:3},{value:"4. Style and Best Practices",id:"4-style-and-best-practices",level:2},{value:"4.1 Writing Clear and Concise Documentation",id:"41-writing-clear-and-concise-documentation",level:3},{value:"4.2 Using Consistent Formatting",id:"42-using-consistent-formatting",level:3},{value:"4.3 Documenting Parameters, Return Values, and Side Effects",id:"43-documenting-parameters-return-values-and-side-effects",level:3},{value:"4.4 Examples of Good Documentation",id:"44-examples-of-good-documentation",level:3},{value:"5. Tools and Utilities",id:"5-tools-and-utilities",level:2},{value:"5.1 Available Systems for Generating Documentation",id:"51-available-systems-for-generating-documentation",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"documenting-your-code",children:"Documenting your Code"}),"\n",(0,t.jsx)(n.h2,{id:"introduction-to-documenting-code-in-common-lisp",children:"Introduction to Documenting Code in Common Lisp"}),"\n",(0,t.jsx)(n.p,{children:"Documenting code is a crucial aspect of software development, ensuring maintainability, collaboration, and understanding. Common Lisp provides excellent built-in facilities for documenting your code directly within the source files. These facilities allow you to embed documentation strings, which can then be extracted by various tools to generate documentation in different formats."}),"\n",(0,t.jsx)(n.p,{children:"This tutorial will introduce you to the core concepts and forms for documenting Common Lisp code, covering how to attach documentation to various program entities and how to access this documentation programmatically."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation Strings:"})," Strings attached to program entities (functions, variables, classes, etc.) that describe their purpose and usage."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"documentation"})," Function:"]})," Accessing documentation strings programmatically."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documenting Different Entities:"})," How to document functions, macros, variables, classes, packages, and more."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Style and Best Practices:"})," Guidelines for writing effective documentation."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Table of Contents:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Documentation Strings:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What are documentation strings?"}),"\n",(0,t.jsx)(n.li,{children:"Syntax for attaching documentation strings."}),"\n",(0,t.jsx)(n.li,{children:"Placement of documentation strings."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["2. The ",(0,t.jsx)(n.code,{children:"documentation"})," Function:"]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Basic usage of ",(0,t.jsx)(n.code,{children:"documentation"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Specifying the documentation type."}),"\n",(0,t.jsx)(n.li,{children:"Handling missing documentation."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"3. Documenting Different Entities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Documenting functions (",(0,t.jsx)(n.code,{children:"defun"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting macros (",(0,t.jsx)(n.code,{children:"defmacro"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting variables (",(0,t.jsx)(n.code,{children:"defvar"}),", ",(0,t.jsx)(n.code,{children:"defparameter"}),", ",(0,t.jsx)(n.code,{children:"defconstant"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting classes (",(0,t.jsx)(n.code,{children:"defclass"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting packages (",(0,t.jsx)(n.code,{children:"defpackage"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting generic functions (",(0,t.jsx)(n.code,{children:"defgeneric"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting methods (",(0,t.jsx)(n.code,{children:"defmethod"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Documenting structures (",(0,t.jsx)(n.code,{children:"defstruct"}),")."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"4. Style and Best Practices:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Writing clear and concise documentation."}),"\n",(0,t.jsx)(n.li,{children:"Using consistent formatting."}),"\n",(0,t.jsx)(n.li,{children:"Documenting parameters, return values, and side effects."}),"\n",(0,t.jsx)(n.li,{children:"Examples of good documentation."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"5. Tools and Utilities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Brief overview of documentation generators."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This tutorial will provide a comprehensive guide to documenting your Common Lisp code effectively, enabling you to create well-documented and maintainable projects."}),"\n",(0,t.jsx)(n.h2,{id:"1-documentation-strings",children:"1. Documentation Strings"}),"\n",(0,t.jsx)(n.p,{children:"This section introduces the concept of documentation strings in Common Lisp, explaining what they are, how to attach them to code, and where they should be placed."}),"\n",(0,t.jsx)(n.h3,{id:"11-what-are-documentation-strings",children:"1.1 What are Documentation Strings?"}),"\n",(0,t.jsx)(n.p,{children:"Documentation strings (docstrings) are strings embedded within your Lisp code that serve as documentation for various program entities. They provide a way to describe the purpose, usage, and other relevant information about functions, macros, variables, classes, packages, and more."}),"\n",(0,t.jsxs)(n.p,{children:["Docstrings are not just comments; they are stored by the Lisp system and can be accessed programmatically using the ",(0,t.jsx)(n.code,{children:"documentation"})," function (covered in the next section). This makes them invaluable for generating documentation, providing help within the REPL, and enabling interactive development tools."]}),"\n",(0,t.jsx)(n.h3,{id:"12-syntax-for-attaching-documentation-strings",children:"1.2 Syntax for Attaching Documentation Strings"}),"\n",(0,t.jsx)(n.p,{children:"The syntax for attaching a documentation string depends on the specific construct you are documenting. However, the general principle is that the docstring should appear as a string literal immediately after the name of the entity being defined."}),"\n",(0,t.jsx)(n.p,{children:"Here are some common examples:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Functions (",(0,t.jsx)(n.code,{children:"defun"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun greet (name)\n  "Greets the given name." ; Docstring\n  (format t "Hello, ~a!~%" name))\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Macros (",(0,t.jsx)(n.code,{children:"defmacro"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defmacro when-positive (number &body body)\n  "Executes the body if the number is positive." ; Docstring\n  `(if (> ,number 0)\n       (progn ,@body)))\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Variables (",(0,t.jsx)(n.code,{children:"defvar"}),", ",(0,t.jsx)(n.code,{children:"defparameter"}),", ",(0,t.jsx)(n.code,{children:"defconstant"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defvar *my-global-variable* 42\n  "A global variable used for important calculations.") ; Docstring\n\n(defparameter *debug-mode* nil\n  "A flag to enable debug output.") ; Docstring\n\n(defconstant +pi+ 3.14159\n  "An approximation of pi.") ; Docstring\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Classes (",(0,t.jsx)(n.code,{children:"defclass"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age))\n  (:documentation "Represents a person with a name and age.")) ; Docstring\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Packages (",(0,t.jsx)(n.code,{children:"defpackage"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defpackage :my-utils\n  (:use :common-lisp)\n  (:export :my-function :my-variable)\n  (:documentation "A package containing utility functions.")) ; Docstring\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Generic Functions (",(0,t.jsx)(n.code,{children:"defgeneric"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defgeneric area (object)\n  (:documentation "Computes the area of an object.")) ; Docstring\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Methods (",(0,t.jsx)(n.code,{children:"defmethod"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defmethod area ((r rectangle))\n  "Computes the area of a rectangle." ; Docstring\n  (* (rectangle-width r) (rectangle-height r)))\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Structures (",(0,t.jsx)(n.code,{children:"defstruct"}),"):"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defstruct point\n  (x 0)\n  (y 0)\n  (:documentation "Represents a point in 2D space.")) ; Docstring\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"13-placement-of-documentation-strings",children:"1.3 Placement of Documentation Strings"}),"\n",(0,t.jsx)(n.p,{children:"The correct placement of documentation strings is crucial for them to be recognized by the Lisp system."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For functions, macros, and generic functions, the docstring should be the ",(0,t.jsx)(n.em,{children:"first"})," form inside the definition, immediately after the name of the entity."]}),"\n",(0,t.jsx)(n.li,{children:"For variables, the docstring should follow the initial value (if any)."}),"\n",(0,t.jsxs)(n.li,{children:["For classes and structures, the docstring should be placed within the options list (using the ",(0,t.jsx)(n.code,{children:":documentation"})," keyword)."]}),"\n",(0,t.jsxs)(n.li,{children:["For packages, the docstring is also placed within the options list using the ",(0,t.jsx)(n.code,{children:":documentation"})," keyword."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example showing correct and incorrect placement:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'; Correct:\n(defun my-function (x)\n  "This is the correct placement."\n  (+ x 1))\n\n; Incorrect:\n(defun my-function (x)\n  (+ x 1)\n  "This is incorrect.") ; This string will be evaluated but not stored as documentation\n\n; Correct:\n(defvar *my-variable* 10\n  "Correct docstring placement")\n\n; Incorrect:\n(defvar *my-variable*\n  "Incorrect docstring placement" ; This will cause an error\n  10)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["By following these rules, you can ensure that your documentation strings are correctly associated with the corresponding program entities and can be accessed programmatically. The next section will cover the ",(0,t.jsx)(n.code,{children:"documentation"})," function, which is used to retrieve these docstrings."]}),"\n",(0,t.jsxs)(n.h2,{id:"2-the-documentation-function",children:["2. The ",(0,t.jsx)(n.code,{children:"documentation"})," Function"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"documentation"})," function is the primary way to programmatically access documentation strings in Common Lisp. This section explains how to use it, how to specify the documentation type, and how to handle cases where documentation is missing."]}),"\n",(0,t.jsxs)(n.h3,{id:"21-basic-usage-of-documentation",children:["2.1 Basic Usage of ",(0,t.jsx)(n.code,{children:"documentation"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"documentation"})," function takes two arguments:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(documentation symbol doc-type)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"symbol"}),":"]})," The symbol representing the entity you want to get documentation for (e.g., a function name, variable name, class name, package name)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"doc-type"}),":"]})," A keyword specifying the type of documentation you want to retrieve (e.g., ",(0,t.jsx)(n.code,{children:":function"}),", ",(0,t.jsx)(n.code,{children:":variable"}),", ",(0,t.jsx)(n.code,{children:":class"}),", ",(0,t.jsx)(n.code,{children:":package"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"documentation"})," returns the documentation string associated with the given symbol and documentation type, or ",(0,t.jsx)(n.code,{children:"NIL"})," if no documentation is found."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(n.p,{children:"Using the examples from the previous section:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun greet (name)\n  "Greets the given name."\n  (format t "Hello, ~a!~%" name))\n\n(documentation \'greet \'function) ; Returns "Greets the given name."\n\n(defvar *my-global-variable* 42\n  "A global variable used for important calculations.")\n\n(documentation \'*my-global-variable* \'variable) ; Returns "A global variable used for important calculations."\n\n(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age))\n  (:documentation "Represents a person with a name and age."))\n\n(documentation \'person \'class) ; Returns "Represents a person with a name and age."\n\n(defpackage :my-utils\n  (:use :common-lisp)\n  (:export :my-function :my-variable)\n  (:documentation "A package containing utility functions."))\n\n(documentation :my-utils \'package) ; Returns "A package containing utility functions."\n'})}),"\n",(0,t.jsx)(n.h3,{id:"22-specifying-the-documentation-type",children:"2.2 Specifying the Documentation Type"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"doc-type"})," argument to ",(0,t.jsx)(n.code,{children:"documentation"})," specifies which kind of documentation you are requesting. The most common doc-types are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":function"}),": For functions and generic functions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":macro"}),": For macros."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":variable"}),": For variables (including ",(0,t.jsx)(n.code,{children:"defvar"}),", ",(0,t.jsx)(n.code,{children:"defparameter"}),", and ",(0,t.jsx)(n.code,{children:"defconstant"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":class"}),": For classes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":package"}),": For packages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":type"}),": For types defined with ",(0,t.jsx)(n.code,{children:"deftype"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":struct"}),": For structures defined with ",(0,t.jsx)(n.code,{children:"defstruct"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:":method"}),": For methods of generic functions."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["It's important to use the correct ",(0,t.jsx)(n.code,{children:"doc-type"}),", as a symbol can have different documentation strings for different types. For example, a symbol might be both a function and a variable, each with its own docstring."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(defun my-function ()\n  \"This is the function's documentation.\")\n\n(defvar my-function 10\n  \"This is the variable's documentation.\")\n\n(documentation 'my-function 'function) ; Returns \"This is the function's documentation.\"\n(documentation 'my-function 'variable) ; Returns \"This is the variable's documentation.\"\n"})}),"\n",(0,t.jsx)(n.h3,{id:"23-handling-missing-documentation",children:"2.3 Handling Missing Documentation"}),"\n",(0,t.jsxs)(n.p,{children:["If you call ",(0,t.jsx)(n.code,{children:"documentation"})," with a symbol and ",(0,t.jsx)(n.code,{children:"doc-type"})," for which no documentation string exists, it returns ",(0,t.jsx)(n.code,{children:"NIL"}),". It's good practice to handle this case gracefully in your code."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(defun my-function-without-docs ())\n\n(if (documentation 'my-function-without-docs 'function)\n    (print (documentation 'my-function-without-docs 'function))\n    (print \"No documentation found.\")) ; Prints \"No documentation found.\"\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A more concise way to do this is using ",(0,t.jsx)(n.code,{children:"or"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(print (or (documentation \'my-function-without-docs \'function)\n           "No documentation found.")) ; Prints "No documentation found."\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This uses the fact that ",(0,t.jsx)(n.code,{children:"or"})," returns the first non-",(0,t.jsx)(n.code,{children:"NIL"})," value."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example with methods:"})}),"\n",(0,t.jsx)(n.p,{children:"Methods are a bit different, as they are associated with generic functions and specialized on parameter types. To get the documentation of a method, you need to provide a list of the specialized parameter types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defgeneric my-generic (x))\n\n(defmethod my-generic ((x integer))\n  "This is the integer method.")\n\n(documentation `(my-generic ,(find-class \'integer)) \'method) ; Returns "This is the integer method."\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here, ",(0,t.jsx)(n.code,{children:"(find-class 'integer)"})," returns the class object for ",(0,t.jsx)(n.code,{children:"integer"}),", and the backquoted expression creates the method specializer list."]}),"\n",(0,t.jsxs)(n.p,{children:["Understanding how to use the ",(0,t.jsx)(n.code,{children:"documentation"})," function is essential for working with documentation strings programmatically. It allows you to create tools that generate documentation, provide online help, and perform other documentation-related tasks. The next section will cover style and best practices for writing effective documentation."]}),"\n",(0,t.jsx)(n.h2,{id:"3-documenting-different-entities",children:"3. Documenting Different Entities"}),"\n",(0,t.jsx)(n.p,{children:"This section provides specific examples of how to document various entities in Common Lisp, including functions, macros, variables, classes, packages, generic functions, methods, and structures."}),"\n",(0,t.jsxs)(n.h3,{id:"31-documenting-functions-defun",children:["3.1 Documenting Functions (",(0,t.jsx)(n.code,{children:"defun"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"The documentation string for a function should describe its purpose, arguments, return values, and any side effects."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun factorial (n)\n  "Computes the factorial of a non-negative integer N.\nReturns an integer representing the factorial of N.\nSignals an error if N is negative."\n  (if (< n 0)\n      (error "N must be non-negative.")\n      (if (zerop n)\n          1\n          (* n (factorial (1- n))))))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in function documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," A brief, clear description of what the function does."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arguments:"})," Describe each argument, including its type and purpose."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Return values:"})," Describe what the function returns and under what conditions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Side effects:"})," Mention any side effects the function has (e.g., modifying global variables, performing I/O)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Exceptions/Errors:"})," Document any errors or exceptions that the function might signal."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"32-documenting-macros-defmacro",children:["3.2 Documenting Macros (",(0,t.jsx)(n.code,{children:"defmacro"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Documenting macros is especially important because they perform code transformations. The documentation should explain what the macro does, how it transforms code, and what its arguments represent."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defmacro when-positive (number &body body)\n  "Executes the BODY forms if NUMBER is positive.\nNUMBER is an expression that evaluates to a number.\nBODY is a sequence of forms to be executed if NUMBER > 0."\n  `(if (> ,number 0)\n       (progn ,@body)))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in macro documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," A concise description of the macro's function."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arguments:"})," Explain what each argument represents ",(0,t.jsx)(n.em,{children:"in terms of code forms"}),' (e.g., "a form that evaluates to a number," "a list of forms").']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Expansion:"})," Briefly describe how the macro transforms the code."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"33-documenting-variables-defvar-defparameter-defconstant",children:["3.3 Documenting Variables (",(0,t.jsx)(n.code,{children:"defvar"}),", ",(0,t.jsx)(n.code,{children:"defparameter"}),", ",(0,t.jsx)(n.code,{children:"defconstant"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Documentation for variables should describe their purpose, usage, and any special characteristics."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defvar *debug-mode* nil\n  "A flag to enable or disable debug output.\nSetting this to T will enable verbose logging.")\n\n(defparameter *default-name* "Anonymous"\n  "The default name used when no name is provided.")\n\n(defconstant +maximum-connections+ 100\n  "The maximum number of allowed network connections.")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in variable documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," What the variable is used for."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scope:"})," Whether it's a global variable, special variable, or lexical variable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Meaning of values:"})," What different values of the variable represent."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"34-documenting-classes-defclass",children:["3.4 Documenting Classes (",(0,t.jsx)(n.code,{children:"defclass"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Class documentation should describe the purpose of the class, its slots (instance variables), and any important behavior."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age))\n  (:documentation \"Represents a person with a name and age.\nThe NAME slot stores the person's name as a string.\nThe AGE slot stores the person's age as an integer.\"))\n"})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in class documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," A description of what the class represents."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slots:"})," Describe each slot, including its name, type (if applicable), and purpose."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inheritance:"})," Mention any superclasses."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"35-documenting-packages-defpackage",children:["3.5 Documenting Packages (",(0,t.jsx)(n.code,{children:"defpackage"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Package documentation should describe the purpose of the package and what functionality it provides."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defpackage :my-utils\n  (:use :common-lisp)\n  (:export :my-function :my-variable)\n  (:documentation "A package containing utility functions for string manipulation and data processing."))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in package documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," A high-level description of the package's purpose."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Functionality:"})," A summary of the main features and functionalities provided by the package."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"36-documenting-generic-functions-defgeneric",children:["3.6 Documenting Generic Functions (",(0,t.jsx)(n.code,{children:"defgeneric"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Generic function documentation should describe the function's purpose and the general meaning of its arguments. The specific behavior for different argument types is documented in the methods."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defgeneric area (object)\n  (:documentation "Computes the area of an OBJECT.\nOBJECT can be any geometric shape."))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in generic function documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," A general description of what the function does."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arguments:"})," Describe the general meaning of each argument."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"37-documenting-methods-defmethod",children:["3.7 Documenting Methods (",(0,t.jsx)(n.code,{children:"defmethod"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Method documentation should describe the specific behavior of the method for the given argument types."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defmethod area ((r rectangle))\n  "Computes the area of a RECTANGLE by multiplying its width and height."\n  (* (rectangle-width r) (rectangle-height r)))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in method documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Specific behavior:"})," Describe what the method does for the given argument types."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Specializations:"})," Clearly indicate the types of the specialized arguments."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"38-documenting-structures-defstruct",children:["3.8 Documenting Structures (",(0,t.jsx)(n.code,{children:"defstruct"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"Structure documentation should describe the purpose of the structure and the meaning of its fields."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defstruct point\n  (x 0)\n  (y 0)\n  (:documentation "Represents a point in 2D space.\nThe X field stores the x-coordinate.\nThe Y field stores the y-coordinate."))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Key elements to include in structure documentation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," A description of what the structure represents."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fields:"})," Describe each field, including its name, type (if applicable), and purpose."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By following these guidelines, you can write clear, concise, and informative documentation for your Common Lisp code. This will make your code easier to understand, maintain, and use. The next section will cover style and best practices for writing effective documentation."}),"\n",(0,t.jsx)(n.h2,{id:"4-style-and-best-practices",children:"4. Style and Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"This section outlines style guidelines and best practices for writing effective documentation strings in Common Lisp. Consistent and well-written documentation significantly improves code maintainability and usability."}),"\n",(0,t.jsx)(n.h3,{id:"41-writing-clear-and-concise-documentation",children:"4.1 Writing Clear and Concise Documentation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Be brief and to the point:"})," Avoid unnecessary jargon or overly verbose explanations. Get straight to the purpose of the documented entity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use simple language:"})," Use clear and straightforward language that is easy to understand, even for those who are not intimately familiar with the code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:'Focus on the "what" and "why":'})," Explain what the entity does and why it exists. Don't just rephrase the code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use complete sentences:"})," Write grammatically correct and complete sentences. This improves readability and professionalism."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Avoid ambiguity:"})," Be precise in your descriptions to avoid any confusion or misinterpretations."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"42-using-consistent-formatting",children:"4.2 Using Consistent Formatting"}),"\n",(0,t.jsx)(n.p,{children:"Consistent formatting makes documentation easier to read and parse."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Indentation:"})," Indent docstrings consistently with the surrounding code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Line breaks:"})," Use line breaks to improve readability, especially for longer docstrings. Aim for lines no longer than 80 characters."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capitalization:"})," Capitalize the first letter of the first sentence of a docstring."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Punctuation:"})," Use proper punctuation, including periods at the end of sentences."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"43-documenting-parameters-return-values-and-side-effects",children:"4.3 Documenting Parameters, Return Values, and Side Effects"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters:"})," Clearly describe each parameter, including its type (if applicable), purpose, and any constraints or special considerations. Use a consistent format for parameter descriptions. A common convention is to mention parameter types in parentheses."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun process-data (data (filename string))\n  "Processes the given DATA.\nDATA (a list) is the data to be processed.\nFILENAME (a string) is the name of the file to write the results to."\n  ; ...\n)\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return values:"})," Explicitly state what the function or macro returns and under what conditions. If multiple values are returned, describe each one."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun divide (x y)\n  "Divides X by Y.\nReturns two values: the quotient and the remainder.\nSignals an error if Y is zero."\n  (if (zerop y)\n      (error "Division by zero.")\n      (values (floor x y) (rem x y))))\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Side effects:"})," Document any side effects the entity has, such as modifying global variables, performing I/O, or changing the state of objects."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun write-to-log (message)\n  "Writes MESSAGE to the log file.\nSide effects: Appends MESSAGE to the log file."\n  ; ...\n)\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"44-examples-of-good-documentation",children:"4.4 Examples of Good Documentation"}),"\n",(0,t.jsx)(n.p,{children:"Here are some more examples of well-written documentation strings:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Function:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defun string-upcase-first (string)\n  "Converts the first character of STRING to uppercase.\nSTRING (a string) is the input string.\nReturns a new string with the first character uppercased.\nReturns STRING unchanged if it is empty."\n  (if (zerop (length string))\n      string\n      (concatenate \'string (string-upcase (subseq string 0 1)) (subseq string 1))))\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Macro:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defmacro with-open-file-for-output ((stream pathname &rest options) &body body)\n  "Opens a file for output, executes BODY forms, and then closes the file.\nSTREAM (a symbol) is the variable to which the file stream will be bound.\nPATHNAME (a string or pathname) is the path to the file.\nOPTIONS are keyword arguments passed to OPEN.\nExpands to a WITH-OPEN-FILE form."\n  `(with-open-file (,stream ,pathname :direction :output ,@options)\n     ,@body))\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Class:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'(defclass point ()\n  ((x :initarg :x :accessor point-x)\n   (y :initarg :y :accessor point-y))\n  (:documentation "Represents a point in a 2D Cartesian coordinate system.\nThe X slot stores the x-coordinate (a number).\nThe Y slot stores the y-coordinate (a number)."))\n'})}),"\n",(0,t.jsx)(n.p,{children:"By adhering to these style guidelines and best practices, you can create high-quality documentation that will make your Common Lisp code more accessible and maintainable. The next section will briefly mention some tools and utilities that can be used for generating documentation from these docstrings."}),"\n",(0,t.jsx)(n.h2,{id:"5-tools-and-utilities",children:"5. Tools and Utilities"}),"\n",(0,t.jsx)(n.p,{children:"This section provides a brief overview of tools and utilities that can be used to generate documentation from the docstrings you've written in your Common Lisp code."}),"\n",(0,t.jsx)(n.h3,{id:"51-available-systems-for-generating-documentation",children:"5.1 Available Systems for Generating Documentation"}),"\n",(0,t.jsxs)(n.p,{children:["There are different options to choose. Please check the ",(0,t.jsx)(n.a,{href:"https://github.com/CodyReichert/awesome-cl?tab=readme-ov-file#documentation-builders",children:"Awesome-CL"})," section on Documentation Builders for the latest recommendations."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Staple - a tool to generate documentation pages using an HTML template. Uses the existing README, adds docstrings, crossreferences and links to the CLHS. zlib."}),"\n",(0,t.jsx)(n.li,{children:"mgl-pax - Exploratory programming environment and documentation generator. one may accomplish similar effects as with Literate Programming, but documentation is generated from code, not vice versa. Code is first, code must look pretty, documentation is code. MIT."}),"\n",(0,t.jsx)(n.li,{children:"sphinxcontrib-cldomain - Extending Sphinx to cover Common Lisp. To build documentation with the same ease as sphinx would a Python project. GPL3 crossreferences, links to the CLHS, symbol index, search, and all Sphinx features."}),"\n",(0,t.jsx)(n.li,{children:"Codex - A beautiful documentation system for Common Lisp. MIT."}),"\n",(0,t.jsxs)(n.li,{children:["See also the ",(0,t.jsx)(n.a,{href:"https://github.com/CodyReichert/awesome-cl?tab=readme-ov-file#literate-programming",children:"Literate Programming"})," section in the ",(0,t.jsx)(n.a,{href:"https://github.com/CodyReichert/awesome-cl",children:"Awesome-CL"})," page."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>r});var t=i(7294);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);