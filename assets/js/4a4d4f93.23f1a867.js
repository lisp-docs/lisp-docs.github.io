"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[6830],{288:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>m});var n=o(5893),i=o(1151);const a={sidebar_position:2.1},s="Motivation",r={id:"tutorial/motivation",title:"Motivation",description:"Why Learn Common Lisp?",source:"@site/docs/tutorial/motivation.md",sourceDirName:"tutorial",slug:"/tutorial/motivation",permalink:"/docs/tutorial/motivation",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/motivation.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:2.1,frontMatter:{sidebar_position:2.1},sidebar:"tutorialSidebar",previous:{title:"Documenting your Code",permalink:"/docs/tutorial/documentation"},next:{title:"Common Lisp Implementations",permalink:"/docs/tutorial/using-cl-implementation"}},l={},m=[{value:"Why Learn Common Lisp?",id:"why-learn-common-lisp",level:2}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"motivation",children:"Motivation"}),"\n",(0,n.jsx)(t.h2,{id:"why-learn-common-lisp",children:"Why Learn Common Lisp?"}),"\n",(0,n.jsx)(t.p,{children:"In a world dominated by mainstream programming languages, you might ask, \"Why should I learn Common Lisp?\" It's a fair question. Common Lisp isn't the trendiest language, but it offers a unique blend of power, expressiveness, and timeless concepts that make it a worthwhile investment for any serious programmer."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Here's why you should consider learning Common Lisp:"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Dynamic and Interactive Development:"}),' Common Lisp\'s dynamic nature and interactive REPL (Read-Eval-Print Loop) enable a highly iterative development process. You can write code, evaluate it immediately, and make changes on the fly without recompilation. This fosters experimentation and rapid prototyping. This is a very strong contrast to the "Compile and Run" style of programming most other languages have. After programming in a REPL driven way, you will realize just how fast you can develop correct working programs compared to almost every other language.']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Powerful Object System (CLOS):"})," The Common Lisp Object System (CLOS) is a highly flexible and powerful object-oriented programming system. It supports multiple inheritance, multimethods (methods dispatched on the types of multiple arguments), and metaobject protocols (MOP), which allow you to customize the object system itself. CLOS is extremely powerful, and if you use it properly, you will even wonder how is it that other languages like Java, which are Object Oriented focused, are so limiting and primitive in their capabilitis. Using CLOS can lead to effective, succint, and powerful programs. In my opinion, this is ",(0,n.jsx)(t.strong,{children:"one of the most underrated and convincing arguments"})," to use Common Lisp over any other programming language."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Mature and Stable:"})," Common Lisp has a long history, dating back to the late 1950s. This means it's a mature and stable language with well-defined standards and implementations. While it may not be the newest language on the block, it has stood the test of time and continues to be used in demanding applications. You can easily run code from the 1970s without much modifications. That's 54 years ago at the time of writing. Compare that to python, where my 10 year old libraries are incompatible with python 3 because of breaking changes. If you want to write code ",(0,n.jsx)(t.strong,{children:"which will work"})," in another 50 years, Common Lisp will do it. Any long term project should seriously consider using Common Lisp. While not the most popular language, it will most certainly be used in production systems in another 50 years, which is not a claim that can be made by most other ",(0,n.jsx)(t.em,{children:"fad"})," languages which come and go as soon as another ",(0,n.jsx)(t.em,{children:"fad"})," shows up."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Metaprogramming Power:"})," Lisp's macro system is unmatched in its ability to manipulate code at compile time. This allows you to extend the language itself, create domain-specific languages (DSLs), and implement powerful abstractions that are simply not possible in many other languages. With macros, you're not just writing programs; you're shaping the language to fit your problem. This can potentially drastically reduce the amount of code you write and make it much easier to reason about your programs."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Unparalleled Expressiveness:"})," Lisp's syntax, based on symbolic expressions (s-expressions), allows for extremely concise and elegant code. It's often said that you can express complex ideas in fewer lines of Lisp than in most other languages. This leads to faster development cycles and more maintainable code. Once you learn to edit code based on s-expressions, the speed of at which code can be restructured and reasoned about is also unparalleled in non-s-expression languages. S-Expressions also make it very easy to understand properly formatted and indented code because the indentation reveals the structure of the code. This is something usually not understood by non Lisp programmers until they experience it themselves."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Extensibility and Stability:"})," The nature of the language makes it so that most new programming ideas can be implemented in Common Lisp without the need of a change in the compilers. This makes it so that multiple competing libraries can implement functionality which in other languages would only be up to the language designer. This in turn allows for the best of the competing ideas to succeed, for cross polination of ideas between libraries, and for quick adoption of new ideas. All of these things are simply not possible in most other languages. Not only that, but because of the ANSI Standard, Common Lisp is ",(0,n.jsx)(t.strong,{children:"stable"}),". This means that none of these changes and new functionality will break backward compatibility. Furthermore, for the rare instances where new functionality cannot be implemented on top of the language, many competing implementations can have different approaches, which repeats the process of allowing for competition and cross polination. Before you think this is something bad because it means code will be implementation dependent (which is the case for almost every other language out there, so this by itself is a non argument), consider tha once the competition settles for what the best approach for novel ideas are, ",(0,n.jsx)(t.code,{children:"trivial"})," libraries usually follow very quickly, which make writing code implementation-independent. So basically Common Lisp delivers the best of both worlds, fast implementation of novel ideas, backwards compatibility, and eventually implementation independent code via ",(0,n.jsx)(t.code,{children:"trivial"})," libraries which will make your code stand the test of time. No other language that I know of has this benefit, rather they mostly deal with the tradeoff between implementation of new ideas, and making code backwards compatible when changes need to be made."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Focus on Concepts:"})," Learning Lisp allows you to think differently about programming. While all the usual programming facilities of C-like procedural programming are available, it allows for many other fundamental concepts like recursion, symbolic computation, and metaprogramming, which can make you a better programmer in any language."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"A Different Perspective:"})," In a world of C-style syntax and object-oriented dogma, Lisp offers a refreshing and unique perspective on programming. It challenges conventional wisdom and encourages creative problem-solving."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Practical Applications:"})," Common Lisp is used in production in all sorts of fields. While it is true, that large libraries for some repetitive work are not as common as in some other languages, the speed to develop a custom solution can usually dwarf the need for those libraries to begin with. For any standard functionality, there are usually multiple Common Lisp libraries, and the community is usually very responsive in accepting changes and contributions."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"If you're looking for a language that will challenge you, expand your programming horizons, and provide you with powerful tools for solving complex problems, then Common Lisp is worth exploring. Dive in and discover the power and elegance of Lisp!"})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,o)=>{o.d(t,{Z:()=>r,a:()=>s});var n=o(7294);const i={},a=n.createContext(i);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);