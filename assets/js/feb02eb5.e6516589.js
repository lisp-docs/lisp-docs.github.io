"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[3965],{193:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var i=n(5893),t=n(1151);const a={sidebar_position:2},c="MetaObject Protocol",o={id:"tutorial/advanced_topics/mop",title:"MetaObject Protocol",description:"This article needs to be checked!.",source:"@site/docs/tutorial/advanced_topics/mop.md",sourceDirName:"tutorial/advanced_topics",slug:"/tutorial/advanced_topics/mop",permalink:"/docs/tutorial/advanced_topics/mop",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/advanced_topics/mop.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Style Guide",permalink:"/docs/tutorial/advanced_topics/style"},next:{title:"Index",permalink:"/docs/tutorial/index"}},l={},d=[{value:"Introduction to the Metaobject Protocol (MOP) in Common Lisp",id:"introduction-to-the-metaobject-protocol-mop-in-common-lisp",level:2},{value:"1. Introduction to Metaobjects",id:"1-introduction-to-metaobjects",level:2},{value:"1.1 What are Metaobjects?",id:"11-what-are-metaobjects",level:3},{value:"1.2 The Relationship Between Objects and Metaobjects",id:"12-the-relationship-between-objects-and-metaobjects",level:3},{value:"1.3 The Concept of Reification",id:"13-the-concept-of-reification",level:3},{value:"2. Standard Metaobject Classes",id:"2-standard-metaobject-classes",level:2},{value:"2.1 <code>standard-class</code>: The Default Metaclass for User-Defined Classes",id:"21-standard-class-the-default-metaclass-for-user-defined-classes",level:3},{value:"2.2 <code>standard-method</code>: The Default Metaclass for Methods",id:"22-standard-method-the-default-metaclass-for-methods",level:3},{value:"2.3 <code>standard-generic-function</code>: The Default Metaclass for Generic Functions",id:"23-standard-generic-function-the-default-metaclass-for-generic-functions",level:3},{value:"2.4 Other Important Metaobject Classes",id:"24-other-important-metaobject-classes",level:3},{value:"3. Basic MOP Operations",id:"3-basic-mop-operations",level:2},{value:"3.1 <code>class-of</code>: Getting the Class of an Object",id:"31-class-of-getting-the-class-of-an-object",level:3},{value:"3.2 <code>class-name</code>: Getting the Name of a Class",id:"32-class-name-getting-the-name-of-a-class",level:3},{value:"3.3 <code>find-class</code>: Finding a Class Object by Name",id:"33-find-class-finding-a-class-object-by-name",level:3},{value:"3.4 <code>slot-value</code>: Accessing Slot Values (Even for Metaobjects)",id:"34-slot-value-accessing-slot-values-even-for-metaobjects",level:3},{value:"4. Customizing Class Creation",id:"4-customizing-class-creation",level:2},{value:"4.1 Defining Custom Metaclasses using <code>defclass</code>",id:"41-defining-custom-metaclasses-using-defclass",level:3},{value:"4.2 Customizing <code>initialize-instance</code> for Metaclasses",id:"42-customizing-initialize-instance-for-metaclasses",level:3},{value:"4.3 Adding or Modifying Slots During Class Creation",id:"43-adding-or-modifying-slots-during-class-creation",level:3},{value:"5. Customizing Method Dispatch",id:"5-customizing-method-dispatch",level:2},{value:"5.1 Method Combinations and Their Metaobject Representation",id:"51-method-combinations-and-their-metaobject-representation",level:3},{value:"5.2 Defining Custom Method Combinations",id:"52-defining-custom-method-combinations",level:3},{value:"5.3 Customizing Method Selection",id:"53-customizing-method-selection",level:3},{value:"6. Introspection and Reflection in CLOS",id:"6-introspection-and-reflection-in-clos",level:2},{value:"6.1 Inspecting Class Structure (Slots, Superclasses)",id:"61-inspecting-class-structure-slots-superclasses",level:3},{value:"6.2 Examining Method Definitions and Specializers",id:"62-examining-method-definitions-and-specializers",level:3},{value:"6.3 Working with Generic Function Metaobjects",id:"63-working-with-generic-function-metaobjects",level:3},{value:"7. Examples and Advanced Techniques using the MOP",id:"7-examples-and-advanced-techniques-using-the-mop",level:2},{value:"7.1 Implementing a Simple Object Database",id:"71-implementing-a-simple-object-database",level:3},{value:"7.2 Implementing Aspects Using the MOP",id:"72-implementing-aspects-using-the-mop",level:3},{value:"7.3 Creating a New Object Model on Top of CLOS",id:"73-creating-a-new-object-model-on-top-of-clos",level:3}];function r(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"metaobject-protocol",children:"MetaObject Protocol"}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsxs)(s.p,{children:["This article ",(0,i.jsx)(s.strong,{children:"needs to be checked!"}),".\nPlease help contribute by checking it and making changes in ",(0,i.jsx)(s.a,{href:"https://github.com/lisp-docs/lisp-docs.github.io",children:"our repository"}),' or by clicking on the "Edit this page" link below.']})}),"\n",(0,i.jsx)(s.h2,{id:"introduction-to-the-metaobject-protocol-mop-in-common-lisp",children:"Introduction to the Metaobject Protocol (MOP) in Common Lisp"}),"\n",(0,i.jsx)(s.p,{children:"The Metaobject Protocol (MOP) is a powerful and advanced feature of the Common Lisp Object System (CLOS) that allows you to introspect and customize the behavior of the object system itself. It provides a standardized interface for accessing and modifying the internal workings of classes, methods, generic functions, and other core components of CLOS."}),"\n",(0,i.jsx)(s.p,{children:"Think of it this way: CLOS defines how objects behave, while the MOP defines how CLOS itself behaves. This meta-level control allows for incredibly flexible and powerful metaprogramming techniques, enabling you to tailor CLOS to specific needs, implement advanced object-oriented features, or even create entirely new object models on top of CLOS."}),"\n",(0,i.jsx)(s.p,{children:"This tutorial will introduce you to the fundamental concepts of the MOP, including metaobjects, standard metaobject classes, and the key protocols for customizing CLOS behavior."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Key Concepts:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Metaobjects:"})," Objects that represent the components of CLOS (e.g., classes, methods, generic functions)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Standard Metaobject Classes:"})," Predefined classes for metaobjects (e.g., ",(0,i.jsx)(s.code,{children:"standard-class"}),", ",(0,i.jsx)(s.code,{children:"standard-method"}),", ",(0,i.jsx)(s.code,{children:"standard-generic-function"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Metaobject Protocols:"})," Standardized interfaces for accessing and manipulating metaobjects."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Introspection:"})," Examining the structure and behavior of CLOS entities."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Customization:"})," Modifying the default behavior of CLOS."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Table of Contents:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"1. Introduction to Metaobjects:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"What are metaobjects?"}),"\n",(0,i.jsx)(s.li,{children:"The relationship between objects and metaobjects."}),"\n",(0,i.jsx)(s.li,{children:"The concept of reification."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"2. Standard Metaobject Classes:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"standard-class"}),": The default metaclass for user-defined classes."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"standard-method"}),": The default metaclass for methods."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"standard-generic-function"}),": The default metaclass for generic functions."]}),"\n",(0,i.jsxs)(s.li,{children:["Other important metaobject classes (e.g., ",(0,i.jsx)(s.code,{children:"slot-definition"}),", ",(0,i.jsx)(s.code,{children:"method-combination"}),")."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"3. Basic MOP Operations:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"class-of"}),": Getting the class of an object."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"class-name"}),": Getting the name of a class."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"find-class"}),": Finding a class object by name."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"slot-value"}),": Accessing slot values (even for metaobjects)."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4. Customizing Class Creation:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Defining custom metaclasses using ",(0,i.jsx)(s.code,{children:"defclass"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Customizing ",(0,i.jsx)(s.code,{children:"initialize-instance"})," for metaclasses."]}),"\n",(0,i.jsx)(s.li,{children:"Adding or modifying slots during class creation."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"5. Customizing Method Dispatch:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Method combinations and their metaobject representation."}),"\n",(0,i.jsx)(s.li,{children:"Defining custom method combinations."}),"\n",(0,i.jsx)(s.li,{children:"Customizing method selection."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"6. Introspection and Reflection:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Inspecting class structure (slots, superclasses)."}),"\n",(0,i.jsx)(s.li,{children:"Examining method definitions and specializers."}),"\n",(0,i.jsx)(s.li,{children:"Working with generic function metaobjects."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"7. Examples and Advanced Techniques:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Implementing a simple object database."}),"\n",(0,i.jsx)(s.li,{children:"Implementing aspects using the MOP."}),"\n",(0,i.jsx)(s.li,{children:"Creating a new object model on top of CLOS."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This tutorial will provide clear explanations and practical examples to help you understand the MOP and its capabilities. It will empower you to leverage the full power of CLOS and perform advanced metaprogramming in Common Lisp. It\u2019s important to note that the MOP is an advanced topic and requires a solid understanding of CLOS itself."}),"\n",(0,i.jsx)(s.h2,{id:"1-introduction-to-metaobjects",children:"1. Introduction to Metaobjects"}),"\n",(0,i.jsxs)(s.p,{children:["The Metaobject Protocol (MOP) provides a way to programmatically access and manipulate the structure and behavior of the Common Lisp Object System (CLOS) itself. This is achieved through ",(0,i.jsx)(s.em,{children:"metaobjects"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"11-what-are-metaobjects",children:"1.1 What are Metaobjects?"}),"\n",(0,i.jsxs)(s.p,{children:["In standard object-oriented programming, ",(0,i.jsx)(s.em,{children:"objects"})," are instances of ",(0,i.jsx)(s.em,{children:"classes"}),". A class defines the structure (slots) and behavior (methods) of its instances. In CLOS, even classes, methods, and generic functions are themselves objects. These objects that represent the components of the object system are called ",(0,i.jsx)(s.em,{children:"metaobjects"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Think of it this way:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Objects:"})," Represent data and have behavior."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Metaobjects:"})," Represent the ",(0,i.jsx)(s.em,{children:"definitions"})," and ",(0,i.jsx)(s.em,{children:"behavior"})," of objects, classes, methods and generic functions. They describe how the object system works."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"For example:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," is a metaobject that describes the structure and behavior of its instances (regular objects)."]}),"\n",(0,i.jsxs)(s.li,{children:["A ",(0,i.jsx)(s.em,{children:"method"})," is a metaobject that describes a specific behavior of a generic function for a particular set of argument specializers."]}),"\n",(0,i.jsxs)(s.li,{children:["A ",(0,i.jsx)(s.em,{children:"generic function"})," is a metaobject that dispatches method calls based on the classes of the arguments."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"12-the-relationship-between-objects-and-metaobjects",children:"1.2 The Relationship Between Objects and Metaobjects"}),"\n",(0,i.jsxs)(s.p,{children:["The relationship between objects and metaobjects is a ",(0,i.jsx)(s.em,{children:"meta-level"})," relationship. An object is an ",(0,i.jsx)(s.em,{children:"instance"})," of a class. A class is an ",(0,i.jsx)(s.em,{children:"instance"})," of a ",(0,i.jsx)(s.em,{children:"metaclass"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Here\u2019s an analogy:"}),"\n",(0,i.jsx)(s.p,{children:"Imagine you have a house (an object). The blueprint for the house is like a class. But who designed the blueprint? An architect. The architect\u2019s design principles and tools are like a metaclass."}),"\n",(0,i.jsx)(s.p,{children:"In CLOS:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"(make-instance 'my-class)"})," creates an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"defclass"})," creates a ",(0,i.jsx)(s.em,{children:"class"})," (which is a metaobject)."]}),"\n",(0,i.jsxs)(s.li,{children:["The default metaclass (",(0,i.jsx)(s.code,{children:"standard-class"}),") defines how classes are created and behave."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"A class is an instance of a meta-class, therefore we can say that a meta-class is a class whose instances are classes."}),"\n",(0,i.jsx)(s.h3,{id:"13-the-concept-of-reification",children:"1.3 The Concept of Reification"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Reification"})," is the process of making something that was previously implicit or abstract explicit and accessible as a data structure. In the context of the MOP, reification means that the components of CLOS (classes, methods, generic functions, etc.) are made available as first-class objects (metaobjects) that can be manipulated programmatically."]}),"\n",(0,i.jsx)(s.p,{children:"Before the MOP, these components were part of the implementation of CLOS and were not directly accessible to the programmer. The MOP reified these components, making them available as objects that can be inspected, modified, and even replaced."}),"\n",(0,i.jsx)(s.p,{children:"This reification allows for powerful metaprogramming techniques, such as:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Customizing class creation:"})," You can define custom metaclasses to control how classes are created, adding or modifying slots, changing inheritance behavior, and more."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Customizing method dispatch:"})," You can define custom method combinations or alter the method selection process."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Implementing new object models:"})," You can build entirely new object systems on top of CLOS, with different inheritance mechanisms, dispatch strategies, and other features."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example:"})}),"\n",(0,i.jsxs)(s.p,{children:["When you define a class using ",(0,i.jsx)(s.code,{children:"defclass"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age)))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Behind the scenes, CLOS uses the ",(0,i.jsx)(s.code,{children:"standard-class"})," metaclass (by default) to create a class object representing ",(0,i.jsx)(s.code,{children:"person"}),". This class object is a metaobject that contains information about the class, such as its name, its superclasses (in this case, ",(0,i.jsx)(s.code,{children:"standard-object"}),"), its slots, and its methods. The MOP allows you to access and manipulate this class object directly."]}),"\n",(0,i.jsx)(s.p,{children:"In summary, metaobjects are objects that represent the components of CLOS. Reification makes these components accessible to the programmer, enabling powerful metaprogramming. This introduction lays the groundwork for understanding how to use the MOP to customize and extend CLOS. In the next section, we will explore the standard metaobject classes."}),"\n",(0,i.jsx)(s.h2,{id:"2-standard-metaobject-classes",children:"2. Standard Metaobject Classes"}),"\n",(0,i.jsx)(s.p,{children:"This section introduces the most important standard metaobject classes in CLOS. These classes represent the core components of the object system and provide the foundation for customization through the MOP."}),"\n",(0,i.jsxs)(s.h3,{id:"21-standard-class-the-default-metaclass-for-user-defined-classes",children:["2.1 ",(0,i.jsx)(s.code,{children:"standard-class"}),": The Default Metaclass for User-Defined Classes"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"standard-class"})," is the default metaclass for classes defined using ",(0,i.jsx)(s.code,{children:"defclass"})," when no explicit metaclass is specified. It provides the standard behavior for class creation, inheritance, and instance creation."]}),"\n",(0,i.jsx)(s.p,{children:"When you define a class like this:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age)))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["CLOS creates an instance of ",(0,i.jsx)(s.code,{children:"standard-class"})," to represent the ",(0,i.jsx)(s.code,{children:"person"})," class. This instance contains information about:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The class name (",(0,i.jsx)(s.code,{children:"person"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["The superclasses (in this case, ",(0,i.jsx)(s.code,{children:"standard-object"})," by default)."]}),"\n",(0,i.jsxs)(s.li,{children:["The slots (",(0,i.jsx)(s.code,{children:"name"})," and ",(0,i.jsx)(s.code,{children:"age"}),")."]}),"\n",(0,i.jsx)(s.li,{children:"The class precedence list (CPL), which determines the order in which methods are applied."}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["You can access the class object itself using ",(0,i.jsx)(s.code,{children:"find-class"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(find-class 'person) ; Returns the class object for PERSON.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You can check if an object is an instance of ",(0,i.jsx)(s.code,{children:"standard-class"})," using ",(0,i.jsx)(s.code,{children:"typep"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(typep (find-class 'person) 'standard-class) ; Returns T\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"22-standard-method-the-default-metaclass-for-methods",children:["2.2 ",(0,i.jsx)(s.code,{children:"standard-method"}),": The Default Metaclass for Methods"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"standard-method"})," is the default metaclass for methods defined using ",(0,i.jsx)(s.code,{children:"defmethod"}),". It represents a specific implementation of a generic function for a particular set of argument specializers."]}),"\n",(0,i.jsx)(s.p,{children:"When you define a method like this:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defmethod greet ((p person))\n  (format t "Hello, ~a!~%" (person-name p)))\n'})}),"\n",(0,i.jsxs)(s.p,{children:["CLOS creates an instance of ",(0,i.jsx)(s.code,{children:"standard-method"})," to represent this method. This instance contains information about:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The generic function it belongs to (",(0,i.jsx)(s.code,{children:"greet"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["The specializers (in this case, ",(0,i.jsx)(s.code,{children:"(person)"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["The method's body (the ",(0,i.jsx)(s.code,{children:"format"})," expression)."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["You can access the method object through the generic function\u2019s method list using ",(0,i.jsx)(s.code,{children:"method-combination"})," and ",(0,i.jsx)(s.code,{children:"compute-applicable-methods"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defgeneric greet (object))\n(defmethod greet ((p person))\n  (format t "Hello, ~a!~%" (person-name p)))\n\n(let ((gf (fdefinition \'greet))) ; get the generic function object\n    (print (method-combination gf)) ; prints STANDARD\n    (print (compute-applicable-methods gf (list (make-instance \'person :name "Bob")))) ; prints a list containing the method\n)\n'})}),"\n",(0,i.jsxs)(s.h3,{id:"23-standard-generic-function-the-default-metaclass-for-generic-functions",children:["2.3 ",(0,i.jsx)(s.code,{children:"standard-generic-function"}),": The Default Metaclass for Generic Functions"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"standard-generic-function"})," is the default metaclass for generic functions defined using ",(0,i.jsx)(s.code,{children:"defgeneric"}),". It manages the dispatch of method calls based on the classes of the arguments."]}),"\n",(0,i.jsx)(s.p,{children:"When you define a generic function like this:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defgeneric greet (object))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["CLOS creates an instance of ",(0,i.jsx)(s.code,{children:"standard-generic-function"}),". This instance contains information about:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The generic function's name (",(0,i.jsx)(s.code,{children:"greet"}),")."]}),"\n",(0,i.jsx)(s.li,{children:"The lambda list (the parameter list)."}),"\n",(0,i.jsxs)(s.li,{children:["The method combination (by default, ",(0,i.jsx)(s.code,{children:"standard"}),")."]}),"\n",(0,i.jsx)(s.li,{children:"The methods associated with the generic function."}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["You can access the generic function object using ",(0,i.jsx)(s.code,{children:"fdefinition"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(fdefinition 'greet) ; Returns the generic function object for GREET.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You can check if an object is a generic function using ",(0,i.jsx)(s.code,{children:"fboundp"})," and ",(0,i.jsx)(s.code,{children:"functionp"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(fboundp 'greet) ; Returns T\n(functionp (fdefinition 'greet)) ; Returns T\n"})}),"\n",(0,i.jsx)(s.h3,{id:"24-other-important-metaobject-classes",children:"2.4 Other Important Metaobject Classes"}),"\n",(0,i.jsx)(s.p,{children:"Besides the core metaobject classes mentioned above, there are other important metaobject classes that play a role in CLOS:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"slot-definition"})}),": Represents a slot in a class. Instances of ",(0,i.jsx)(s.code,{children:"standard-class"})," have a list of ",(0,i.jsx)(s.code,{children:"slot-definition"})," objects that describe the slots of the class."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"method-combination"})}),": Represents a method combination type (e.g., ",(0,i.jsx)(s.code,{children:"standard"}),", ",(0,i.jsx)(s.code,{children:"+"}),", ",(0,i.jsx)(s.code,{children:"append"}),"). Method combinations define how methods are combined when multiple methods are applicable to a generic function call."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"These metaobject classes are essential for customizing the behavior of CLOS at a deeper level. By understanding their structure and behavior, you can implement advanced metaprogramming techniques."}),"\n",(0,i.jsx)(s.p,{children:"This section introduced the standard metaobject classes in CLOS. Understanding these classes is crucial for working with the MOP. The next sections will cover how to use the MOP to customize class creation, method dispatch, and other aspects of CLOS."}),"\n",(0,i.jsx)(s.h2,{id:"3-basic-mop-operations",children:"3. Basic MOP Operations"}),"\n",(0,i.jsx)(s.p,{children:"This section covers some fundamental operations for working with metaobjects in Common Lisp. These operations allow you to introspect and access information about classes, objects, and their components."}),"\n",(0,i.jsxs)(s.h3,{id:"31-class-of-getting-the-class-of-an-object",children:["3.1 ",(0,i.jsx)(s.code,{children:"class-of"}),": Getting the Class of an Object"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"class-of"})," function returns the class of an object. This is a basic but essential MOP operation."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defclass person ()\n  ((name :initarg :name :accessor person-name)))\n\n(let ((p (make-instance \'person :name "Alice")))\n  (class-of p)) ; Returns the class object for PERSON.\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The result of ",(0,i.jsx)(s.code,{children:"(class-of p)"})," is the ",(0,i.jsx)(s.em,{children:"class object"})," itself, not the symbol ",(0,i.jsx)(s.code,{children:"'person"}),". You can compare it using ",(0,i.jsx)(s.code,{children:"eq"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(eq (class-of p) (find-class 'person)) ; Returns T\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"32-class-name-getting-the-name-of-a-class",children:["3.2 ",(0,i.jsx)(s.code,{children:"class-name"}),": Getting the Name of a Class"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"class-name"})," function returns the name of a class (as a symbol)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass person () ())\n\n(class-name (find-class 'person)) ; Returns PERSON\n"})}),"\n",(0,i.jsxs)(s.p,{children:["If the class is anonymous, the function might return ",(0,i.jsx)(s.code,{children:"nil"}),"."]}),"\n",(0,i.jsxs)(s.h3,{id:"33-find-class-finding-a-class-object-by-name",children:["3.3 ",(0,i.jsx)(s.code,{children:"find-class"}),": Finding a Class Object by Name"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"find-class"})," function takes a symbol representing a class name and returns the corresponding class object."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass person () ())\n\n(find-class 'person) ; Returns the class object for PERSON.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["If the class is not found, ",(0,i.jsx)(s.code,{children:"find-class"})," returns ",(0,i.jsx)(s.code,{children:"nil"}),". You can specify a second optional argument which is a boolean value indicating whether an error should be signaled if the class is not found. The default is ",(0,i.jsx)(s.code,{children:"t"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(find-class 'non-existent-class) ; Signals a simple error\n(find-class 'non-existent-class nil) ; Returns nil\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"find-class"})," searches the current ",(0,i.jsx)(s.em,{children:"class environment"}),", which is influenced by packages. By default, it searches the current package."]}),"\n",(0,i.jsxs)(s.h3,{id:"34-slot-value-accessing-slot-values-even-for-metaobjects",children:["3.4 ",(0,i.jsx)(s.code,{children:"slot-value"}),": Accessing Slot Values (Even for Metaobjects)"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"slot-value"})," function is used to access the value of a slot in an object. Importantly, it can also be used to access slots of ",(0,i.jsx)(s.em,{children:"metaobjects"}),". This is a key aspect of the MOP, as it allows you to inspect and manipulate the internal state of classes, methods, and generic functions."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass person ()\n  ((name :initarg :name :accessor person-name)))\n\n(let ((p (make-instance 'person :name \"Bob\")))\n  (slot-value p 'name)) ; Returns \"Bob\"\n\n; Accessing slots of a metaobject (class):\n(let ((person-class (find-class 'person)))\n  (slot-value person-class 'name)) ; This would signal an error, because the class object does not have a slot named name\n\n(defclass my-class ()\n    ((my-slot :initform 42)))\n\n(let ((my-class-object (find-class 'my-class)))\n    (print (slot-value my-class-object 'slots)) ; prints a list of slot definitions\n    (let ((my-slot-definition (first (slot-value my-class-object 'slots))))\n        (print (slot-value my-slot-definition 'name)) ; prints MY-SLOT\n        (print (slot-value my-slot-definition 'initform)) ; prints 42\n    )\n)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["In the last example, we accessed the ",(0,i.jsx)(s.code,{children:"slots"})," slot of the ",(0,i.jsx)(s.code,{children:"my-class"})," class object. This slot contains a list of ",(0,i.jsx)(s.code,{children:"slot-definition"})," metaobjects, which themselves have slots like ",(0,i.jsx)(s.code,{children:"name"})," and ",(0,i.jsx)(s.code,{children:"initform"}),". This demonstrates how ",(0,i.jsx)(s.code,{children:"slot-value"})," can be used to navigate the metaobject hierarchy."]}),"\n",(0,i.jsxs)(s.p,{children:["It\u2019s important to note that accessing slots of metaobjects directly using ",(0,i.jsx)(s.code,{children:"slot-value"})," can be implementation-dependent. The MOP provides a more portable and standardized way to access metaobject information through ",(0,i.jsx)(s.em,{children:"metaobject protocols"})," (generic functions defined on metaobject classes), which we will cover in later sections. However, ",(0,i.jsx)(s.code,{children:"slot-value"})," remains a useful tool for basic introspection and is often used in MOP implementations."]}),"\n",(0,i.jsxs)(s.p,{children:["These basic MOP operations (",(0,i.jsx)(s.code,{children:"class-of"}),", ",(0,i.jsx)(s.code,{children:"class-name"}),", ",(0,i.jsx)(s.code,{children:"find-class"}),", ",(0,i.jsx)(s.code,{children:"slot-value"}),") provide the foundation for more advanced metaprogramming techniques. They allow you to inspect and understand the structure of your CLOS objects and classes. The following sections will build upon these basics to show you how to customize class creation and method dispatch."]}),"\n",(0,i.jsx)(s.h2,{id:"4-customizing-class-creation",children:"4. Customizing Class Creation"}),"\n",(0,i.jsxs)(s.p,{children:["This section explains how to customize the process of class creation in CLOS using the Metaobject Protocol. This involves defining custom metaclasses and customizing the ",(0,i.jsx)(s.code,{children:"initialize-instance"})," method for these metaclasses."]}),"\n",(0,i.jsxs)(s.h3,{id:"41-defining-custom-metaclasses-using-defclass",children:["4.1 Defining Custom Metaclasses using ",(0,i.jsx)(s.code,{children:"defclass"})]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"metaclass"})," is a class whose instances are classes. You define a custom metaclass using ",(0,i.jsx)(s.code,{children:"defclass"}),", just like defining any other class, but you typically inherit from ",(0,i.jsx)(s.code,{children:"standard-class"})," (or another appropriate metaclass)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass my-metaclass (standard-class)\n  ((extra-info :initarg :extra-info :accessor extra-info)))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["This defines a metaclass called ",(0,i.jsx)(s.code,{children:"my-metaclass"})," with an additional slot called ",(0,i.jsx)(s.code,{children:"extra-info"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["To use a custom metaclass for a class, you specify the ",(0,i.jsx)(s.code,{children:":metaclass"})," option in the ",(0,i.jsx)(s.code,{children:"defclass"})," form:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defclass my-class ()\n  ((a :initarg :a :accessor my-class-a))\n  (:metaclass my-metaclass)\n  (:extra-info "Some metadata"))\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Now, the ",(0,i.jsx)(s.code,{children:"my-class"})," class is an instance of ",(0,i.jsx)(s.code,{children:"my-metaclass"}),", not ",(0,i.jsx)(s.code,{children:"standard-class"}),". You can access the ",(0,i.jsx)(s.code,{children:"extra-info"})," slot of the ",(0,i.jsx)(s.code,{children:"my-class"})," class object:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(slot-value (find-class 'my-class) 'extra-info) ; Returns \"Some metadata\"\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"42-customizing-initialize-instance-for-metaclasses",children:["4.2 Customizing ",(0,i.jsx)(s.code,{children:"initialize-instance"})," for Metaclasses"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"initialize-instance"})," method is called when a new instance of a class is created (including when a new class is created, since classes are instances of metaclasses). By specializing ",(0,i.jsx)(s.code,{children:"initialize-instance"})," on your custom metaclass, you can customize the class creation process."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass my-metaclass (standard-class)\n  ((creation-time :accessor creation-time)))\n\n(defmethod initialize-instance ((class my-metaclass) &rest initargs)\n  (call-next-method) ; Call the standard initialize-instance method\n  (setf (creation-time class) (get-universal-time))\n  class)\n\n(defclass my-class ()\n  ()\n  (:metaclass my-metaclass))\n\n(creation-time (find-class 'my-class)) ; Returns the time when my-class was created.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["In this example, we specialize ",(0,i.jsx)(s.code,{children:"initialize-instance"})," on ",(0,i.jsx)(s.code,{children:"my-metaclass"}),". We first call ",(0,i.jsx)(s.code,{children:"call-next-method"})," to ensure that the standard initialization process is performed. Then, we set the ",(0,i.jsx)(s.code,{children:"creation-time"})," slot of the class object."]}),"\n",(0,i.jsxs)(s.p,{children:["You can use ",(0,i.jsx)(s.code,{children:"&key"})," parameters in the ",(0,i.jsx)(s.code,{children:"initialize-instance"})," method to handle custom options passed to ",(0,i.jsx)(s.code,{children:"defclass"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defclass my-metaclass (standard-class)\n  ((custom-option :initarg :custom-option :accessor custom-option)))\n\n(defmethod initialize-instance ((class my-metaclass) &rest initargs &key custom-option &allow-other-keys)\n  (call-next-method)\n  (when custom-option\n    (setf (custom-option class) custom-option))\n  class)\n\n(defclass my-class ()\n  ()\n  (:metaclass my-metaclass)\n  (:custom-option "A custom value"))\n\n(custom-option (find-class \'my-class)) ; Returns "A custom value"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"43-adding-or-modifying-slots-during-class-creation",children:"4.3 Adding or Modifying Slots During Class Creation"}),"\n",(0,i.jsxs)(s.p,{children:["You can add or modify slots during class creation by manipulating the ",(0,i.jsx)(s.code,{children:"slots"})," slot of the class metaobject within ",(0,i.jsx)(s.code,{children:"initialize-instance"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass my-metaclass (standard-class) ())\n\n(defmethod initialize-instance ((class my-metaclass) &rest initargs)\n    (call-next-method)\n    ; Add a new slot to the class\n    (setf (slot-value class 'slots)\n        (append (slot-value class 'slots)\n                (list (make-instance 'standard-effective-slot-definition\n                                     :name 'added-slot\n                                     :initform 0))))\n    class)\n\n(defclass my-class ()\n    ((original-slot :initform \"foo\"))\n    (:metaclass my-metaclass))\n\n(mapcar #'slot-definition-name (slot-value (find-class 'my-class) 'slots)) ; prints (ORIGINAL-SLOT ADDED-SLOT)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["In this example, we add a new slot named ",(0,i.jsx)(s.code,{children:"added-slot"})," with an ",(0,i.jsx)(s.code,{children:"initform"})," of 0 to the class being created. ",(0,i.jsx)(s.code,{children:"standard-effective-slot-definition"})," is used to create the new slot definition."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Important Considerations:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Modifying the structure of a class after instances have been created can have complex consequences. CLOS provides mechanisms for updating instances, but it's often best to design your classes carefully from the beginning."}),"\n",(0,i.jsx)(s.li,{children:"The MOP is a powerful tool, but it should be used judiciously. Overuse of metaprogramming can make code harder to understand and maintain."}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["This section covered how to customize class creation using custom metaclasses and the ",(0,i.jsx)(s.code,{children:"initialize-instance"})," method. This allows you to exert fine-grained control over the structure and behavior of your classes. The next sections will cover customizing method dispatch and other advanced MOP topics."]}),"\n",(0,i.jsx)(s.h2,{id:"5-customizing-method-dispatch",children:"5. Customizing Method Dispatch"}),"\n",(0,i.jsxs)(s.p,{children:["This section delves into customizing method dispatch in CLOS using the Metaobject Protocol. This primarily involves understanding and manipulating ",(0,i.jsx)(s.em,{children:"method combinations"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"51-method-combinations-and-their-metaobject-representation",children:"5.1 Method Combinations and Their Metaobject Representation"}),"\n",(0,i.jsxs)(s.p,{children:["When a generic function is called, CLOS determines which methods are ",(0,i.jsx)(s.em,{children:"applicable"})," (their specializers match the arguments). If multiple methods are applicable, CLOS uses a ",(0,i.jsx)(s.em,{children:"method combination"})," to determine how the results of these methods are combined."]}),"\n",(0,i.jsxs)(s.p,{children:["The standard method combination is called ",(0,i.jsx)(s.code,{children:"standard"}),". It defines the order in which methods are called (most specific to least specific) and how their results are combined (primary methods are called first, then ",(0,i.jsx)(s.code,{children:"before"})," methods, then ",(0,i.jsx)(s.code,{children:"after"})," methods, and finally ",(0,i.jsx)(s.code,{children:"around"})," methods)."]}),"\n",(0,i.jsxs)(s.p,{children:["Method combinations are themselves represented by metaobjects of class ",(0,i.jsx)(s.code,{children:"method-combination"}),". You can access the method combination of a generic function using ",(0,i.jsx)(s.code,{children:"method-combination"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defgeneric my-generic-function (x))\n(method-combination (fdefinition 'my-generic-function)) ; Returns STANDARD\n"})}),"\n",(0,i.jsx)(s.h3,{id:"52-defining-custom-method-combinations",children:"5.2 Defining Custom Method Combinations"}),"\n",(0,i.jsxs)(s.p,{children:["You can define custom method combinations using ",(0,i.jsx)(s.code,{children:"define-method-combination"}),". The syntax is complex and allows for a high degree of customization. Here, we'll cover a simplified example."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(define-method-combination my-combination (&optional (order :most-specific-first))\n  ((methods (method-combination-methods)))\n  (case order\n    (:most-specific-first\n     `(progn ,@(mapcar #'(lambda (method) `(call-method ,method)) methods)))\n    (:most-specific-last\n     `(progn ,@(reverse (mapcar #'(lambda (method) `(call-method ,method)) methods))))))\n"})}),"\n",(0,i.jsxs)(s.p,{children:["This defines a method combination called ",(0,i.jsx)(s.code,{children:"my-combination"})," that takes an optional argument ",(0,i.jsx)(s.code,{children:"order"}),". If ",(0,i.jsx)(s.code,{children:"order"})," is ",(0,i.jsx)(s.code,{children:":most-specific-first"})," (the default), it calls the applicable methods from most specific to least specific. If ",(0,i.jsx)(s.code,{children:"order"})," is ",(0,i.jsx)(s.code,{children:":most-specific-last"}),", it calls them in reverse order."]}),"\n",(0,i.jsxs)(s.p,{children:["To use a custom method combination, you specify the ",(0,i.jsx)(s.code,{children:":method-combination"})," option in ",(0,i.jsx)(s.code,{children:"defgeneric"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defgeneric my-generic-function (x)\n  (:method-combination my-combination))\n\n(defmethod my-generic-function ((x number))\n  (format t "Number method~%")\n  x)\n\n(defmethod my-generic-function ((x integer))\n  (format t "Integer method~%")\n  (* x 2))\n\n(my-generic-function 5)\n; Output:\n; Integer method\n; Number method\n; 10\n\n(defgeneric my-other-generic-function (x)\n  (:method-combination my-combination (:most-specific-last)))\n\n(defmethod my-other-generic-function ((x number))\n  (format t "Number method~%")\n  x)\n\n(defmethod my-other-generic-function ((x integer))\n  (format t "Integer method~%")\n  (* x 2))\n\n(my-other-generic-function 5)\n; Output:\n; Number method\n; Integer method\n; 10\n'})}),"\n",(0,i.jsx)(s.h3,{id:"53-customizing-method-selection",children:"5.3 Customizing Method Selection"}),"\n",(0,i.jsxs)(s.p,{children:["You can customize method selection by specializing the generic functions that are responsible for determining applicable methods and ordering them. The most important generic function for this is ",(0,i.jsx)(s.code,{children:"compute-applicable-methods"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"compute-applicable-methods"})," takes a generic function and a list of arguments and returns a list of applicable methods, ordered according to the method combination. By specializing this generic function, you can change the method selection process entirely."]}),"\n",(0,i.jsx)(s.p,{children:"Here's a simplified example that demonstrates how to filter applicable methods based on a condition:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defgeneric my-generic-function (x))\n\n(defmethod compute-applicable-methods ((gf standard-generic-function) args)\n  (remove-if-not #\'(lambda (method)\n                     (let ((specializer (first (method-specializers method))))\n                       (or (eq specializer \'t) ; Always include methods specialized on T\n                           (evenp (first args))))) ; Only include methods if the first argument is even\n                 (call-next-method))) ; Call the standard compute-applicable-methods\n\n(defmethod my-generic-function ((x number))\n  (format t "Number method~%")\n  x)\n\n(defmethod my-generic-function ((x integer))\n  (format t "Integer method~%")\n  (* x 2))\n\n(my-generic-function 4)\n; Output:\n; Integer method\n; 8\n\n(my-generic-function 5)\n; Output:\n; Number method\n; 5\n'})}),"\n",(0,i.jsxs)(s.p,{children:["In this example, we specialize ",(0,i.jsx)(s.code,{children:"compute-applicable-methods"})," to filter the applicable methods, only keeping those where the first argument is even (or if the method is specialized on ",(0,i.jsx)(s.code,{children:"T"}),")."]}),"\n",(0,i.jsx)(s.p,{children:"Customizing method dispatch is an advanced technique that allows for very fine-grained control over the behavior of CLOS. However, it's often complex and should be used only when necessary. Most of the time, the standard method combination and the standard method selection process are sufficient."}),"\n",(0,i.jsxs)(s.p,{children:["This section covered customizing method dispatch using custom method combinations and specializing ",(0,i.jsx)(s.code,{children:"compute-applicable-methods"}),". This enables very powerful and flexible control over how generic functions behave. This concludes the tutorial on the Metaobject Protocol."]}),"\n",(0,i.jsx)(s.h2,{id:"6-introspection-and-reflection-in-clos",children:"6. Introspection and Reflection in CLOS"}),"\n",(0,i.jsx)(s.p,{children:"Introspection and reflection are powerful features of CLOS that allow you to examine and manipulate the structure and behavior of objects, classes, methods, and generic functions at runtime. This section explores how to perform these operations using the Metaobject Protocol."}),"\n",(0,i.jsx)(s.h3,{id:"61-inspecting-class-structure-slots-superclasses",children:"6.1 Inspecting Class Structure (Slots, Superclasses)"}),"\n",(0,i.jsx)(s.p,{children:"You can inspect the structure of a class using several MOP functions:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"class-slots"})}),": Returns a list of ",(0,i.jsx)(s.code,{children:"slot-definition"})," metaobjects for a given class. Each ",(0,i.jsx)(s.code,{children:"slot-definition"})," contains information about a slot, such as its name, initargs, initform, and accessors."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass person ()\n  ((name :initarg :name :accessor person-name)\n   (age :initarg :age :accessor person-age)))\n\n(mapcar #'slot-definition-name (class-slots (find-class 'person))) ; Returns (NAME AGE)\n(mapcar #'slot-definition-initargs (class-slots (find-class 'person))) ; Returns ((:NAME) (:AGE))\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"class-direct-slots"})}),": Returns a list of ",(0,i.jsx)(s.code,{children:"slot-definition"})," metaobjects for the slots directly defined in the class (excluding inherited slots)."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defclass employee (person)\n  ((employee-id :initarg :id :accessor employee-id)))\n\n(mapcar #'slot-definition-name (class-slots (find-class 'employee))) ; Returns (NAME AGE EMPLOYEE-ID)\n(mapcar #'slot-definition-name (class-direct-slots (find-class 'employee))) ; Returns (EMPLOYEE-ID)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"class-precedence-list"})}),": Returns the class precedence list (CPL) for a class. The CPL determines the order in which methods are applied when a generic function is called."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(class-precedence-list (find-class 'employee)) ; Returns a list of classes: (EMPLOYEE PERSON STANDARD-OBJECT T)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"class-direct-superclasses"})}),": Returns the direct superclasses of a class."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(class-direct-superclasses (find-class 'employee)) ; Returns (PERSON)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"62-examining-method-definitions-and-specializers",children:"6.2 Examining Method Definitions and Specializers"}),"\n",(0,i.jsx)(s.p,{children:"You can examine method definitions and specializers using the following functions:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"method-specializers"})}),": Returns a list of the specializers of a method."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defgeneric greet (x))\n(defmethod greet ((x person))\n  (format t \"Hello, ~a!~%\" (person-name x)))\n\n(let ((method (find-method #'greet '() (list (find-class 'person)))))\n    (method-specializers method)) ; Returns (PERSON)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"method-lambda-list"})}),": Returns the lambda list of a method."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((method (find-method #'greet '() (list (find-class 'person)))))\n    (method-lambda-list method)) ; Returns (X)\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"method-function"})}),": Returns the compiled function that implements the method."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(let ((method (find-method #'greet '() (list (find-class 'person)))))\n    (function-lambda-expression (method-function method))) ; returns the lambda expression of the method\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"find-method"})}),": Finds a method of a generic function that matches a given set of specializers."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(find-method #'greet '() (list (find-class 'person))) ; Returns the method object.\n(find-method #'greet '() (list (find-class 'integer))) ; Returns nil because there is no method specialized on integer\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"63-working-with-generic-function-metaobjects",children:"6.3 Working with Generic Function Metaobjects"}),"\n",(0,i.jsx)(s.p,{children:"You can access and manipulate generic function metaobjects using these functions:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"generic-function-name"})}),": Returns the name of a generic function."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defgeneric greet (x))\n(generic-function-name (fdefinition 'greet)) ; Returns GREET\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"generic-function-methods"})}),": Returns a list of all methods associated with a generic function."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(defmethod greet ((x number)) nil)\n(defmethod greet ((x integer)) nil)\n(length (generic-function-methods (fdefinition 'greet))) ; Returns 2\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"generic-function-method-class"})}),": Returns the class of the methods associated with a generic function (usually ",(0,i.jsx)(s.code,{children:"standard-method"}),")."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(generic-function-method-class (fdefinition 'greet)) ; Returns STANDARD-METHOD\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"method-combination"})}),": Returns the method combination object of the generic function."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:"(method-combination (fdefinition 'greet)) ; Returns STANDARD\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example: Printing Information about a Class:"})}),"\n",(0,i.jsx)(s.p,{children:"This example demonstrates how to use introspection to print information about a class:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defun print-class-info (class-name)\n  (let ((class (find-class class-name)))\n    (when class\n      (format t "Class: ~a~%" (class-name class))\n      (format t "Superclasses: ~a~%" (class-direct-superclasses class))\n      (format t "Slots:~%")\n      (dolist (slot (class-slots class))\n        (format t "  ~a (initargs: ~a)~%"\n                (slot-definition-name slot)\n                (slot-definition-initargs slot))))))\n\n(print-class-info \'employee)\n'})}),"\n",(0,i.jsx)(s.p,{children:"This function prints the name, superclasses, and slots of a given class."}),"\n",(0,i.jsx)(s.p,{children:"Introspection and reflection are powerful tools for understanding and manipulating the structure and behavior of your CLOS code. They are particularly useful for debugging, metaprogramming, and building tools that analyze or manipulate code. This concludes the tutorial on the Metaobject Protocol. While many more advanced features exist, this introduction should provide a solid foundation for further exploration."}),"\n",(0,i.jsx)(s.h2,{id:"7-examples-and-advanced-techniques-using-the-mop",children:"7. Examples and Advanced Techniques using the MOP"}),"\n",(0,i.jsx)(s.p,{children:"This section explores some more advanced techniques and provides examples of how the Metaobject Protocol (MOP) can be used to solve real-world problems."}),"\n",(0,i.jsx)(s.h3,{id:"71-implementing-a-simple-object-database",children:"7.1 Implementing a Simple Object Database"}),"\n",(0,i.jsx)(s.p,{children:"The MOP can be used to implement a simple in-memory object database. This example demonstrates how to automatically assign unique IDs to objects upon creation."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defclass db-class (standard-class)\n  ((next-id :initform 0 :accessor next-id)))\n\n(defmethod initialize-instance ((class db-class) &rest initargs)\n  (call-next-method)\n  class)\n\n(defmethod make-instance ((class db-class) &rest initargs)\n  (let ((instance (call-next-method)))\n    (setf (getf initargs :id) (incf (next-id class))) ; Auto-assign ID\n    (apply #\'reinitialize-instance instance initargs)\n    instance))\n\n(defclass db-object ()\n  ((id :initarg :id :accessor object-id))\n  (:metaclass db-class))\n\n(defclass person (db-object)\n  ((name :initarg :name :accessor person-name)))\n\n(let ((p1 (make-instance \'person :name "Alice"))\n      (p2 (make-instance \'person :name "Bob")))\n  (format t "P1 ID: ~a, Name: ~a~%" (object-id p1) (person-name p1))\n  (format t "P2 ID: ~a, Name: ~a~%" (object-id p2) (person-name p2)))\n; Output:\n; P1 ID: 1, Name: Alice\n; P2 ID: 2, Name: Bob\n'})}),"\n",(0,i.jsx)(s.p,{children:"Here's how it works:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"db-class"})," is a custom metaclass that inherits from ",(0,i.jsx)(s.code,{children:"standard-class"})," and has a slot ",(0,i.jsx)(s.code,{children:"next-id"})," to keep track of the next available ID."]}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"initialize-instance"})," method for ",(0,i.jsx)(s.code,{children:"db-class"})," does nothing special but is needed to make the ",(0,i.jsx)(s.code,{children:"next-id"})," slot work."]}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"make-instance"})," method specialized on ",(0,i.jsx)(s.code,{children:"db-class"})," now automatically assigns a unique ID to each instance by incrementing ",(0,i.jsx)(s.code,{children:"next-id"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"db-object"})," is a base class for all database objects, which has an ",(0,i.jsx)(s.code,{children:"id"})," slot."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"person"})," inherits from ",(0,i.jsx)(s.code,{children:"db-object"})," and thus automatically gains the ID functionality."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This is a simple example, but it illustrates how the MOP can be used to add common behavior to classes automatically."}),"\n",(0,i.jsx)(s.h3,{id:"72-implementing-aspects-using-the-mop",children:"7.2 Implementing Aspects Using the MOP"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Aspect-Oriented Programming (AOP)"})," is a programming paradigm that allows you to modularize cross-cutting concerns (aspects) such as logging, tracing, or security. The MOP can be used to implement aspects in CLOS."]}),"\n",(0,i.jsx)(s.p,{children:"This example demonstrates how to implement a simple tracing aspect:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lisp",children:'(defclass traced-class (standard-class) ())\n\n(defmethod initialize-instance ((class traced-class) &rest initargs)\n  (call-next-method)\n  (dolist (method (generic-function-methods (fdefinition (intern (format nil "~a-~a" (package-name (symbol-package (class-name class))) (class-name class))))))\n      (let ((original-function (method-function method)))\n          (setf (method-function method)\n              #\'(lambda (&rest args)\n                  (format t "Entering ~a with args: ~a~%" method args)\n                  (multiple-value-prog1 (apply original-function args)\n                      (format t "Exiting ~a~%" method))))))\n  class)\n\n(defgeneric person-greet (p))\n\n(defclass person ()\n    ((name :initarg :name :accessor person-name))\n    (:metaclass traced-class))\n\n(defmethod person-greet ((p person))\n    (format t "Hello ~a~%" (person-name p)))\n\n(person-greet (make-instance \'person :name "Alice"))\n; Output:\n; Entering #<STANDARD-METHOD PERSON-GREET (PERSON)> with args: (#<PERSON {1004838383}>)\n; Hello Alice\n; Exiting #<STANDARD-METHOD PERSON-GREET (PERSON)>\n'})}),"\n",(0,i.jsx)(s.p,{children:"Here's how it works:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"traced-class"})," is a custom metaclass."]}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"initialize-instance"})," method for ",(0,i.jsx)(s.code,{children:"traced-class"})," iterates through all methods associated with the class, and wraps the original method function with a new function that prints tracing information before and after calling the original method."]}),"\n",(0,i.jsxs)(s.li,{children:["By making a class use the ",(0,i.jsx)(s.code,{children:"traced-class"})," metaclass, all methods of that class are automatically traced."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This is a simplified example of aspect implementation. More complex aspects can be implemented using more advanced MOP techniques."}),"\n",(0,i.jsx)(s.h3,{id:"73-creating-a-new-object-model-on-top-of-clos",children:"7.3 Creating a New Object Model on Top of CLOS"}),"\n",(0,i.jsx)(s.p,{children:"The MOP provides enough power to implement entirely new object models on top of CLOS. This is a very advanced technique and is rarely necessary for most applications. However, it demonstrates the extreme flexibility of the MOP."}),"\n",(0,i.jsx)(s.p,{children:"Implementing a new object model typically involves:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Defining custom metaclasses for classes, methods, and generic functions."}),"\n",(0,i.jsx)(s.li,{children:"Customizing method dispatch."}),"\n",(0,i.jsx)(s.li,{children:"Defining new method combinations."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This is a very complex topic and is beyond the scope of this introductory tutorial. However, it's important to understand that the MOP provides this level of customization."}),"\n",(0,i.jsx)(s.p,{children:"These examples illustrate some of the advanced capabilities of the MOP. It's a powerful tool that allows you to customize and extend CLOS in significant ways. However, it's important to use it judiciously, as overuse can make code more complex. For most applications, the standard behavior of CLOS is sufficient. This concludes the tutorial."})]})}function h(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>o,a:()=>c});var i=n(7294);const t={},a=i.createContext(t);function c(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(a.Provider,{value:s},e.children)}}}]);