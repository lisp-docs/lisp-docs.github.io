"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[2357],{2122:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var i=s(5893),t=s(1151);const r={sidebar_position:7},c="Types",l={id:"tutorial/types",title:"Types",description:"This article needs to be checked!.",source:"@site/docs/tutorial/types.md",sourceDirName:"tutorial",slug:"/tutorial/types",permalink:"/docs/tutorial/types",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/types.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Input and Output",permalink:"/docs/tutorial/io"},next:{title:"Condition System",permalink:"/docs/tutorial/conditions"}},o={},d=[{value:"Introduction to the Common Lisp Type System",id:"introduction-to-the-common-lisp-type-system",level:2},{value:"1. Basic Type Concepts",id:"1-basic-type-concepts",level:2},{value:"1.1 What is a Type?",id:"11-what-is-a-type",level:3},{value:"1.2 Type Specifiers",id:"12-type-specifiers",level:3},{value:"1.3 The Universal Type <code>T</code> and the Empty Type <code>NIL</code>",id:"13-the-universal-type-t-and-the-empty-type-nil",level:3},{value:"2. Built-in Types",id:"2-built-in-types",level:2},{value:"2.1 Numeric Types",id:"21-numeric-types",level:3},{value:"2.2 Character Types",id:"22-character-types",level:3},{value:"2.3 Symbol Types",id:"23-symbol-types",level:3},{value:"2.4 List Types",id:"24-list-types",level:3},{value:"2.5 Array Types",id:"25-array-types",level:3},{value:"2.6 Other Important Types",id:"26-other-important-types",level:3},{value:"3. Type Specifiers",id:"3-type-specifiers",level:2},{value:"3.1 Atomic Type Specifiers",id:"31-atomic-type-specifiers",level:3},{value:"3.2 Compound Type Specifiers",id:"32-compound-type-specifiers",level:3},{value:"3.3 <code>EQL</code> Type Specifiers",id:"33-eql-type-specifiers",level:3},{value:"3.4 <code>MEMBER</code> Type Specifiers",id:"34-member-type-specifiers",level:3},{value:"4. Type Checking Functions",id:"4-type-checking-functions",level:2},{value:"4.1 <code>typep</code>: Testing if an Object is of a Given Type",id:"41-typep-testing-if-an-object-is-of-a-given-type",level:3},{value:"4.2 <code>type-of</code>: Returning the Most Specific Type of an Object",id:"42-type-of-returning-the-most-specific-type-of-an-object",level:3},{value:"5. Type Declarations",id:"5-type-declarations",level:2},{value:"5.1 <code>declare</code> Special Form",id:"51-declare-special-form",level:3},{value:"5.2 Using Type Declarations for Optimization",id:"52-using-type-declarations-for-optimization",level:3},{value:"5.3 Type Inference",id:"53-type-inference",level:3},{value:"6. Types and CLOS",id:"6-types-and-clos",level:2},{value:"6.1 Classes as Types",id:"61-classes-as-types",level:3},{value:"6.2 <code>typep</code> with Class Names",id:"62-typep-with-class-names",level:3},{value:"6.3 <code>subtypep</code>: Determining Subtype Relationships Between Classes and Other Types",id:"63-subtypep-determining-subtype-relationships-between-classes-and-other-types",level:3},{value:"6.4 Using <code>deftype</code> to Create Type Aliases for Class Names or Other Type Specifiers",id:"64-using-deftype-to-create-type-aliases-for-class-names-or-other-type-specifiers",level:3},{value:"7. Examples and Advanced Techniques",id:"7-examples-and-advanced-techniques",level:2},{value:"7.1 Defining Custom Types Using <code>deftype</code>",id:"71-defining-custom-types-using-deftype",level:3},{value:"7.2 Using Types for Error Checking and Validation",id:"72-using-types-for-error-checking-and-validation",level:3},{value:"7.3 Interactions of Types with Generic Functions and Methods",id:"73-interactions-of-types-with-generic-functions-and-methods",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"types",children:"Types"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["This article ",(0,i.jsx)(n.strong,{children:"needs to be checked!"}),".\nPlease help contribute by checking it and making changes in ",(0,i.jsx)(n.a,{href:"https://github.com/lisp-docs/lisp-docs.github.io",children:"our repository"}),' or by clicking on the "Edit this page" link below.']})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-the-common-lisp-type-system",children:"Introduction to the Common Lisp Type System"}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp possesses a rich and powerful type system that goes far beyond simple static typing found in languages like C or Java. It's a ",(0,i.jsx)(n.em,{children:"dynamic"})," type system, meaning type checking primarily occurs at runtime. However, it also includes features for type declarations that can be used for optimization and static analysis. It is also a ",(0,i.jsx)(n.em,{children:"hierarchy"})," of types, where types can be subtypes and supertypes of each other. The Common Lisp Object System (CLOS) is integrated into the type system, making classes themselves types."]}),"\n",(0,i.jsx)(n.p,{children:"This tutorial will introduce you to the core concepts of the Common Lisp type system, including built-in types, type specifiers, type checking functions, and how types interact with CLOS. We will not reiterate CLOS concepts already covered in the previous tutorial, focusing instead on how types relate to CLOS."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Types and Type Specifiers:"})," Ways to denote types in Lisp code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Hierarchy:"})," The relationships between different types (subtypes, supertypes)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Checking:"})," Functions for testing the type of an object."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Declarations:"})," Hints to the compiler for optimization."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Specifiers and CLOS:"})," How classes and objects relate to the type system."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Table of Contents:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Basic Type Concepts:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What is a type?"}),"\n",(0,i.jsx)(n.li,{children:"Type specifiers."}),"\n",(0,i.jsxs)(n.li,{children:["The universal type ",(0,i.jsx)(n.code,{children:"T"})," and the empty type ",(0,i.jsx)(n.code,{children:"NIL"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Built-in Types:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Numeric types: ",(0,i.jsx)(n.code,{children:"integer"}),", ",(0,i.jsx)(n.code,{children:"rational"}),", ",(0,i.jsx)(n.code,{children:"real"}),", ",(0,i.jsx)(n.code,{children:"complex"}),", ",(0,i.jsx)(n.code,{children:"float"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Character types: ",(0,i.jsx)(n.code,{children:"character"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Symbol types: ",(0,i.jsx)(n.code,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["List types: ",(0,i.jsx)(n.code,{children:"list"}),", ",(0,i.jsx)(n.code,{children:"cons"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Array types: ",(0,i.jsx)(n.code,{children:"array"}),", ",(0,i.jsx)(n.code,{children:"vector"}),", ",(0,i.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Other important types: ",(0,i.jsx)(n.code,{children:"null"}),", ",(0,i.jsx)(n.code,{children:"function"}),", ",(0,i.jsx)(n.code,{children:"pathname"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Type Specifiers:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Atomic type specifiers (e.g., ",(0,i.jsx)(n.code,{children:"integer"}),", ",(0,i.jsx)(n.code,{children:"string"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Compound type specifiers (e.g., ",(0,i.jsx)(n.code,{children:"(integer 0 *)"}),", ",(0,i.jsx)(n.code,{children:"(array string (10))"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"EQL"})," type specifiers (e.g., ",(0,i.jsx)(n.code,{children:"(eql 5)"}),", ",(0,i.jsx)(n.code,{children:"(eql 'foo)"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MEMBER"})," type specifiers (e.g., ",(0,i.jsx)(n.code,{children:"(member :red :green :blue)"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Type Checking Functions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"typep"}),": Testing if an object is of a given type."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"type-of"}),": Returning the most specific type of an object."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Type Declarations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"declare"})," special form."]}),"\n",(0,i.jsx)(n.li,{children:"Using type declarations for optimization."}),"\n",(0,i.jsx)(n.li,{children:"Type inference."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"6. Types and CLOS:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Classes as types."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"typep"})," with class names."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"subtypep"}),": Determining subtype relationships between classes and other types."]}),"\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"deftype"})," to create type aliases for class names or other type specifiers."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7. Examples and Advanced Techniques:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Defining custom types using ",(0,i.jsx)(n.code,{children:"deftype"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Using types for error checking and validation."}),"\n",(0,i.jsx)(n.li,{children:"Interactions of types with generic functions and methods."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This tutorial will provide a comprehensive overview of the Common Lisp type system, equipping you with the knowledge to effectively use types in your Lisp programs."}),"\n",(0,i.jsx)(n.h2,{id:"1-basic-type-concepts",children:"1. Basic Type Concepts"}),"\n",(0,i.jsx)(n.p,{children:"This section introduces the fundamental concepts of types in Common Lisp."}),"\n",(0,i.jsx)(n.h3,{id:"11-what-is-a-type",children:"1.1 What is a Type?"}),"\n",(0,i.jsxs)(n.p,{children:["In Common Lisp, a ",(0,i.jsx)(n.em,{children:"type"})," is a set of objects. An object is said to be ",(0,i.jsx)(n.em,{children:"of"})," a particular type if it is a member of that set. Types are used to classify objects and reason about their behavior."]}),"\n",(0,i.jsx)(n.p,{children:"Unlike statically typed languages where type checking is performed at compile time, Common Lisp is dynamically typed. This means that type checking primarily occurs at runtime. When an operation is performed on an object, the Lisp system checks if the object is of the expected type for that operation. If not, a type error is signaled."}),"\n",(0,i.jsxs)(n.p,{children:["For example, the ",(0,i.jsx)(n.code,{children:"+"})," operator expects numeric arguments. If you try to add a number and a string, a type error will occur."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(+ 5 "hello") ; This will signal a type error.\n'})}),"\n",(0,i.jsx)(n.h3,{id:"12-type-specifiers",children:"1.2 Type Specifiers"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"type specifier"})," is a symbolic expression that denotes a type. Type specifiers are used in type declarations, type checking functions, and other contexts where you need to refer to a type."]}),"\n",(0,i.jsx)(n.p,{children:"Some examples of type specifiers include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"integer"}),": Represents the set of all integers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"string"}),": Represents the set of all strings."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"symbol"}),": Represents the set of all symbols."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(integer 0 10)"}),": Represents the set of integers between 0 and 10 (inclusive)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(vector integer)"}),": Represents the set of all vectors whose elements are integers."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Type specifiers can be simple atomic symbols (like ",(0,i.jsx)(n.code,{children:"integer"})," or ",(0,i.jsx)(n.code,{children:"string"}),"), or they can be more complex compound expressions (like the examples above). We will explore compound type specifiers in more detail later."]}),"\n",(0,i.jsxs)(n.h3,{id:"13-the-universal-type-t-and-the-empty-type-nil",children:["1.3 The Universal Type ",(0,i.jsx)(n.code,{children:"T"})," and the Empty Type ",(0,i.jsx)(n.code,{children:"NIL"})]}),"\n",(0,i.jsx)(n.p,{children:"Two special type specifiers play important roles in the Common Lisp type system:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"T"})," (Top):"]})," This is the ",(0,i.jsx)(n.em,{children:"universal type"}),". Every object in Common Lisp is of type ",(0,i.jsx)(n.code,{children:"T"}),". It represents the set of ",(0,i.jsx)(n.em,{children:"all"})," objects. ",(0,i.jsx)(n.code,{children:"T"})," is the supertype of all other types."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 5 't)      ; Returns T\n(typep \"hello\" 't) ; Returns T\n(typep 'foo 't)   ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"NIL"})," (Bottom):"]})," This is the ",(0,i.jsx)(n.em,{children:"empty type"})," (also called ",(0,i.jsx)(n.em,{children:"bottom type"}),"). No object is of type ",(0,i.jsx)(n.code,{children:"NIL"}),". It represents the empty set. ",(0,i.jsx)(n.code,{children:"NIL"})," is the subtype of all other types. It is important to distinguish the type ",(0,i.jsx)(n.code,{children:"NIL"})," from the symbol ",(0,i.jsx)(n.code,{children:"NIL"})," which represents logical false, and is the only object of type ",(0,i.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 5 'nil)      ; Returns NIL\n(typep \"hello\" 'nil) ; Returns NIL\n(typep 'foo 'nil)   ; Returns NIL\n\n(typep nil 'null) ; Returns T\n(typep nil 'symbol) ; Returns T\n(typep nil 'list) ; Returns T\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The relationship between types can be visualized as a hierarchy. ",(0,i.jsx)(n.code,{children:"T"})," sits at the top of the hierarchy, and ",(0,i.jsx)(n.code,{children:"NIL"})," sits at the bottom. All other types fall somewhere in between."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"integer"})," is a subtype of ",(0,i.jsx)(n.code,{children:"real"}),", which is a subtype of ",(0,i.jsx)(n.code,{children:"number"}),", which is a subtype of ",(0,i.jsx)(n.code,{children:"T"}),". ",(0,i.jsx)(n.code,{children:"NIL"})," is a subtype of ",(0,i.jsx)(n.code,{children:"integer"}),", ",(0,i.jsx)(n.code,{children:"real"}),", ",(0,i.jsx)(n.code,{children:"number"}),", and every other type."]}),"\n",(0,i.jsxs)(n.p,{children:["Understanding ",(0,i.jsx)(n.code,{children:"T"})," and ",(0,i.jsx)(n.code,{children:"NIL"})," is important for reasoning about type relationships and writing correct type checks. For example, if a function can accept any type of argument, you would use ",(0,i.jsx)(n.code,{children:"T"})," as the argument's type specifier. If a function should never be called with any argument, you might use ",(0,i.jsx)(n.code,{children:"NIL"})," in a type declaration to indicate this (although this is less common)."]}),"\n",(0,i.jsxs)(n.p,{children:["This section introduced basic type concepts, type specifiers, and the special types ",(0,i.jsx)(n.code,{children:"T"})," and ",(0,i.jsx)(n.code,{children:"NIL"}),". The next section will cover the built-in types in Common Lisp."]}),"\n",(0,i.jsx)(n.h2,{id:"2-built-in-types",children:"2. Built-in Types"}),"\n",(0,i.jsx)(n.p,{children:"Common Lisp provides a rich set of built-in types that cover a wide range of data structures and values. This section describes some of the most important built-in types."}),"\n",(0,i.jsx)(n.h3,{id:"21-numeric-types",children:"2.1 Numeric Types"}),"\n",(0,i.jsx)(n.p,{children:"Common Lisp has a comprehensive numeric type hierarchy:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"integer"}),":"]})," Represents whole numbers (e.g., -2, 0, 100). Integers can be arbitrarily large (bignums)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 10 'integer)      ; Returns T\n(typep -5 'integer)     ; Returns T\n(typep 123456789012345678901234567890 'integer) ; Returns T (bignum)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"rational"}),":"]})," Represents numbers that can be expressed as a ratio of two integers (e.g., 1/2, 3/4, -7/3). Integers are a subtype of rationals."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 1/2 'rational)   ; Returns T\n(typep 6/3 'rational)   ; Returns T (equivalent to the integer 2)\n(typep 2 'rational) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"real"}),":"]})," Represents all numbers that can be plotted on a number line. This includes rationals and floating-point numbers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 3.14 'real)      ; Returns T\n(typep 1/3 'real)    ; Returns T\n(typep 5 'real)       ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"float"}),":"]})," Represents floating-point numbers (e.g., 3.14, -0.001, 1.23e10). Common Lisp supports multiple floating-point formats: ",(0,i.jsx)(n.code,{children:"short-float"}),", ",(0,i.jsx)(n.code,{children:"single-float"}),", ",(0,i.jsx)(n.code,{children:"double-float"}),", and ",(0,i.jsx)(n.code,{children:"long-float"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 3.14f0 'single-float) ; Returns T\n(typep 3.14d0 'double-float) ; Returns T\n(typep 3.14 'float) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"complex"}),":"]})," Represents complex numbers, which have a real and an imaginary part (e.g., #C(3 4), #C(0 1))."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #C(3 4) 'complex)   ; Returns T\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The numeric types form a subtype hierarchy: ",(0,i.jsx)(n.code,{children:"integer"})," \u2282 ",(0,i.jsx)(n.code,{children:"rational"})," \u2282 ",(0,i.jsx)(n.code,{children:"real"})," \u2282 ",(0,i.jsx)(n.code,{children:"complex"}),". Also, ",(0,i.jsx)(n.code,{children:"float"})," \u2282 ",(0,i.jsx)(n.code,{children:"real"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"22-character-types",children:"2.2 Character Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"character"}),":"]})," Represents single characters (e.g., #\\A, #\\space, #\\newline)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #\\a 'character)   ; Returns T\n(typep #\\Space 'character) ; Returns T\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"23-symbol-types",children:"2.3 Symbol Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"symbol"}),":"]})," Represents symbolic names (e.g., ",(0,i.jsx)(n.code,{children:"foo"}),", ",(0,i.jsx)(n.code,{children:"BAR"}),", ",(0,i.jsx)(n.code,{children:"my-variable"}),"). Symbols are used as identifiers in Lisp code."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 'foo 'symbol)   ; Returns T\n(typep 'Bar123 'symbol) ; Returns T\n(typep nil 'symbol) ; Returns T. nil is a symbol\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"24-list-types",children:"2.4 List Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"list"}),":"]})," Represents linked lists of objects. The empty list is represented by ",(0,i.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep '(1 2 3) 'list)   ; Returns T\n(typep nil 'list)     ; Returns T (nil is also the empty list)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"cons"}),":"]})," Represents a cons cell, which is the basic building block of lists. A cons cell has two parts: the ",(0,i.jsx)(n.code,{children:"car"})," (first element) and the ",(0,i.jsx)(n.code,{children:"cdr"})," (rest of the list). A list is either ",(0,i.jsx)(n.code,{children:"nil"})," or a ",(0,i.jsx)(n.code,{children:"cons"})," whose ",(0,i.jsx)(n.code,{children:"cdr"})," is a list."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep (cons 1 2) 'cons)   ; Returns T\n(typep '(1 . 2) 'cons)   ; Returns T\n(typep '(1 2) 'cons)   ; Returns T\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"list"})," is equivalent to ",(0,i.jsx)(n.code,{children:"(or null cons)"}),". ",(0,i.jsx)(n.code,{children:"null"})," is a subtype of ",(0,i.jsx)(n.code,{children:"symbol"})," and only has one element: ",(0,i.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"25-array-types",children:"2.5 Array Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"array"}),":"]})," Represents multi-dimensional arrays of objects."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #(1 2 3) 'array)           ; Returns T\n(typep (make-array '(3 3)) 'array) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"vector"}),":"]})," Represents one-dimensional arrays. It is a subtype of ",(0,i.jsx)(n.code,{children:"array"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #(1 2 3) 'vector) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"string"}),":"]})," Represents sequences of characters. It is a specialized type of vector."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(typep "hello" \'string) ; Returns T\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"string"})," is equivalent to ",(0,i.jsx)(n.code,{children:"(vector character)"}),". ",(0,i.jsx)(n.code,{children:"vector"})," is equivalent to ",(0,i.jsx)(n.code,{children:"(array t (*))"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"26-other-important-types",children:"2.6 Other Important Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"null"}),":"]})," Represents the type containing only the symbol ",(0,i.jsx)(n.code,{children:"nil"}),". It is a subtype of ",(0,i.jsx)(n.code,{children:"symbol"})," and ",(0,i.jsx)(n.code,{children:"list"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep nil 'null) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"function"}),":"]})," Represents functions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #'+ 'function) ; Returns T\n(typep #'(lambda (x) (* x x)) 'function) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"pathname"}),":"]})," Represents file and directory names."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(typep #p"/tmp/foo.txt" \'pathname) ; Returns T (implementation-dependent)\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This section covered some of the most important built-in types in Common Lisp. Understanding these types is crucial for writing correct and efficient Lisp code. The next section will cover type specifiers in more detail, including compound type specifiers."}),"\n",(0,i.jsx)(n.h2,{id:"3-type-specifiers",children:"3. Type Specifiers"}),"\n",(0,i.jsx)(n.p,{children:"Type specifiers are symbolic expressions that denote types in Common Lisp. They are used in various contexts, including type declarations, type checking, and function signatures. This section explores different kinds of type specifiers."}),"\n",(0,i.jsx)(n.h3,{id:"31-atomic-type-specifiers",children:"3.1 Atomic Type Specifiers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Atomic type specifiers"})," are simple symbols that represent built-in types. We've already seen several examples in the previous section:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"integer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"rational"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"real"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"complex"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"float"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"character"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"symbol"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"list"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"cons"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"array"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"vector"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"string"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"null"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"function"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pathname"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These symbols directly name the corresponding built-in types."}),"\n",(0,i.jsx)(n.h3,{id:"32-compound-type-specifiers",children:"3.2 Compound Type Specifiers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Compound type specifiers"})," are more complex expressions that allow you to specify more precise types. They are typically lists where the first element is a type specifier and subsequent elements provide additional constraints."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["*",(0,i.jsxs)(n.em,{children:["(INTEGER * ",(0,i.jsx)(n.em,{children:"):"})]})," Represents all integers (equivalent to ",(0,i.jsx)(n.code,{children:"integer"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 10 '(integer * *)) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["*",(0,i.jsxs)(n.em,{children:["(INTEGER 0 ",(0,i.jsx)(n.em,{children:"):"})]})," Represents non-negative integers (integers greater than or equal to 0)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 5 '(integer 0 *))  ; Returns T\n(typep 0 '(integer 0 *))  ; Returns T\n(typep -1 '(integer 0 *)) ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(INTEGER 0 10):"})," Represents integers between 0 and 10 (inclusive)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 5 '(integer 0 10)) ; Returns T\n(typep 11 '(integer 0 10)); Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(FLOAT 0.0 1.0):"})," Represents floating-point numbers between 0.0 and 1.0 (exclusive)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 0.5 '(float 0.0 1.0)) ; Returns T\n(typep 1.0 '(float 0.0 1.0)) ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(ARRAY T (10)):"})," Represents a one-dimensional array (vector) of 10 elements of any type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #(1 2 3 4 5 6 7 8 9 10) '(array t (10))) ; Returns T\n(typep #(1 2 3) '(array t (10))) ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(ARRAY STRING (3 4)):"})," Represents a two-dimensional array of strings with dimensions 3x4."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep (make-array '(3 4) :element-type 'string :initial-element \"hello\") '(array string (3 4))) ; Returns T\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(VECTOR INTEGER):"})," Represents a one dimensional array of integers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep #(1 2 3) '(vector integer)) ; Returns T\n(typep #(1 2 \"3\") '(vector integer)) ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(STRING 10):"})," Represents a string of length 10."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(typep "0123456789" \'(string 10)) ; Returns T\n(typep "0123" \'(string 10)) ; Returns NIL\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(SIMPLE-VECTOR 10):"})," Represents a simple vector of length 10. Simple vectors are optimized vectors that can only hold objects of a single type."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(SIMPLE-ARRAY BIT (10 20)):"})," Represents a simple two dimensional array of bits of dimensions 10x20."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"33-eql-type-specifiers",children:["3.3 ",(0,i.jsx)(n.code,{children:"EQL"})," Type Specifiers"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"EQL"})," type specifier allows you to specify a type that contains only a single specific object."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(EQL 5):"})," Represents the type containing only the integer 5."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 5 '(eql 5))   ; Returns T\n(typep 6 '(eql 5))   ; Returns NIL\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(EQL 'foo):"})," Represents the type containing only the symbol ",(0,i.jsx)(n.code,{children:"foo"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 'foo '(eql 'foo)) ; Returns T\n(typep 'bar '(eql 'foo)) ; Returns NIL\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EQL"})," type specifiers are often used in ",(0,i.jsx)(n.code,{children:"CASE"})," statements and method specializers."]}),"\n",(0,i.jsxs)(n.h3,{id:"34-member-type-specifiers",children:["3.4 ",(0,i.jsx)(n.code,{children:"MEMBER"})," Type Specifiers"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"MEMBER"})," type specifier allows you to define a type as a set of specific objects."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["(MEMBER ",":red"," ",":green"," ",":blue","):"]})," Represents the type containing only the keywords ",(0,i.jsx)(n.code,{children:":red"}),", ",(0,i.jsx)(n.code,{children:":green"}),", and ",(0,i.jsx)(n.code,{children:":blue"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep :red '(member :red :green :blue))   ; Returns T\n(typep :yellow '(member :red :green :blue)) ; Returns NIL\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MEMBER"})," type specifiers are useful for defining enumerated types or when a variable can only hold a limited set of values."]}),"\n",(0,i.jsxs)(n.p,{children:["This section covered different types of type specifiers, including atomic, compound, ",(0,i.jsx)(n.code,{children:"EQL"}),", and ",(0,i.jsx)(n.code,{children:"MEMBER"})," specifiers. These specifiers provide a powerful and flexible way to express types in Common Lisp. The next section will cover type checking functions."]}),"\n",(0,i.jsx)(n.h2,{id:"4-type-checking-functions",children:"4. Type Checking Functions"}),"\n",(0,i.jsxs)(n.p,{children:["This section describes the primary functions used for type checking in Common Lisp: ",(0,i.jsx)(n.code,{children:"typep"})," and ",(0,i.jsx)(n.code,{children:"type-of"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"41-typep-testing-if-an-object-is-of-a-given-type",children:["4.1 ",(0,i.jsx)(n.code,{children:"typep"}),": Testing if an Object is of a Given Type"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"typep"})," function is used to test if an object is of a given type. Its syntax is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep object type-specifier)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"object"})}),": The object to test."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"type-specifier"})}),": The type specifier to test against."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"typep"})," returns ",(0,i.jsx)(n.code,{children:"T"})," if the object is of the specified type, and ",(0,i.jsx)(n.code,{children:"NIL"})," otherwise."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 10 'integer)             ; Returns T\n(typep 3.14 'float)             ; Returns T\n(typep \"hello\" 'string)           ; Returns T\n(typep '(1 2 3) 'list)            ; Returns T\n(typep 'foo 'symbol)             ; Returns T\n(typep 10 '(integer 0 100))     ; Returns T\n(typep 200 '(integer 0 100))    ; Returns NIL\n(typep :red '(member :red :green :blue)) ; Returns T\n(typep 5 '(eql 5))               ; Returns T\n(typep 5 '(eql 6))               ; Returns NIL\n(typep #(1 2 3) '(vector integer)) ; Returns T\n(typep #(1 2 \"3\") '(vector integer)) ; Returns NIL\n(typep (make-array '(3 4) :element-type 'string) '(array string (3 4))) ; Returns T\n(typep (make-array '(3 4) :element-type 'string) 'array) ; Returns T\n(typep (make-array '(3 4)) 'array) ; Returns T\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"typep"})," handles the type hierarchy correctly. If a type ",(0,i.jsx)(n.code,{children:"A"})," is a subtype of type ",(0,i.jsx)(n.code,{children:"B"}),", and an object is of type ",(0,i.jsx)(n.code,{children:"A"}),", then ",(0,i.jsx)(n.code,{children:"typep"})," will also return ",(0,i.jsx)(n.code,{children:"T"})," when testing if the object is of type ",(0,i.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 5 'real)     ; Returns T (integer is a subtype of real)\n(typep \"hello\" 'sequence) ; Returns T (string is a subtype of sequence)\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"42-type-of-returning-the-most-specific-type-of-an-object",children:["4.2 ",(0,i.jsx)(n.code,{children:"type-of"}),": Returning the Most Specific Type of an Object"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"type-of"})," function returns the ",(0,i.jsx)(n.em,{children:"most specific"})," type of an object. This is often a more precise type than what ",(0,i.jsx)(n.code,{children:"typep"})," would indicate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(type-of 10)       ; Returns INTEGER\n(type-of 3.14)     ; Returns SINGLE-FLOAT (or DOUBLE-FLOAT on some implementations)\n(type-of \"hello\")   ; Returns (SIMPLE-ARRAY CHARACTER (5)) or STRING\n(type-of '(1 2 3))  ; Returns CONS\n(type-of 'foo)     ; Returns SYMBOL\n(type-of nil)      ; Returns NULL\n(type-of #())      ; Returns (SIMPLE-ARRAY T (0))\n(type-of #(1 2 3))  ; Returns (SIMPLE-ARRAY FIXNUM (3)) or (SIMPLE-ARRAY INTEGER (3))\n(type-of (make-array '(2 3))) ; Returns (SIMPLE-ARRAY T (2 3))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The exact return value of ",(0,i.jsx)(n.code,{children:"type-of"})," can be implementation-dependent, especially for array types. For example, some implementations might return ",(0,i.jsx)(n.code,{children:"STRING"})," for string objects, while others might return a more specific array type like ",(0,i.jsx)(n.code,{children:"(SIMPLE-ARRAY CHARACTER (*))"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"type-of"})," is useful for introspection and debugging when you need to know the precise type of an object."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Key Differences between ",(0,i.jsx)(n.code,{children:"typep"})," and ",(0,i.jsx)(n.code,{children:"type-of"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"typep"})," tests if an object is ",(0,i.jsx)(n.em,{children:"of"})," a given type (including supertypes). It returns a boolean (",(0,i.jsx)(n.code,{children:"T"})," or ",(0,i.jsx)(n.code,{children:"NIL"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"type-of"})," returns the ",(0,i.jsx)(n.em,{children:"most specific"})," type of an object. It returns a type specifier."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In most cases, ",(0,i.jsx)(n.code,{children:"typep"})," is the function you'll use for type checking in your code. ",(0,i.jsx)(n.code,{children:"type-of"})," is more useful for introspection and debugging."]}),"\n",(0,i.jsx)(n.h2,{id:"5-type-declarations",children:"5. Type Declarations"}),"\n",(0,i.jsx)(n.p,{children:"Type declarations in Common Lisp are used to provide hints to the compiler about the types of variables, function arguments, and return values. They are primarily used for optimization and can also be used for static analysis and documentation."}),"\n",(0,i.jsxs)(n.h3,{id:"51-declare-special-form",children:["5.1 ",(0,i.jsx)(n.code,{children:"declare"})," Special Form"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"declare"})," special form is used to introduce type declarations. It can be used in various contexts, including:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Inside ",(0,i.jsx)(n.code,{children:"let"})," forms: To declare the types of local variables."]}),"\n",(0,i.jsx)(n.li,{children:"At the top level of a function definition: To declare the types of function arguments and the return value."}),"\n",(0,i.jsx)(n.li,{children:"Globally at top level."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The basic syntax of ",(0,i.jsx)(n.code,{children:"declare"})," is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(declare (type type-specifier variable1 variable2 ...))\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(let ((x 10))\n  (declare (type integer x)) ; Declare x as an integer\n  (+ x 5))\n\n(defun my-function (x y)\n  (declare (type integer x y)\n           (values integer)) ; Declare x and y as integers, and the return value as an integer\n  (+ x y))\n\n(defun my-string-function (x)\n    (declare (type string x)\n             (values string))\n    (concatenate \'string x " suffix"))\n\n(defconstant +my-global-constant+ 10\n    "A global constant"\n    (declare (type integer +my-global-constant+)))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Multiple declarations can be combined within a single ",(0,i.jsx)(n.code,{children:"declare"})," form:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(declare (type integer x y) (type string z))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"52-using-type-declarations-for-optimization",children:"5.2 Using Type Declarations for Optimization"}),"\n",(0,i.jsx)(n.p,{children:"The primary purpose of type declarations is to provide information to the compiler that can be used for optimization. By knowing the types of variables, the compiler can generate more efficient code."}),"\n",(0,i.jsx)(n.p,{children:"For example, if the compiler knows that a variable is always an integer, it can use specialized integer arithmetic instructions instead of more general (and slower) arithmetic operations."}),"\n",(0,i.jsxs)(n.p,{children:["However, it's important to understand that type declarations in Common Lisp are ",(0,i.jsx)(n.em,{children:"not"})," mandatory. The Lisp system will still function correctly even without type declarations. If a type declaration is incorrect, a type error will be signaled at runtime."]}),"\n",(0,i.jsx)(n.h3,{id:"53-type-inference",children:"5.3 Type Inference"}),"\n",(0,i.jsxs)(n.p,{children:["Common Lisp implementations often perform some level of ",(0,i.jsx)(n.em,{children:"type inference"}),". This means that the compiler can sometimes deduce the types of variables even without explicit type declarations."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if you have the expression ",(0,i.jsx)(n.code,{children:"(+ 5 10)"}),", the compiler can infer that the result will be an integer, even if no type declarations are present."]}),"\n",(0,i.jsx)(n.p,{children:"Type inference can reduce the need for explicit type declarations in many cases. However, providing type declarations can still be beneficial for optimization and for making your code more readable and maintainable."}),"\n",(0,i.jsxs)(n.p,{children:["This section covered type checking functions (",(0,i.jsx)(n.code,{children:"typep"})," and ",(0,i.jsx)(n.code,{children:"type-of"}),") and type declarations (",(0,i.jsx)(n.code,{children:"declare"}),"). These tools are essential for working with types in Common Lisp. The next section will cover how types interact with CLOS."]}),"\n",(0,i.jsx)(n.h2,{id:"6-types-and-clos",children:"6. Types and CLOS"}),"\n",(0,i.jsx)(n.p,{children:"This section explains how the Common Lisp Object System (CLOS) integrates with the type system."}),"\n",(0,i.jsx)(n.h3,{id:"61-classes-as-types",children:"6.1 Classes as Types"}),"\n",(0,i.jsx)(n.p,{children:"In CLOS, classes are themselves types. This means that you can use class names as type specifiers. If an object is an instance of a class, it is also considered to be of that class's type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defclass person ()\n  ((name :initarg :name :accessor person-name)))\n\n(let ((p (make-instance 'person :name \"Alice\")))\n  (typep p 'person)) ; Returns T\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, ",(0,i.jsx)(n.code,{children:"person"})," is both a class name and a type specifier. The ",(0,i.jsx)(n.code,{children:"typep"})," function correctly determines that the object ",(0,i.jsx)(n.code,{children:"p"})," is of type ",(0,i.jsx)(n.code,{children:"person"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"62-typep-with-class-names",children:["6.2 ",(0,i.jsx)(n.code,{children:"typep"})," with Class Names"]}),"\n",(0,i.jsxs)(n.p,{children:["You can use ",(0,i.jsx)(n.code,{children:"typep"})," with class names just like with any other type specifier. ",(0,i.jsx)(n.code,{children:"typep"})," handles the class hierarchy correctly, meaning if ",(0,i.jsx)(n.code,{children:"B"})," is a subclass of ",(0,i.jsx)(n.code,{children:"A"}),", then an instance of ",(0,i.jsx)(n.code,{children:"B"})," is also considered to be of type ",(0,i.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defclass employee (person)\n  ((employee-id :initarg :id :accessor employee-id)))\n\n(let ((e (make-instance 'employee :name \"Bob\" :id 123)))\n  (typep e 'employee)) ; Returns T\n(typep e 'person)   ; Returns T (employee is a subclass of person)\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"63-subtypep-determining-subtype-relationships-between-classes-and-other-types",children:["6.3 ",(0,i.jsx)(n.code,{children:"subtypep"}),": Determining Subtype Relationships Between Classes and Other Types"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"subtypep"})," function is used to determine if one type is a subtype of another. Its syntax is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subtypep type-specifier1 type-specifier2 &optional environment)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It returns two values:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["A boolean indicating whether ",(0,i.jsx)(n.code,{children:"type-specifier1"})," is a subtype of ",(0,i.jsx)(n.code,{children:"type-specifier2"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"A boolean indicating whether the subtype relationship could be determined definitely. This second value is important because some subtype relationships can only be determined at runtime."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(subtypep 'integer 'real) ; Returns T, T\n(subtypep 'real 'integer) ; Returns NIL, T\n(subtypep 'employee 'person) ; Returns T, T\n(subtypep 'person 'employee) ; Returns NIL, T\n(subtypep '(integer 0 10) 'integer) ; Returns T, T\n(subtypep 'null 'list) ; returns T, T\n(subtypep 'null 'symbol) ; returns T, T\n(subtypep 'list 'null) ; returns NIL, T\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"subtypep"})," is particularly useful when working with class hierarchies and complex type specifiers."]}),"\n",(0,i.jsxs)(n.h3,{id:"64-using-deftype-to-create-type-aliases-for-class-names-or-other-type-specifiers",children:["6.4 Using ",(0,i.jsx)(n.code,{children:"deftype"})," to Create Type Aliases for Class Names or Other Type Specifiers"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"deftype"})," macro allows you to create new type specifiers as aliases for existing ones. This can make your code more readable and maintainable, especially when dealing with complex type specifiers or class names."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(deftype positive-integer () '(integer 1 *)) ; Define positive-integer\n(deftype my-string () 'string) ; Define my-string as an alias for string\n\n(typep 5 'positive-integer) ; Returns T\n(typep 0 'positive-integer) ; Returns NIL\n(typep \"hello\" 'my-string)  ; Returns T\n\n(defclass my-class () ())\n(deftype my-class-type () 'my-class)\n\n(typep (make-instance 'my-class) 'my-class-type) ; Returns T\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"deftype"})," can also be used to create more complex type specifiers by using a lambda list:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(deftype range (min max) `(integer ,min ,max))\n\n(typep 5 '(range 0 10))   ; Returns T\n(typep 15 '(range 0 10))  ; Returns NIL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, ",(0,i.jsx)(n.code,{children:"range"})," is a type specifier that takes two arguments, ",(0,i.jsx)(n.code,{children:"min"})," and ",(0,i.jsx)(n.code,{children:"max"}),", and creates an ",(0,i.jsx)(n.code,{children:"INTEGER"})," type specifier with the specified range."]}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"deftype"})," with classes can be helpful for creating more descriptive type names or for abstracting away implementation details. For example, if you later decide to change the implementation of ",(0,i.jsx)(n.code,{children:"my-class"}),", you can simply change the definition of ",(0,i.jsx)(n.code,{children:"my-class-type"})," without having to modify all the code that uses it."]}),"\n",(0,i.jsxs)(n.p,{children:["This section explained how types and CLOS are integrated, how to use ",(0,i.jsx)(n.code,{children:"typep"})," with class names, how to determine subtype relationships with ",(0,i.jsx)(n.code,{children:"subtypep"}),", and how to create type aliases with ",(0,i.jsx)(n.code,{children:"deftype"}),". The next section will cover some examples and advanced techniques using types."]}),"\n",(0,i.jsx)(n.h2,{id:"7-examples-and-advanced-techniques",children:"7. Examples and Advanced Techniques"}),"\n",(0,i.jsx)(n.p,{children:"This section demonstrates some practical applications and advanced techniques related to the Common Lisp type system."}),"\n",(0,i.jsxs)(n.h3,{id:"71-defining-custom-types-using-deftype",children:["7.1 Defining Custom Types Using ",(0,i.jsx)(n.code,{children:"deftype"})]}),"\n",(0,i.jsxs)(n.p,{children:["We've already seen a basic example of ",(0,i.jsx)(n.code,{children:"deftype"})," in the previous section. Here are some more advanced examples:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Defining a type for even integers:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(deftype even-integer ()\n  `(integer * ,(1- most-positive-fixnum) 2))\n; or\n(deftype even-integer ()\n `(satisfies evenp))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The first version uses a compound type specifier with a ",(0,i.jsx)(n.code,{children:"mod"})," test. The second version uses the ",(0,i.jsx)(n.code,{children:"satisfies"})," type specifier, which takes a function and defines a type of all objects for which the function returns true."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(typep 4 'even-integer)  ; Returns T\n(typep 5 'even-integer)  ; Returns NIL\n(typep -2 'even-integer) ; Returns T\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Defining a type for RGB colors:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(deftype rgb-color ()\n  `(vector (integer 0 255) 3))\n\n(typep #(255 0 0) 'rgb-color)   ; Returns T (Red)\n(typep #(0 255 0) 'rgb-color)   ; Returns T (Green)\n(typep #(0 0 255) 'rgb-color)   ; Returns T (Blue)\n(typep #(255 0 0 1) 'rgb-color) ; Returns NIL (wrong number of elements)\n(typep #(255 0 0.5) 'rgb-color) ; Returns NIL (wrong element type)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This defines an ",(0,i.jsx)(n.code,{children:"rgb-color"})," type as a vector of three integers between 0 and 255."]}),"\n",(0,i.jsx)(n.h3,{id:"72-using-types-for-error-checking-and-validation",children:"7.2 Using Types for Error Checking and Validation"}),"\n",(0,i.jsxs)(n.p,{children:["Types can be used for error checking and validation, both statically (with type declarations) and dynamically (with ",(0,i.jsx)(n.code,{children:"typep"}),")."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Type declarations for static checking:"})}),"\n",(0,i.jsx)(n.p,{children:"While type declarations are primarily for optimization, some Lisp implementations or external tools can use them for static analysis to catch potential type errors at compile time."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defun my-add (x y)\n  (declare (type integer x y)\n           (values integer))\n  (+ x y))\n\n(my-add 5 10)    ; Works fine\n;(my-add 5 "hello") ; Might produce a warning or error during compilation or static analysis\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["2. ",(0,i.jsx)(n.code,{children:"typep"})," for dynamic checking:"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"typep"})," can be used to perform explicit type checks at runtime and handle potential type errors gracefully."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defun safe-add (x y)\n  (if (and (typep x \'integer) (typep y \'integer))\n      (+ x y)\n      (error "Arguments must be integers.")))\n\n(safe-add 5 10)    ; Returns 15\n(safe-add 5 "hello") ; Signals an error: "Arguments must be integers."\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["3. Using ",(0,i.jsx)(n.code,{children:"check-type"})," for concise type checking and error signaling:"]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"check-type"})," macro simplifies type checking and error signaling. Its syntax is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(check-type place type-specifier &optional string)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"place"}),": A place (a variable or a generalized variable like ",(0,i.jsx)(n.code,{children:"(aref array index)"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"type-specifier"}),": The expected type."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"string"}),": An optional error message."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If the value of ",(0,i.jsx)(n.code,{children:"place"})," is not of the specified type, ",(0,i.jsx)(n.code,{children:"check-type"})," signals a correctable ",(0,i.jsx)(n.code,{children:"type-error"})," condition."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defun safe-add (x y)\n  (check-type x integer "X must be an integer.")\n  (check-type y integer "Y must be an integer.")\n  (+ x y))\n\n(safe-add 5 10)    ; Returns 15\n(safe-add 5 "hello") ; Signals a correctable TYPE-ERROR.\n'})}),"\n",(0,i.jsx)(n.h3,{id:"73-interactions-of-types-with-generic-functions-and-methods",children:"7.3 Interactions of Types with Generic Functions and Methods"}),"\n",(0,i.jsx)(n.p,{children:"Types play an important role in method dispatch in CLOS. When a generic function is called, CLOS uses the types of the arguments to determine which method to apply."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Specializers:"})}),"\n",(0,i.jsxs)(n.p,{children:["Methods are specialized on types. The ",(0,i.jsx)(n.em,{children:"specializers"})," in a ",(0,i.jsx)(n.code,{children:"defmethod"})," form specify the types of the arguments for which the method is applicable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defgeneric greet (x))\n\n(defmethod greet ((x string))\n  (format t "Hello, ~a!~%" x))\n\n(defmethod greet ((x integer))\n  (format t "Number ~a!~%" x))\n\n(greet "Alice") ; Prints "Hello, Alice!"\n(greet 10)      ; Prints "Number 10!"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the ",(0,i.jsx)(n.code,{children:"greet"})," generic function has two methods: one specialized on ",(0,i.jsx)(n.code,{children:"string"})," and one specialized on ",(0,i.jsx)(n.code,{children:"integer"}),". CLOS dispatches to the appropriate method based on the type of the argument."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Method precedence:"})}),"\n",(0,i.jsx)(n.p,{children:"When multiple methods are applicable, CLOS uses the class precedence list (CPL) to determine which method is most specific. The CPL is based on the subtype relationships between the specializers."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defclass animal () ())\n(defclass dog (animal) ())\n\n(defgeneric speak (x))\n\n(defmethod speak ((x animal))\n  (format t "Generic animal sound~%"))\n\n(defmethod speak ((x dog))\n  (format t "Woof!~%"))\n\n(speak (make-instance \'animal)) ; Prints "Generic animal sound"\n(speak (make-instance \'dog))    ; Prints "Woof!" (dog is more specific than animal)\n'})}),"\n",(0,i.jsx)(n.p,{children:"This section provided examples of defining custom types, using types for error checking and validation, and how types interact with generic functions and methods. Understanding these concepts is essential for writing robust and efficient Common Lisp code."})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>c});var i=s(7294);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);