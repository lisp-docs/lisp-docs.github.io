"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[9043],{287:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var o=t(5893),i=t(1151);const n={sidebar_position:2},a="Packages and Systems",r={id:"tutorial/projects/packages-systems",title:"Packages and Systems",description:"Original Author: Steve Losh",source:"@site/docs/tutorial/projects/packages-systems.md",sourceDirName:"tutorial/projects",slug:"/tutorial/projects/packages-systems",permalink:"/docs/tutorial/projects/packages-systems",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/projects/packages-systems.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"The Complete Idiot\u2019s Guide to Common Lisp Packages",permalink:"/docs/tutorial/projects/guide_to_packages"},next:{title:"Package Inferred Systems",permalink:"/docs/tutorial/projects/package_inferred"}},l={},c=[{value:"Structure",id:"structure",level:2},{value:"Packages",id:"packages",level:2},{value:"Systems",id:"systems",level:2},{value:"Projects",id:"projects",level:2},{value:"Recap",id:"recap",level:2}];function d(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components},{DictionaryLink:t,GlossaryTerm:n}=s;return t||m("DictionaryLink",!0),n||m("GlossaryTerm",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.h1,{id:"packages-and-systems",children:"Packages and Systems"}),"\n",(0,o.jsxs)(s.blockquote,{children:["\n",(0,o.jsxs)(s.p,{children:["Original Author: ",(0,o.jsx)(s.a,{href:"https://stevelosh.com",children:"Steve Losh"})]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.a,{href:"https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/#s30-modern-common-lisp",children:"Source"})}),"\n",(0,o.jsx)(s.p,{children:"Slightly modified to fit this tutorial."}),"\n"]}),"\n",(0,o.jsx)(s.h2,{id:"structure",children:"Structure"}),"\n",(0,o.jsxs)(s.p,{children:["Common Lisp's terminology for various parts of projects is often confusing to new people because it's old and uses a lot of words that we use now (like ",(0,o.jsx)(n,{term:"package",children:(0,o.jsx)("i",{children:(0,o.jsx)(s.a,{href:"https://lisp-docs.github.io/cl-language-reference/chap-11/bb-b-package-concepts",children:"\u201cpackage\u201d"})})}),") to mean subtly different things than people mean today. Things get easier once you internalize what Common Lisp means by the terms."]}),"\n",(0,o.jsx)(s.h2,{id:"packages",children:"Packages"}),"\n",(0,o.jsxs)(s.p,{children:['We often see questions in IRC and Discord that look something like: "How do I export a class from a package"? Questions worded like this are a sign of a very common misunderstanding about what packages in Common Lisp ',(0,o.jsx)(s.em,{children:"actually are"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"A package in Common Lisp is a container for symbols."})," That's it. They're a way to group related names (",(0,o.jsx)(n,{term:"symbol",children:(0,o.jsx)(t,{term:"symbol",children:(0,o.jsx)("b",{children:"symbols"})})}),") together so you don't have to do the miserable prefixing of every name with ",(0,o.jsx)(s.code,{children:"mylibrary-..."})," like you need to do in Emacs Lisp or C to avoid name clashes."]}),"\n",(0,o.jsxs)(s.p,{children:["You don't export a class from a package, you export a ",(0,o.jsx)(n,{term:"symbol",children:(0,o.jsx)(t,{term:"symbol",children:(0,o.jsx)("b",{children:"symbol"})})}),". You don't import a function, you import the symbol it's attached to. This sounds pedantic, but is important to keep clear in your head as you start using the package system. If you're not clear on what exactly a symbol is, I wrote a ",(0,o.jsx)(s.a,{href:"https://stevelosh.com/blog/2016/06/symbolic-computation/",children:"separate post"})," just about symbols which you might find helpful."]}),"\n",(0,o.jsx)(s.p,{children:"Another major tripping point for new people is the relationship between packages and files. Or, rather: the completely lack of any relationship in Common Lisp."}),"\n",(0,o.jsxs)(s.p,{children:["In many languages like Python, Java, or Clojure, a file's package and its location on the hard drive are tied together. For example: when you say import ",(0,o.jsx)(s.code,{children:"foo.bar.baz"})," in Python, Python will look for a ",(0,o.jsx)(s.code,{children:"baz.py"})," file inside the ",(0,o.jsx)(s.code,{children:"foo/bar/"})," directory (it's a little more complicated than this, but that doesn't matter for this example)."]}),"\n",(0,o.jsxs)(s.p,{children:["In Common Lisp, this is not the case. ",(0,o.jsx)(s.strong,{children:"Files and packages are completely unrelated in Common Lisp."})," You can have many files that all work in the same package, or one file that switches between many packages, or even create or modify packages at runtime."]}),"\n",(0,o.jsxs)(s.p,{children:["This gives you the flexibility to work however you want. For example: in my procedural art library ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/flax",children:"Flax"})," most of the packages are each used in one specific file, much like you would do in modern languages. But the flax.drawing package contains not only a drawing protocol but also several implementations of that protocol (PNG, SVG, etc), and so I split the code into a ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/flax/tree/master/src/drawing",children:"series of separate files"}),", each one dealing with how to draw a single format (plus one for the protocol itself)."]}),"\n",(0,o.jsx)(s.p,{children:"I could have created separate packages for each implementation and set up the imports/exports between them, but I didn't feel like the extra boilerplate was worth it. Common Lisp is flexible enough to let you make such choices."}),"\n",(0,o.jsxs)(s.p,{children:["So if files and packages aren't related, the next question is: how does Common Lisp know where to ",(0,o.jsx)(s.em,{children:"find"})," anything on disk when it comes time to load the code?"]}),"\n",(0,o.jsx)(s.h2,{id:"systems",children:"Systems"}),"\n",(0,o.jsx)(s.p,{children:"A system in Common Lisp is a collection of serveral things:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Some code."}),"\n",(0,o.jsx)(s.li,{children:"A description of how to load that code."}),"\n",(0,o.jsx)(s.li,{children:"A list of other systems this system depends on, which need to be loaded prior to loading this one."}),"\n",(0,o.jsx)(s.li,{children:"Some metadata like author, license, version, homepage, etc."}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["The Common Lisp language itself has no knowledge of systems. If you look at ",(0,o.jsx)(s.a,{href:"https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node120.html",children:"section 11.9"})," of CLtL2 you'll see that it was imagined that each author would write their own custom file to load their code. But since Common Lisp gives you the power to abstract almost anything, people eventually abstracted the process of loading Common Lisp code."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{href:"https://asdf.common-lisp.dev/",children:"ASDF"}),' is a Common Lisp library bundled with most modern implementations which handles defining and loading systems. The name ASDF stands for "Another System Definition Facility", so as you might guess there have been several other such libraries. ASDF is the one everyone uses today.']}),"\n",(0,o.jsx)(s.p,{children:"ASDF standardizes the process of defining a system into something like this:"}),"\n",(0,o.jsxs)(s.p,{children:["The system definition(s) for a project called ",(0,o.jsx)(s.code,{children:"foo"})," would be in a file named ",(0,o.jsx)(s.code,{children:"foo.asd"}),".\nEach system is defined with a ",(0,o.jsx)(s.code,{children:"(defsystem ...)"}),' form inside this file.\nWe\'ll talk more about what a "project" is shortly. Note the extension of the file is ',(0,o.jsx)(s.code,{children:"asd"}),", not ",(0,o.jsx)(s.code,{children:"asdf"}),", which is a little confusing, but was probably chosen to work in environments with three-letter-extension limits."]}),"\n",(0,o.jsxs)(s.p,{children:["The ",(0,o.jsx)(s.a,{href:"https://asdf.common-lisp.dev/#documentation",children:"ASDF manual"})," is the definitive resource for the syntax and semantics of ",(0,o.jsx)(s.code,{children:"defsystem"}),", but can be a little heavy to read if you're just getting started. Another way to get started is to read some .asd files of some small-to-medium sized open source projects and see how they handle things."]}),"\n",(0,o.jsx)(s.p,{children:"Systems and packages are orthogonal in Common Lisp. Some systems (like small libraries) will define exactly one package. Some systems will define multiple packages. Rarely a system might not define any new packages, but will use or add to an existing one."}),"\n",(0,o.jsx)(s.p,{children:"For example:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["My directed graph library ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/cl-digraph",children:"cl-digraph"})," contains a system called ",(0,o.jsx)(s.code,{children:"cl-digraph"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:["That system has a description of how to load the code, which lives in the ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/cl-digraph/blob/master/cl-digraph.asd",children:(0,o.jsx)(s.code,{children:"cl-digraph.asd"})})," file."]}),"\n",(0,o.jsxs)(s.li,{children:["One of the files specified for loading is ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/cl-digraph/blob/master/package.lisp",children:(0,o.jsx)(s.code,{children:"package.lisp"})}),", which creates a package called ",(0,o.jsx)(s.code,{children:"digraph"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["Even though ASDF standardizes some aspects of system definition, it still gives you plenty of flexibility. As you read projects by different authors you'll encounter different ways of organizing systems \u2014 this can be a little overwhelming at first, but it means you can organize a system in the way that works ",(0,o.jsx)(s.em,{children:"best for that system"}),", which is really nice once you've got some experience under your belt."]}),"\n",(0,o.jsx)(s.p,{children:"One example of this is how people define packages for their systems. There are a couple of common ways to do this you'll see in the wild:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["A single ",(0,o.jsx)(s.code,{children:"package.lisp"})," file which contains all the definitions for all the packages in the project, and gets loaded before all other files. This is the strategy I usually prefer."]}),"\n",(0,o.jsx)(s.li,{children:"Each file defines its package at the top of the file, much like you would in Clojure or other modern languages. Care is taken in the system definition to load the files in the correct order so that each package is defined before it is ever used.\nTo review: a system is a collection of code and a description of how to load it, a list of its dependencies, and some metadata. Now let's move up one level higher to the final layer of structure you need to know about."}),"\n"]}),"\n",(0,o.jsx)(s.h2,{id:"projects",children:"Projects"}),"\n",(0,o.jsx)(s.p,{children:"A project in Common Lisp is not an official term defined anywhere that I know of, but is a word that's generally used to mean something like a library, a framework, an application, etc."}),"\n",(0,o.jsxs)(s.p,{children:["A project will usually define at least one system, because systems are where you describe how to load the code, and if a project didn't define a system how would you know how to load its code? My string-wrapping library ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/bobbin",children:"Bobbin"})," is a project that defines ",(0,o.jsx)(s.em,{children:"two"})," systems:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["The ",(0,o.jsx)(s.code,{children:"bobbin"})," system contains the actual data structure and API. It has no dependencies."]}),"\n",(0,o.jsxs)(s.li,{children:["The ",(0,o.jsx)(s.code,{children:"bobbin/test"})," system contains the unit tests. It depends on the ",(0,o.jsx)(s.code,{children:"bobbin"})," system (because that's the code it's going to test) and the ",(0,o.jsx)(s.code,{children:"1am"})," system (a unit test framework). I made this a separate system because it allows users to load the main code without also having to load the unit testing framework if they're not going to be running the tests."]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["Both of these systems are defined in the ",(0,o.jsx)(s.a,{href:"https://github.com/sjl/bobbin/blob/master/bobbin.asd",children:(0,o.jsx)(s.code,{children:"bobbin.asd"})})," file. ASDF ",(0,o.jsx)(s.a,{href:"https://asdf.common-lisp.dev/asdf.html#index-find_002dsystem",children:"treats systems with a forward slash in their name specially"})," and knows to look for them in the asd file named with the text before the slash."]}),"\n",(0,o.jsx)(s.p,{children:"We saw how Common Lisp has no concept of a system \u2014 that concept comes from ASDF. Similarly, ASDF has no concept of the internet or of reaching out to somewhere to download things. ASDF assumes you have somehow acquired the systems you want to load and stored them on your hard drive, perhaps by sending a check to an address and receiving a copy of the code on floppy disk, as many of my old Lisp books offer in their final pages."}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{href:"https://www.quicklisp.org/beta/",children:"Quicklisp"}),' is another library that works on top of ASDF to provide the "download projects from the internet automatically if necessary" functionality that people expect in the modern world. So when you say ',(0,o.jsx)(s.code,{children:"(ql:quickload :bobbin)"})," you\u2019re asking Quicklisp to download Bobbin (and any dependencies) if necessary, and then hand it off to ASDF to actually load the code of the bobbin system."]}),"\n",(0,o.jsx)(s.p,{children:"Unlike ASDF, Quicklisp is relatively new in the Common Lisp world (it's only about eight years old) and so is not bundled with any modern Lisp implementations that I know of, which is why you need to install it separately."}),"\n",(0,o.jsx)(s.h2,{id:"recap",children:"Recap"}),"\n",(0,o.jsx)(s.p,{children:"Here's a quick recap of the different layers of project structure you'll encounter in Common Lisp. Jot these down on a post it note you can refer to as you're learning."}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Files"})," are files on your hard drive."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Packages"})," are containers of symbols. They are orthogonal to files."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Systems"})," are collections of code, instructions on how to load that code, dependency lists, and metadata. They are orthogonal to packages."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Projects"}),' are high-level collections of... "stuff" such as code, documentation, maybe some image assets, etc. They are (mostly) orthogonal to systems (are you seeing a trend here?).']}),"\n",(0,o.jsx)(s.li,{children:"Common Lisp itself knows about files and packages."}),"\n",(0,o.jsx)(s.li,{children:"ASDF adds systems."}),"\n",(0,o.jsx)(s.li,{children:"Quicklisp adds the internet."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}function m(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},1151:(e,s,t)=>{t.d(s,{Z:()=>r,a:()=>a});var o=t(7294);const i={},n=o.createContext(i);function a(e){const s=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(n.Provider,{value:s},e.children)}}}]);