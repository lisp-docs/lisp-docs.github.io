"use strict";(self.webpackChunklisp_docs_github_io=self.webpackChunklisp_docs_github_io||[]).push([[7893],{9280:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>a,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var s=i(5893),r=i(1151);const t={sidebar_position:9.6},o="Debugging Common Lisp",l={id:"tutorial/debugging",title:"Debugging Common Lisp",description:"Tutorial: Debugging in Common Lisp with SBCL, SLIME, and SLY",source:"@site/docs/tutorial/debugging.md",sourceDirName:"tutorial",slug:"/tutorial/debugging",permalink:"/docs/tutorial/debugging",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/lisp-docs.github.io/tree/main/docs/tutorial/debugging.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",sidebarPosition:9.6,frontMatter:{sidebar_position:9.6},sidebar:"tutorialSidebar",previous:{title:"Documenting your Code",permalink:"/docs/tutorial/documentation"},next:{title:"Advanced Topics",permalink:"/docs/category/advanced-topics"}},d={},c=[{value:"<strong>Tutorial: Debugging in Common Lisp with SBCL, SLIME, and SLY</strong>",id:"tutorial-debugging-in-common-lisp-with-sbcl-slime-and-sly",level:2},{value:"<strong>Introduction</strong>",id:"introduction",level:3},{value:"<strong>1. Setting Up SBCL for Debugging</strong>",id:"1-setting-up-sbcl-for-debugging",level:3},{value:"<strong>1.1 Installing SBCL</strong>",id:"11-installing-sbcl",level:4},{value:"<strong>1.2 Compiler Settings for Debugging</strong>",id:"12-compiler-settings-for-debugging",level:4},{value:"<strong>1.3 Optimizing for Performance</strong>",id:"13-optimizing-for-performance",level:4},{value:"<strong>2. Using SLIME/SLY for Interactive Development</strong>",id:"2-using-slimesly-for-interactive-development",level:3},{value:"<strong>2.1 Setting Up SLIME/SLY</strong>",id:"21-setting-up-slimesly",level:4},{value:"<strong>3. Using the SBCL Debugger</strong>",id:"3-using-the-sbcl-debugger",level:3},{value:"<strong>3.1 Triggering the Debugger</strong>",id:"31-triggering-the-debugger",level:4},{value:"<strong>3.2 Debugging in the SBCL REPL</strong>",id:"32-debugging-in-the-sbcl-repl",level:4},{value:"<strong>4. Debugging Workflow: Interactive Debugging with SLIME/SLY</strong>",id:"4-debugging-workflow-interactive-debugging-with-slimesly",level:3},{value:"<strong>4.1 Example Workflow: Handling Errors and Modifying Code in the Debugger</strong>",id:"41-example-workflow-handling-errors-and-modifying-code-in-the-debugger",level:4},{value:"<strong>4.2 Example Workflow: Live Modifications and Testing Stack Data</strong>",id:"42-example-workflow-live-modifications-and-testing-stack-data",level:4},{value:"<strong>5. Best Practices for Debugging in Common Lisp</strong>",id:"5-best-practices-for-debugging-in-common-lisp",level:3},{value:"<strong>Conclusion</strong>",id:"conclusion",level:3}];function g(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"debugging-common-lisp",children:"Debugging Common Lisp"}),"\n",(0,s.jsx)(n.h2,{id:"tutorial-debugging-in-common-lisp-with-sbcl-slime-and-sly",children:(0,s.jsx)(n.strong,{children:"Tutorial: Debugging in Common Lisp with SBCL, SLIME, and SLY"})}),"\n",(0,s.jsx)(n.h3,{id:"introduction",children:(0,s.jsx)(n.strong,{children:"Introduction"})}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will guide you through the process of debugging in Common Lisp with an emphasis on practical, real-world workflows. We\u2019ll cover:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Setting up SBCL for efficient debugging."})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Using SLIME/SLY for interactive development."})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Common debugging workflows and best practices."})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Debugging with the SBCL debugger, modifying live code, and testing in-place."})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s get started!"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"1-setting-up-sbcl-for-debugging",children:(0,s.jsx)(n.strong,{children:"1. Setting Up SBCL for Debugging"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SBCL"})," (Steel Bank Common Lisp) is a highly efficient implementation of Common Lisp, and it\u2019s widely used for production systems. To ensure a smooth debugging experience, you need to configure your compiler and runtime settings properly."]}),"\n",(0,s.jsx)(n.h4,{id:"11-installing-sbcl",children:(0,s.jsx)(n.strong,{children:"1.1 Installing SBCL"})}),"\n",(0,s.jsxs)(n.p,{children:["Ensure SBCL is installed and available on your system. You can download it from ",(0,s.jsx)(n.a,{href:"http://www.sbcl.org/",children:"SBCL's official website"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"You can check if SBCL is installed via:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"sbcl --version\n"})}),"\n",(0,s.jsx)(n.h4,{id:"12-compiler-settings-for-debugging",children:(0,s.jsx)(n.strong,{children:"1.2 Compiler Settings for Debugging"})}),"\n",(0,s.jsxs)(n.p,{children:["To set the SBCL compiler settings for debugging, you should modify the ",(0,s.jsx)(n.code,{children:"sbcl"})," environment settings before you start a session. Here are some useful options to enable more detailed debug information:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Disable optimization"}),": Disable optimizations when you need more detailed debugging information. This will slow down execution but make debugging much easier."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(setq *sbcl-optimize* :debug)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Enable full debugging info"}),": To keep debugging symbols, use the ",(0,s.jsx)(n.code,{children:"*debugger-hook*"})," and ",(0,s.jsx)(n.code,{children:"*compile-file-hook*"})," to help in debugging sessions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Control Debugging Level"}),": You can set the ",(0,s.jsx)(n.code,{children:"*compile-verbose*"})," flag to control the level of debugging information:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(setq *compile-verbose* t)\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"13-optimizing-for-performance",children:(0,s.jsx)(n.strong,{children:"1.3 Optimizing for Performance"})}),"\n",(0,s.jsx)(n.p,{children:"When you're not debugging and want to focus on performance, consider using the following compiler settings for SBCL:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use aggressive optimizations"}),": SBCL offers several optimization levels. For example, you can set ",(0,s.jsx)(n.code,{children:":speed"})," to maximize performance and ",(0,s.jsx)(n.code,{children:":safety"})," to ensure no runtime errors."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(setq *sbcl-optimize* :speed)\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can also manually adjust SBCL's optimization during function compilation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defmethod some-function ((x some-type))\n  (declare (optimize (speed 3) (safety 0) (debug 0)))\n  ; your code here\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will maximize performance while avoiding unnecessary debugging info."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"2-using-slimesly-for-interactive-development",children:(0,s.jsx)(n.strong,{children:"2. Using SLIME/SLY for Interactive Development"})}),"\n",(0,s.jsx)(n.h4,{id:"21-setting-up-slimesly",children:(0,s.jsx)(n.strong,{children:"2.1 Setting Up SLIME/SLY"})}),"\n",(0,s.jsx)(n.p,{children:"SLIME and SLY are powerful tools that provide interactive programming, debugging, and REPL support for Common Lisp."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SLIME"})," is an older, but still widely used tool, whereas ",(0,s.jsx)(n.strong,{children:"SLY"})," is a more recent alternative that provides better performance and new features. Both integrate well with Emacs."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Install SLIME/SLY via Quicklisp"})," (if you haven't already):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"For SLIME:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "slime")\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"For SLY (the modern alternative to SLIME):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(ql:quickload "sly")\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configure Emacs for SLIME/SLY"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Add the following to your Emacs configuration file (",(0,s.jsx)(n.code,{children:"~/.emacs.d/init.el"})," or ",(0,s.jsx)(n.code,{children:".emacs"}),"):"]}),"\n",(0,s.jsx)(n.p,{children:"For SLIME:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(setq inferior-lisp-program "/path/to/sbcl")  ;; Path to SBCL\n(require \'slime)\n(slime-setup)\n'})}),"\n",(0,s.jsx)(n.p,{children:"For SLY:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(setq inferior-lisp-program "/path/to/sbcl")  ;; Path to SBCL\n(require \'sly)\n(sly-setup)\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"3-using-the-sbcl-debugger",children:(0,s.jsx)(n.strong,{children:"3. Using the SBCL Debugger"})}),"\n",(0,s.jsx)(n.p,{children:"The SBCL debugger allows you to inspect your program\u2019s state at runtime, and even modify code without restarting the program."}),"\n",(0,s.jsx)(n.h4,{id:"31-triggering-the-debugger",children:(0,s.jsx)(n.strong,{children:"3.1 Triggering the Debugger"})}),"\n",(0,s.jsx)(n.p,{children:"The SBCL debugger can be triggered automatically when an error occurs, or you can manually invoke it."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Automatic Trigger"}),": If your program hits an error, the debugger will activate automatically. It will show you the backtrace, the current stack frame, and allow you to inspect variables."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Manually Triggering"}),": You can invoke the debugger manually in a running program by using the ",(0,s.jsx)(n.code,{children:"sb-debug"})," package:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(sb-debug:debug)\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"32-debugging-in-the-sbcl-repl",children:(0,s.jsx)(n.strong,{children:"3.2 Debugging in the SBCL REPL"})}),"\n",(0,s.jsx)(n.p,{children:"The REPL provides interactive debugging features. You can step through code, inspect the stack, and even modify variables."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Viewing the Stack"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["In the SBCL debugger, use ",(0,s.jsx)(n.code,{children:":stack"})," to inspect the call stack. This will show the functions in the current call hierarchy."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Inspecting Variables"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["You can inspect variables in the current frame using ",(0,s.jsx)(n.code,{children:":inspect"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:":inspect some-variable\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stepping Through Code"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["You can step through the code using ",(0,s.jsx)(n.code,{children:":step"}),", ",(0,s.jsx)(n.code,{children:":next"}),", ",(0,s.jsx)(n.code,{children:":finish"}),", and ",(0,s.jsx)(n.code,{children:":cont"})," commands."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"4-debugging-workflow-interactive-debugging-with-slimesly",children:(0,s.jsx)(n.strong,{children:"4. Debugging Workflow: Interactive Debugging with SLIME/SLY"})}),"\n",(0,s.jsx)(n.p,{children:"Now let\u2019s go through a common debugging workflow where we interact with the code during runtime."}),"\n",(0,s.jsx)(n.h4,{id:"41-example-workflow-handling-errors-and-modifying-code-in-the-debugger",children:(0,s.jsx)(n.strong,{children:"4.1 Example Workflow: Handling Errors and Modifying Code in the Debugger"})}),"\n",(0,s.jsx)(n.p,{children:"Imagine you have the following function that throws an error:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defun divide (x y)\n  (if (zerop y)\n      (error "Cannot divide by zero")\n      (/ x y)))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When you call ",(0,s.jsx)(n.code,{children:"(divide 5 0)"}),", the program will trigger an error."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 1: Start the REPL in Emacs with SLIME/SLY"}),". You\u2019ll see the error message in the SLIME/SLY buffer and automatically be dropped into the SBCL debugger."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 2: Inspect the error."})," Look at the stack, and check the values of ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"y"})," in the debugger."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 3: Modify the code in-place"}),". Let\u2019s say you want to add a check for negative numbers in the divisor. You can edit the code directly in the REPL and reload the definition."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defun divide (x y)\n  (if (or (zerop y) (< y 0))\n      (error "Invalid divisor")\n      (/ x y)))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["After modifying the code, simply continue the execution using ",(0,s.jsx)(n.code,{children:":cont"})," to let the code run with the updated behavior."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"42-example-workflow-live-modifications-and-testing-stack-data",children:(0,s.jsx)(n.strong,{children:"4.2 Example Workflow: Live Modifications and Testing Stack Data"})}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s say you are debugging a function and encounter an error. The error stops execution, but you want to continue working with the data at that point."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 1: Inspect the current stack frame"})," to view local variables."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 2: Test changes live in the debugger"}),". You can change the value of a variable in the current frame:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(setf some-variable new-value)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 3: Continue execution with the new value"})," by using ",(0,s.jsx)(n.code,{children:":cont"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"5-best-practices-for-debugging-in-common-lisp",children:(0,s.jsx)(n.strong,{children:"5. Best Practices for Debugging in Common Lisp"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use SLIME/SLY for fast iterative development"}),": You can quickly test code, modify it, and inspect errors without restarting the whole process."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep debugging symbols enabled when debugging"}),": Turn off optimizations and debug info only when performance is not an issue."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interact with live data"}),": When an error occurs, don\u2019t just fix the code and continue\u2014interact with the stack and modify state to test your fix without restarting."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Understand the debugging tools"}),": Learn how to use the SBCL debugger effectively, and use SLIME/SLY to interact with your program in real-time."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"conclusion",children:(0,s.jsx)(n.strong,{children:"Conclusion"})}),"\n",(0,s.jsx)(n.p,{children:"With SBCL, SLIME/SLY, and the SBCL debugger, debugging in Common Lisp is both powerful and flexible. By following the steps in this tutorial, you should be able to interact with your code, inspect errors, modify live code, and continue execution with minimal interruptions."}),"\n",(0,s.jsx)(n.p,{children:"Remember to always test your changes interactively in the REPL and use the SBCL debugger to manage your program\u2019s state in real-time!"}),"\n",(0,s.jsx)(n.p,{children:"Happy debugging!"})]})}function a(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>o});var s=i(7294);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);